#define COLOR
#define CPX
#define TESSLVL 0
#define NVALS 2
#define NPZ Noise(1)
// notes:
// 1. second shader in pipeline
// 2. input from vertex shader
// 3. output to fragment shader
// 

//#version 120
//#extension GL_EXT_geometry_shader4 : enable

#ifndef _UTILS_H
#define _UTILS_H
// ########## begin utils.h #########################
float lerp(float x, float xmin, float xmax, float ymin, float ymax){
	x=x<xmin?xmin:x;
	x=x>xmax?xmax:x;
	float a=(ymax-ymin)/(xmax-xmin);
	float b=ymin-a*xmin;
	float y=a*x+b;
	return y;
}
// ########## end  utils.h #########################
#endif
#ifdef COLOR
varying in vec4 Color_G[];
varying out vec4 Color;
#endif
#if NVALS >0
varying in vec4 Vertex1_G[];
varying in vec4 Vertex2_G[];
varying out vec4 Vertex1;
varying out vec4 Vertex2;

#define PI		3.14159265359

uniform int tessLevel;
uniform vec3 pv;
uniform float freqmip;

float logf=0;
float nbamp=0;
vec4 gv=vec4(0);
float amplitude = 1.0;
vec3 bump;
float g=0;
float b=0;
bool newcell=false;

#define GEOM

// ########## begin noise_funcs.frag #########################
uniform sampler3D noise3DTexture;
uniform float fmax;

vec3 v1;
vec3 v2;
vec3 v3;
vec3 df;

#ifdef N3D
// classic Perlin noise using a 3D texture 
#define FSCALE 0.03125
#ifdef VNOISE
vec4 noise3D(vec3 p) {
	return (texture3D (noise3DTexture, FSCALE*p) - 0.5); 
}
#else
float noise3D(vec3 p) {
	return 2.0 * (texture3D (noise3DTexture, FSCALE*p ).r - 0.5); 
}
#endif
#else
#define FSCALE 1.0
// ########## begin noise.frag #########################

uniform sampler2D permTexture;

#ifndef CPX
#ifdef _BUMPS_
//#define VNOISE
#endif
#endif

/*
 * To create offsets of one texel and one half texel in the
 * texture lookup, we need to know the texture image size.
 */
#define ONE 0.00390625
#define ONEHALF 0.001953125

// The numbers above are 1/256 and 0.5/256, change accordingly
// if you change the code to use another texture size.

#define fade(t) t*t*t*(t*(t*6.0-15.0)+10.0)

// returns classic Perlin noise and derivatives using a 2D texture

vec4 noise3D(vec3 P){
/*
vec4 noise3D(float f) {
	vec3 P;
	float df=f/fmax;
	vec3 P1=v1*f;
	vec3 P2=v2*f;
	
    if(df>=1)
        P=P2;
    else if(df<0.25)
        P=P1;
    else{
        float m=smoothstep(0.25,1.0,df);
        P=mix(P1,P2,m);
    }
*/
    vec4 vout=vec4(0);
    vec3 Pi = ONE*(floor(P));
    vec3 Pf = fract(P);

    float b00 = texture2D(permTexture, Pi.xy).a;
    float b10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a;
    float b01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a;
    float b11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;
     
    // contributions from (x=0, y=0), z=0 and z=1
    vec3 grad000 = texture2D(permTexture, vec2(b00, Pi.z)).rgb * 2.0-1.0;
    vec3 grad001 = texture2D(permTexture, vec2(b00, Pi.z + ONE)).rgb * 2.0-1.0;
 
    // contributions from (x=0, y=1), z=0 and z=1
    vec3 grad010 = texture2D(permTexture, vec2(b01, Pi.z)).rgb * 2.0-1.0;
    vec3 grad011 = texture2D(permTexture, vec2(b01, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=0), z=0 and z=1
    vec3 grad100 = texture2D(permTexture, vec2(b10, Pi.z)).rgb *2.0- 1.0;
    vec3 grad101 = texture2D(permTexture, vec2(b10, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=1), z=0 and z=1
    vec3 grad110 = texture2D(permTexture, vec2(b11, Pi.z)).rgb * 2.0- 1.0;
    vec3 grad111 = texture2D(permTexture, vec2(b11, Pi.z + ONE)).rgb * 2.0-1.0;

    float n000 = dot(grad000, Pf);
    float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));    
    float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));
    float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));    
    float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));
    float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));    
    float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));
    float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));
    
    vec4 n1=vec4(n000, n001, n010, n011);
    vec4 n2=vec4(n100, n101, n110, n111);
 
    vec3 fpt=fade(Pf);
   
   // Blend contributions along x
   
    vec4 n_x = mix(n1, n2, fpt.x);
    // Blend contributions along y
    vec2 n_xy = mix(n_x.xy, n_x.zw, fpt.y);
    // Blend contributions along z
    float n_xyz = mix(n_xy.x, n_xy.y, fpt.z);
    vout.x=n_xyz;
    
#ifdef VNOISE

#define DELTA (1.15*ONEHALF)
    
    vec3 Pid = ONE*floor(P+DELTA);
    vec3 Pfd = fract(P+DELTA);

    if(Pid.x>Pi.x)
   	 	Pfd.x=1.0;
    if(Pid.y>Pi.y)
   	 	Pfd.y=1.0;
    if(Pid.z>Pi.z)
   	 	Pfd.z=1.0;
     
    // estimate x derivative
 
    vec3 Pd=P+vec3(DELTA);
    vec3 dpt=fade(Pfd);
    
    vec4 gx1=vec4(grad000.x, grad001.x, grad010.x,  grad011.x);
    vec4 gx2=vec4(grad100.x, grad101.x, grad110.x,  grad111.x);
   
    vec4 x1=n1+gx1*DELTA;
    vec4 x2=n2+gx2*DELTA;
              
    vec4 x_delta = mix(x1,x2,dpt.x);
    vec2 vx = mix(x_delta.xy, x_delta.zw, fpt.y); 
    vout.y=(mix(vx.x, vx.y, fpt.z)-n_xyz)/DELTA;

   // estimate y derivative

    vec4 gy1=vec4(grad000.y, grad001.y, grad010.y,  grad011.y);
    vec4 gy2=vec4(grad100.y, grad101.y, grad110.y,  grad111.y);
 
    vec4 y1=n1+gy1*DELTA;
    vec4 y2=n2+gy2*DELTA;
 
    vec4 y_delta = mix(y1,y2,fpt.x);
    vec2 vy = mix(y_delta.xy, y_delta.zw, dpt.y); 
    vout.z=(mix(vy.x, vy.y, fpt.z)-n_xyz)/DELTA;

   // estimate z derivative

    vec4 gz1=vec4(grad000.z, grad001.z, grad010.z,  grad011.z);
    vec4 gz2=vec4(grad100.z, grad101.z, grad110.z,  grad111.z);
 
    vec4 z1=n1+gz1*DELTA;
    vec4 z2=n2+gz2*DELTA;
    vec4 z_delta = mix(z1,z2,fpt.x);
    vec2 vz = mix(z_delta.xy, z_delta.zw, fpt.y); 
    vout.w=(mix(vz.x, vz.y, dpt.z)-n_xyz)/DELTA;
#endif
    return vout;
}

// ########## end noise.frag #########################
#endif

#define GCURVE1(t) (0.5*t*t*(3.0-t))
#define DCURVE1(t) 1.5*t*(2-t)
#define SCURVE1(t) (t*t*(3.0 - 2.0*t) )

struct noise_info {
	float fact;
	float delta;
	float orders;
	float freq;
	float H;
	float L;
	float bias;
	float ampl;
	float offset;
	float smooth;
	float clamp;
	float logf;
	float ma;
	float mb;
	bool sqr;
	bool invert;
	bool absval;
	bool uns;
};

uniform noise_info nvars[NVALS];

#define VMAX 0.5

float noise_fade=0;

float reset(){
	v1=Vertex1.xyz;
	return 0.0;
}
float corialis(float a){
    vec3 vt=(v1-0.5)*2.0;
    
	float x=vt.x;
	float y=vt.z;
	float z=vt.y;
	float r=(x*x+y*y);
	float angle=a*2.0*PI*r;
	float s=sin(angle);
	float c=cos(angle);
	vt=vec3(x*c-y*s,x*s+y*c,z);
	v1=vt*0.5+0.5;
	return 0.0;
}

#define twist(a,b) corialis(a)+b+reset()

// multi-order procedural 3d noise

vec4 Noise(int index) {
	noise_info info=nvars[index];

    float orders=min(info.orders, Vertex1.w-info.logf-freqmip);
    noise_fade = lerp(orders,-1.0,1.0,0.0,1.0);

    if(noise_fade<=0)
    	return vec4(0.0);

	float gval=0.0,x,y;
	float fact=info.fact;
	vec4 result=vec4(0);
	vec4 last_val=vec4(0);
	vec4 val,nvec;
	
	float f=info.freq;
	float gain=1.0-info.bias;
	float weight=1.0;
    float octaves=max(orders,1.0);

	int n=int(octaves);
	float rem=octaves-float(n);
	n=rem>0.0?n+1:n;
	float rmin=info.smooth*VMAX;
	if(!info.absval)
		rmin *=2;
	float clip=info.clamp*VMAX;
	for(int i=0;i<n;i++) {
		float df=f/fmax;
		/*
		if(df>1)
			nvec=noise3D(v2*f);
		else
		nvec=noise3D(v1*f);
		*/
	    //if(df>=1)
	    //    nvec=noise3D(v2*f);
	   // else if(df<0.25)
	   //     nvec=noise3D(v1*f);
	   // else{
	        float m=smoothstep(0.1,1.75,df);
	        vec4 P1=noise3D(v1*f);
	        vec4 P2=noise3D(v2*f);
	        nvec=mix(P1,P2,m);
	   // }
	    
        //nvec=noise3D(f);
		nvec.yzw*=f;
		if(nvec.x>clip+0.1*nvec.x){
			nvec.x=clip+0.1*nvec.x;
			nvec.yzw*=0.1;
		}		
		f*=info.L;
		if(info.absval) {
			if(nvec.x<0)
			    nvec=-nvec;
			if(rmin>0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
				x=GCURVE1(x);
			    nvec.x=rmin*x;
			}
			nvec.x=VMAX-nvec.x;
			nvec.yzw=-nvec.yzw;
			nvec*=2;
		}
		else{
			nvec.x=VMAX+nvec.x;
		    if(rmin>0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
			    x=GCURVE1(x);
			    nvec.x=rmin*x;
		    }
		}
		val=nvec*weight*fact;
		last_val=result;
		result += val;
		fact*=info.delta;
		if(weight<=0)
		    break;
		weight*=nvec.x*gain+info.bias;
		weight=clamp(weight,0.0,1.0);
	}
	if(rem>0.0)
		result=last_val+rem*val;
	if(info.sqr){
		result.yzw*=2*abs(result.x);  // derivative of x^2 ?
		if(info.uns)
			result.x*=result.x;
		else
		    result.x*=abs(result.x);
	}
	if(info.invert)
		result=-result;
	result*=noise_fade*info.ampl;
	result.x+=noise_fade*info.offset;
	return result;	
}
#ifdef _BUMPS_
#ifdef VNOISE
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x; \
 	if(lighting) { \
 	    df=gv.yzw; \
 	    df*=0.1*noise_fade*bump_ampl; \
		bump = bump + amplitude*df; \
    }
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g= gv.x; \
 	if(lighting) { \
 	    float delta=bump_delta; \
		nbamp = 0.1*noise_fade*bump_ampl/delta; \
		b = g; \
		v1 = vec3(Vertex1.x+delta,Vertex1.y,Vertex1.z);  \
		v2 = vec3(Vertex2.x+delta,Vertex2.y,Vertex2.z);  \
 		gv = func; \
		df.x =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y+delta,Vertex1.z); \
		v2 = vec3(Vertex2.x,Vertex2.y+delta,Vertex2.z); \
 		gv = func; \
		df.y =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y,Vertex1.z+delta); \
		v2 = vec3(Vertex2.x,Vertex2.y,Vertex2.z+delta); \
 		gv = func; \
		df.z =gv.x; \
		df = (df-vec3(b,b,b))*(nbamp); \
		bump = bump + amplitude*df; \
    }
#endif
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x;
#endif

#define NOISE_COLOR(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
    vec4 ncolor=func; \
 	color =ncolor+color;

#define NOISE_VARS \
    df=vec3(0); \
    nbamp=0; \
    g=0; \
    b=0; \
    noise_fade=0; \
	gv=vec4(0);

// ########## end noise_funcs.frag #########################

//######################################################

#if TESSLVL >0
void ProduceVertex(float s, float t){
#else
void ProduceVertex(int i){
#endif
    float amp=1.0e-6; // need to use ht scale factor
#if TESSLVL >0	
	Vertex1=s*(Vertex1_G[2]-Vertex1_G[0]) + t*(Vertex1_G[1]-Vertex1_G[0])+Vertex1_G[0];
	Vertex2=s*(Vertex2_G[2]-Vertex2_G[0]) + t*(Vertex2_G[1]-Vertex2_G[0])+Vertex2_G[0];
	vec4 p=s*(gl_PositionIn[2]-gl_PositionIn[0]) + t*(gl_PositionIn[1]-gl_PositionIn[0])+gl_PositionIn[0];
#else
	Vertex1=Vertex1_G[i];
	Vertex2=Vertex2_G[i];	
	vec4 p=gl_PositionIn[i];
#endif	
    // displace using noise function
#ifdef NPZ
	g=0;
	SET_NOISE(NPZ);
	g*=2.0; // seems to align scaling better with per vertex ht
#endif
	vec3 v=p.xyz+pv;  // move from eye to model reference
	v=normalize(v)*g; // displace along vector from vertex to object center
	p.xyz+=amp*v;	
	gl_Position=gl_ModelViewProjectionMatrix * p;	
	EmitVertex();
}
#endif

void main(void) {
#ifdef COLOR
	Color = Color_G[0]; // id mapped into color at pivot vertex
#endif
#if TESSLVL >0	
	int numLayers = 1 << TESSLVL;
	float dt = 1.0 / float( numLayers );
	float t_top = 1.0;
	for( int it = 0; it < numLayers; it++ ){
		float t_bot = t_top - dt;
		float smax_top = 1.0 - t_top;
		float smax_bot = 1.0 - t_bot;
		int nums = it + 1;
		float ds_top = smax_top / float(nums - 1 );
		float ds_bot = smax_bot / float(nums);
		float s_top = 0.0;
		float s_bot = 0.0;
		int j=0;
		for( int is = 0; is < nums; is++ ,j++)
		{
			ProduceVertex(s_bot, t_bot);
			ProduceVertex(s_top, t_top);
			s_top += ds_top;
			s_bot += ds_bot;
		}
		ProduceVertex(s_bot, t_bot);
		EndPrimitive();
		t_top = t_bot;
		t_bot -= dt;
	}
#else
	ProduceVertex(0);
	ProduceVertex(1);
	ProduceVertex(2);
#endif
}

