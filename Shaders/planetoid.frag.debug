#define LMODE 0
#define NLIGHTS 1
#define HDR
#define NTEXS 4
#define NBUMPS 3
#define NVALS 0
#define TX0
#define C0 CS0
#define M0
#define B0
#define TX1
#define C1 CS1
#define T1
#define M1
#define B1
#define TX2
#define C2 CS2
#define M2
#define B2
#define TX3
#define X3 HT+0.2*BMPHT
 #define C3 CS3
#define T3
// ########## begin planetoid.frag #########################
//#extension GL_ARB_gpu_shader_fp64 : enable
#define DBLSTEST
//#version 130
//#define COLOR
#ifndef _COMMON_H
#define _COMMON_H
// ########## begin common.h #########################
#ifdef COLOR
varying vec4 Color;
#endif


#if NVALS >0
varying vec4 Vertex1;
varying vec4 Vertex2;
#endif
#if NTEXS >0
varying vec4 Tangent;
#endif

varying vec4 Constants;

float bump_ampl=1.0;
float bump_delta=1e-6;
float logf=0.0;
float nbamp=0.0;
vec4 gv=vec4(0.0);
float amplitude = 1.0;
vec3 bump;
float g=0.0;
float b=0.0;
bool newcell=false;

uniform float texmip;
uniform float bumpmip;
uniform float colormip;
uniform float freqmip;

#define HT Constants.x
#define DEPTH Constants.y
#define PHI Constants.z

#define PI		3.14159265359
#define RT2		1.414213562373

float RPD=2.0*PI/360.0;
float DPR=360.0/2.0/PI;

//const float MILES = 1.0e-5;
float bmpht=0.0;
#define BMPHT bmpht
#define SLOPE 0.0
float RED=1.0;
float GREEN=1.0;
float BLUE=1.0;
float ALPHA=1.0;

#define LAT abs(PHI)
#define EQU (1-LAT)
#define X Vertex1.x
#define THETA 0.0

// ########## end common.h #########################

#endif
#ifndef _UTILS_H
#define _UTILS_H
// ########## begin utils.h #########################
float lerp(float x, float xmin, float xmax, float ymin, float ymax){
	x=x<xmin?xmin:x;
	x=x>xmax?xmax:x;
	float a=(ymax-ymin)/(xmax-xmin);
	float b=ymin-a*xmin;
	float y=a*x+b;
	return y;
}
// ########## end  utils.h #########################
#endif

#ifdef TEST4
//#define N3D
#endif
uniform vec3 center;
uniform vec3 object;

uniform bool fbo_read;
uniform bool fbo_write;

uniform sampler2DRect FBOTex1;
uniform sampler2DRect FBOTex2;
uniform sampler2DRect FBOTex3;
uniform sampler2DRect FBOTex4;

#define SHADOWTEX FBOTex3

uniform float hdr_min;
uniform float hdr_max;


// ########## Lighting section #########################

#ifndef NLIGHTS
#define NLIGHTS 1
#endif

uniform float haze_grad;
uniform float haze_zfar;
uniform vec4 Haze;

uniform float sky_alpha;
uniform bool lighting;
uniform float twilite_min;
uniform float twilite_max;
uniform float twilite_dph; // dot product between point-center light-point at horizon
uniform float shadow_darkness;
varying vec4 EyeDirection;
varying vec4 Normal;

#ifndef LMODE
#define LMODE 0
#endif

uniform vec4 Diffuse;   // for some reason can't seem to set & use gl_FrontMaterial.diffuse ??
uniform vec4 Shadow;

//
//Lighting model
//
vec4 setLighting(vec3 BaseColor, vec3 n, vec3 b) {
	vec3 bmp  = -gl_NormalMatrix*b;
	vec3 eye = normalize(EyeDirection.xyz);
	vec3 radius = -normalize(EyeDirection.xyz+center);

	vec3 normal  = normalize(n+bmp);
	vec3 ambient = vec3(0.0, 0.0, 0.0);
	vec3 emission = vec3(0.0, 0.0, 0.0);
	vec3 diffuse = vec3(0.0, 0.0, 0.0);
	vec3 specular = vec3(0.0, 0.0, 0.0);
#ifdef HDR
	float bumpamp=dot(n,bmp);
    float exposure = 1.0-hdr_min*smoothstep(0.0,1.0,bumpamp/hdr_max);
	exposure = max(exposure,0.0);
	exposure*=exposure;	
	float RdotN   = dot(radius,normal); // for top lighting on nightside
	float top_shading  = 0.5*exposure*RdotN+0.5+0.5*exposure;  
#else
	float RdotN   = dot(radius,normal); // for top lighting on nightside
	float top_shading  = 0.5*RdotN+0.5;  // models hemispherical lighting (light from all angles)
#endif
	//float top_shading  = RdotN*RdotN*RdotN; // models a single light source from above (a bit more dramatic)
    vec3 topcolor=gl_FrontMaterial.ambient.rgb*(top_shading*gl_FrontMaterial.ambient.a);
	ambient = topcolor;
	emission = gl_FrontMaterial.emission.rgb;
	float illumination = gl_FrontMaterial.emission.a;
#ifdef SHADOWS
    float shadow=texture2DRect(SHADOWTEX, gl_FragCoord.xy).r; // data texture
    float shadow_diffuse=lerp(Shadow.a,0.0,1.0,1.0,shadow);
    float shadow_specular=shadow;//lerp(shadow,0.2,1.0,0.0,shadow);
#else
	float shadow_diffuse=1.0;
	float shadow_specular=1.0;
#endif

	for(int i=0;i<NLIGHTS;i++){
	    if(gl_LightSource[i].position.w==0.0)
	    	continue;
		vec3 light      = normalize(gl_LightSource[i].position.xyz+EyeDirection.xyz);
		float LdotN     = dot(light,normal);  // for day side diffuse lighting
		float LdotR     = dot(light,radius ); // for horizon band calculation
		float horizon   = lerp(LdotR,twilite_dph+twilite_min,twilite_dph+twilite_max,0.0,1.0); // twilite band
		float intensity = 1.0/gl_LightSource[i].constantAttenuation;
		float lpn       = LdotN*intensity*horizon;
		diffuse        += Diffuse.rgb*gl_LightSource[i].diffuse.rgb*max(lpn,top_shading*gl_FrontMaterial.ambient.a);
		//illumination   += 2.0*LdotN*intensity*horizon;
		illumination   += horizon;
		ambient+=topcolor*(3.0*horizon);
        if(LdotN>-0.5){
			float damp = lerp(LdotN,-0.5,0.0,0.0,1.0); // prevents false specular highlites on backfaces
#if LMODE == 0 // phong-blinn: uses half-vector (this is the openGL light model)
			vec3 H = normalize((light + eye)*0.5);
			float sdp   = max(0.0, dot(normal,H));
#elif LMODE == 1 // phong: uses light vector reflected about normal
			vec3 R = reflect(-light,normal);  // normalize(((2.0*normal )*LdotN)-light);
			float sdp   = max(0.0, dot(R, eye));
#else // combined mode (ogl seems better at low angles phong better at higher angles)
			vec3 R = reflect(-light,normal);  // normalize(((2.0*normal )*LdotN)-light);
			float phong   = max(0.0, dot(R, eye));
			vec3 H = normalize((light + eye)*0.5);
			float ogl   = max(0.0, dot(normal,H));
			float sdp=(0.5*phong+0.5*ogl);
#endif
			float pf        = damp*intensity*horizon*pow(sdp, gl_FrontMaterial.shininess);
			
			specular       += gl_LightSource[i].specular.rgb * pf*shadow_specular;
			//illumination   += pf*gl_LightSource[i].specular.a;
        }
	}
	diffuse.rgb=mix(diffuse.rgb,Shadow.rgb,1.0-shadow_diffuse);
	vec3 TotalEmission = emission.rgb * BaseColor;
	vec3 TotalAmbient = ambient.rgb * BaseColor;
	vec3 TotalDiffuse = diffuse.rgb * BaseColor*Diffuse.a*shadow_diffuse;
	vec3 TotalSpecular = specular.rgb;
	//illumination=clamp(illumination,0.0,1.0);
	return vec4(TotalAmbient +TotalEmission + TotalDiffuse + TotalSpecular,illumination);
}

//########## 3D noise section #########################

#define _BUMPS_

#if NVALS >0
// ########## begin noise_funcs.frag #########################
uniform sampler3D noise3DTexture;
uniform float fmax;

vec3 v1;
vec3 v2;
vec3 v3;
vec3 df;

#ifdef N3D
// classic Perlin noise using a 3D texture 
#define FSCALE 0.03125
#ifdef VNOISE
vec4 noise3D(vec3 p) {
	return (texture3D (noise3DTexture, FSCALE*p) - 0.5); 
}
#else
float noise3D(vec3 p) {
	return 2.0 * (texture3D (noise3DTexture, FSCALE*p ).r - 0.5); 
}
#endif
#else
#define FSCALE 1.0
// ########## begin noise.frag #########################

uniform sampler2D permTexture;

#ifndef CPX
#ifdef _BUMPS_
//#define VNOISE
#endif
#endif

/*
 * To create offsets of one texel and one half texel in the
 * texture lookup, we need to know the texture image size.
 */
#define ONE 0.00390625
#define ONEHALF 0.001953125

// The numbers above are 1/256 and 0.5/256, change accordingly
// if you change the code to use another texture size.

#define fade(t) t*t*t*(t*(t*6.0-15.0)+10.0)

// returns classic Perlin noise and derivatives using a 2D texture

vec4 noise3D(vec3 P){
    vec4 vout=vec4(0.0);
    vec3 Pi = ONE*(floor(P));
    vec3 Pf = fract(P);

    float b00 = texture2D(permTexture, Pi.xy).a;
    float b10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a;
    float b01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a;
    float b11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;
     
    // contributions from (x=0, y=0), z=0 and z=1
    vec3 grad000 = texture2D(permTexture, vec2(b00, Pi.z)).rgb * 2.0-1.0;
    vec3 grad001 = texture2D(permTexture, vec2(b00, Pi.z + ONE)).rgb * 2.0-1.0;
 
    // contributions from (x=0, y=1), z=0 and z=1
    vec3 grad010 = texture2D(permTexture, vec2(b01, Pi.z)).rgb * 2.0-1.0;
    vec3 grad011 = texture2D(permTexture, vec2(b01, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=0), z=0 and z=1
    vec3 grad100 = texture2D(permTexture, vec2(b10, Pi.z)).rgb *2.0- 1.0;
    vec3 grad101 = texture2D(permTexture, vec2(b10, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=1), z=0 and z=1
    vec3 grad110 = texture2D(permTexture, vec2(b11, Pi.z)).rgb * 2.0- 1.0;
    vec3 grad111 = texture2D(permTexture, vec2(b11, Pi.z + ONE)).rgb * 2.0-1.0;

    float n000 = dot(grad000, Pf);
    float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));    
    float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));
    float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));    
    float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));
    float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));    
    float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));
    float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));
    
    vec4 n1=vec4(n000, n001, n010, n011);
    vec4 n2=vec4(n100, n101, n110, n111);
 
    vec3 fpt=fade(Pf);
   
   // Blend contributions along x
   
    vec4 n_x = mix(n1, n2, fpt.x);
    // Blend contributions along y
    vec2 n_xy = mix(n_x.xy, n_x.zw, fpt.y);
    // Blend contributions along z
    float n_xyz = mix(n_xy.x, n_xy.y, fpt.z);
    vout.x=n_xyz;
    
#ifdef VNOISE

#define DELTA (1.15*ONEHALF)
    
    vec3 Pid = ONE*floor(P+DELTA);
    vec3 Pfd = fract(P+DELTA);

    if(Pid.x>Pi.x)
   	 	Pfd.x=1.0;
    if(Pid.y>Pi.y)
   	 	Pfd.y=1.0;
    if(Pid.z>Pi.z)
   	 	Pfd.z=1.0;
     
    // estimate x derivative
 
    vec3 Pd=P+vec3(DELTA);
    vec3 dpt=fade(Pfd);
    
    vec4 gx1=vec4(grad000.x, grad001.x, grad010.x,  grad011.x);
    vec4 gx2=vec4(grad100.x, grad101.x, grad110.x,  grad111.x);
   
    vec4 x1=n1+gx1*DELTA;
    vec4 x2=n2+gx2*DELTA;
              
    vec4 x_delta = mix(x1,x2,dpt.x);
    vec2 vx = mix(x_delta.xy, x_delta.zw, fpt.y); 
    vout.y=(mix(vx.x, vx.y, fpt.z)-n_xyz)/DELTA;

   // estimate y derivative

    vec4 gy1=vec4(grad000.y, grad001.y, grad010.y,  grad011.y);
    vec4 gy2=vec4(grad100.y, grad101.y, grad110.y,  grad111.y);
 
    vec4 y1=n1+gy1*DELTA;
    vec4 y2=n2+gy2*DELTA;
 
    vec4 y_delta = mix(y1,y2,fpt.x);
    vec2 vy = mix(y_delta.xy, y_delta.zw, dpt.y); 
    vout.z=(mix(vy.x, vy.y, fpt.z)-n_xyz)/DELTA;

   // estimate z derivative

    vec4 gz1=vec4(grad000.z, grad001.z, grad010.z,  grad011.z);
    vec4 gz2=vec4(grad100.z, grad101.z, grad110.z,  grad111.z);
 
    vec4 z1=n1+gz1*DELTA;
    vec4 z2=n2+gz2*DELTA;
    vec4 z_delta = mix(z1,z2,fpt.x);
    vec2 vz = mix(z_delta.xy, z_delta.zw, fpt.y); 
    vout.w=(mix(vz.x, vz.y, dpt.z)-n_xyz)/DELTA;
#endif
    return vout;
}

// ########## end noise.frag #########################
#endif

#define GCURVE1(t) (0.5*t*t*(3.0-t))
#define DCURVE1(t) 1.5*t*(2.0-t)
#define SCURVE1(t) (t*t*(3.0 - 2.0*t) )

struct noise_info {
	float fact;
	float delta;
	float orders;
	float freq;
	float H;
	float L;
	float bias;
	float ampl;
	float offset;
	float smooth;
	float clamp;
	float logf;
	float ma;
	float mb;
	bool sqr;
	bool invert;
	bool absval;
	bool uns;
};

uniform noise_info nvars[NVALS];

#define VMAX 0.5

float noise_fade=0.0;

float reset(){
	v1=Vertex1.xyz;
	return 0.0;
}
float corialis(float a){
    vec3 vt=(v1-0.5)*2.0;
    
	float x=vt.x;
	float y=vt.z;
	float z=vt.y;
	float r=(x*x+y*y);
	float angle=a*2.0*PI*r;
	float s=sin(angle);
	float c=cos(angle);
	vt=vec3(x*c-y*s,x*s+y*c,z);
	v1=vt*0.5+0.5;
	return 0.0;
}

#define twist(a,b) corialis(a)+b+reset()

// multi-order procedural 3d noise

vec4 Noise(int index) {
	noise_info info=nvars[index];

    float orders=min(info.orders, Vertex1.w-info.logf-freqmip);
    noise_fade = lerp(orders,-1.0,1.0,0.0,1.0);

    if(noise_fade<=0.0)
    	return vec4(0.0);

	float gval=0.0,x,y;
	float fact=info.fact;
	vec4 result=vec4(0.0);
	vec4 last_val=vec4(0.0);
	vec4 val,nvec;
	
	float f=info.freq;
	float gain=1.0-info.bias;
	float weight=1.0;
    float octaves=max(orders,1.0);

	int n=int(octaves);
	float rem=octaves-float(n);
	n=rem>0.0?n+1:n;
	float rmin=info.smooth*VMAX;
	if(!info.absval)
		rmin *=2.0;
	float clip=info.clamp*VMAX;
	for(int i=0;i<n;i++) {
		float df=f/fmax;
		/*
		if(df>1)
			nvec=noise3D(v2*f);
		else
		nvec=noise3D(v1*f);
		*/
	    //if(df>=1)
	    //    nvec=noise3D(v2*f);
	   // else if(df<0.25)
	   //     nvec=noise3D(v1*f);
	   // else{
	        float m=smoothstep(0.1,1.75,df);
	        vec4 P1=noise3D(v1*f);
	        vec4 P2=noise3D(v2*f);
	        nvec=mix(P1,P2,m);
	   // }
	    
        //nvec=noise3D(f);
		nvec.yzw*=f;
		if(nvec.x>clip+0.1*nvec.x){
			nvec.x=clip+0.1*nvec.x;
			nvec.yzw*=0.1;
		}		
		f*=info.L;
		if(info.absval) {
			if(nvec.x<0.0)
			    nvec=-nvec;
			if(rmin>0.0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
				x=GCURVE1(x);
			    nvec.x=rmin*x;
			}
			nvec.x=VMAX-nvec.x;
			nvec.yzw=-nvec.yzw;
			nvec*=2;
		}
		else{
			nvec.x=VMAX+nvec.x;
		    if(rmin>0.0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
			    x=GCURVE1(x);
			    nvec.x=rmin*x;
		    }
		}
		val=nvec*weight*fact;
		last_val=result;
		result += val;
		fact*=info.delta;
		if(weight<=0.0)
		    break;
		weight*=nvec.x*gain+info.bias;
		weight=clamp(weight,0.0,1.0);
	}
	if(rem>0.0)
		result=last_val+rem*val;
	if(info.sqr){
		result.yzw*=2.0*abs(result.x);  // derivative of x^2 ?
		if(info.uns)
			result.x*=result.x;
		else
		    result.x*=abs(result.x);
	}
	if(info.invert)
		result=-result;
	result*=noise_fade*info.ampl;
	result.x+=noise_fade*info.offset;
	return result;	
}
#ifdef _BUMPS_
#ifdef VNOISE
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x; \
 	if(lighting) { \
 	    df=gv.yzw; \
 	    df*=0.1*noise_fade*bump_ampl; \
		bump = bump + amplitude*df; \
    }
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g= gv.x; \
 	if(lighting) { \
 	    float delta=bump_delta; \
		nbamp = 0.1*noise_fade*bump_ampl/delta; \
		b = g; \
		v1 = vec3(Vertex1.x+delta,Vertex1.y,Vertex1.z);  \
		v2 = vec3(Vertex2.x+delta,Vertex2.y,Vertex2.z);  \
 		gv = func; \
		df.x =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y+delta,Vertex1.z); \
		v2 = vec3(Vertex2.x,Vertex2.y+delta,Vertex2.z); \
 		gv = func; \
		df.y =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y,Vertex1.z+delta); \
		v2 = vec3(Vertex2.x,Vertex2.y,Vertex2.z+delta); \
 		gv = func; \
		df.z =gv.x; \
		df = (df-vec3(b,b,b))*(nbamp); \
		bump = bump + amplitude*df; \
    }
#endif
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x;
#endif

#define NOISE_COLOR(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
    vec4 ncolor=func; \
 	color =ncolor+color;

#define NOISE_VARS \
    df=vec3(0); \
    nbamp=0.0; \
    g=0.0; \
    b=0.0; \
    noise_fade=0.0; \
	gv=vec4(0.0);

// ########## end noise_funcs.frag #########################
#endif

// ########## Texture section #########################

#if NTEXS >0
// ########## begin tex_funcs.frag #########################
// TODO: for 1d textures, pass in S expression for evaluation in shader
// ########## begin attributes.def #########################

#define AT0 attributes[0].x
#define AT1 attributes[0].y
#define AT2 attributes[0].z
#define AT3 attributes[0].w
#define AT4 attributes[1].x
#define AT5 attributes[1].y
#define AT6 attributes[1].z
#define AT7 attributes[1].w

varying vec4 attributes[2];

// ########## end attributes.def #########################
#define CS0 gl_TexCoord[0].xy
#define CS1 gl_TexCoord[0].zw
#define CS2 gl_TexCoord[1].xy
#define CS3 gl_TexCoord[1].zw
#define CS4 gl_TexCoord[2].xy
#define CS5 gl_TexCoord[2].zw
#define CS6 gl_TexCoord[3].xy
#define CS7 gl_TexCoord[3].zw
#define CS8 gl_TexCoord[4].xy
#define CS9 gl_TexCoord[4].zw
#define CS10 gl_TexCoord[5].xy
#define CS11 gl_TexCoord[5].zw
#define CS12 gl_TexCoord[6].xy
#define CS13 gl_TexCoord[6].zw
#define CS14 gl_TexCoord[7].xy
#define CS15 gl_TexCoord[7].zw

struct tex2d_info {
	float bumpamp;
	float texamp;
	float bump_delta;
	float bump_damp;
	float orders_delta;  // scale multiplier for multi-orders
	float orders_atten;  // attenuation factor
	float orders_bump;
	float scale;         // texture scale
	float bias;   		 // texture bias 
	float logf;    		 // scale factor
	float dlogf;         // delta scale factor
	float orders; 		 // number of orders to add
};
uniform tex2d_info tex2d[NTEXS];
uniform sampler2D samplers2d[NTEXS];
#define BIAS vec2(tex2d[tid].bias,0.0)
#define NOATTR 1.0
#define SET_ATTRIB(ATTR) \
	attrib = ATTR;

#ifdef _BUMPS_
#define INIT_TEX(i,COORDS) \
	tid = i; \
	coords = COORDS; \
	amplitude = clamp(attrib+tex2d[tid].bias,0.0,1.0); \
	logf=tex2d[i].logf; \
	last_color=color; \
	last_bump=bump; \
	last_bmpht=bmpht; \
	alpha = tex2d[i].texamp; \
	alpha_fade = lerp(Tangent.w-logf-colormip,-6.0,1.0,0.0,1.0); \
	dlogf=tex2d[i].dlogf; \
	bump_ampl = tex2d[i].bumpamp; \
    bump_delta=tex2d[i].bump_delta;

#define SET_TEX(X) \
	coords.x += tex2d[tid].scale*(X);

#define APPLY_TEX \
    offset = vec2(g*tex2d[tid].texamp*tex2d[tid].scale); \
	tval=texture2D(samplers2d[tid], coords+offset,texmip); \
	alpha = tex2d[tid].texamp; \
	cmix = alpha_fade*amplitude*lerp(alpha,1.0,2.0,tval.a*alpha,1.0);

#define SET_BUMP \
	bump*=1.0-tval.a*tex2d[tid].bump_damp*bump_max; \
	s=coords.x; \
	t=coords.y; \
	orders_bump=tex2d[tid].orders_bump; \
	ds=vec2(s+orders_bump,t)+offset; \
	dt=vec2(s,t+orders_bump)+offset; \
	tc2.x=texture2D(samplers2d[tid],ds,texmip).a-tval.a; \
	tc2.y=texture2D(samplers2d[tid],dt,texmip).a-tval.a; \
	tc=vec3(tc2, 0.0); \
    last_bump=bump; \
    last_bmpht=bmpht; \
    bump_fade = lerp(Tangent.w-logf-freqmip,-4.0,1.0,0.0,1.0); \
    bump_fade *= lerp(Tangent.w-logf-freqmip,3.0,10.0,1.0,0.0); \
    bump_max=max(bump_max,bump_fade); \
	bump += bump_max*amplitude*bump_ampl*trans_mat*tc; \
	bmpht += b+amplitude*(tval.a-0.5)*bump_ampl*orders_delta;

#define NEXT_ORDER \
	orders_delta /= tex2d[tid].orders_delta; \
    coords *= tex2d[tid].orders_delta; \
    tval=texture2D(samplers2d[tid], coords+offset,texmip); \
    alpha*=tex2d[tid].texamp; \
	cmix = alpha_fade*amplitude*lerp(alpha,1.0,2.0,tval.a*alpha,1.0); \
	amplitude *=tex2d[tid].orders_atten; \
	logf+=dlogf;

#else // no bumps
#define INIT_TEX(i,COORDS) \
	tid = i; \
	last_color=color; \
	last_bump=bump; \
	last_bmpht=bmpht; \
	coords = COORDS; \
	amplitude = clamp(attrib+tex2d[tid].bias,0.0,1.0); \
	alpha = tex2d[i].texamp; \
	logf=tex2d[i].logf; \
	alpha_fade = lerp(Tangent.w-logf-colormip,-6.0,1.0,0.0,1.0);

#define SET_TEX(X) \
	coords.x += tex2d[tid].scale*(X);

#define APPLY_TEX \
    offset = vec2(g*tex2d[tid].texamp*tex2d[tid].scale); \
	tval=texture2D(samplers2d[tid], coords+offset,texmip); \
	cmix = alpha_fade*amplitude*lerp(alpha,1.0,2.0,tval.a*alpha,1.0);

#define NEXT_ORDER \
	orders_delta /= tex2d[tid].orders_delta; \
    coords *= tex2d[tid].orders_delta; \
    tval=texture2D(samplers2d[tid], coords+offset,texmip); \
    alpha*=tex2d[tid].texamp; \
	cmix = alpha_fade*amplitude*lerp(alpha,1.0,2.0,tval.a*alpha,1.0); \

#endif // TEX_BUMPS

#define BGN_ORDERS \
	tex_orders=min(tex2d[tid].orders, Tangent.w-logf-freqmip+0.5); \
	tex_n=int(tex_orders); \
	tex_rem=tex_orders-float(tex_n); \
	tex_n=tex_rem>0.0?tex_n+1:tex_n; \
	orders_delta=1.0; \
	for(int i=0;i<tex_n;i++) {

#define SET_COLOR \
	last_color=color; \
	color=mix(color,tval, cmix);

#define END_ORDERS \
	} \
	if(tex_rem>0.0){ \
		color=mix(last_color,color,tex_rem); \
		bump=mix(last_bump,bump,tex_rem); \
		bmpht=mix(last_bmpht,bmpht,tex_rem); \
	} \


#define TEX_VARS \
	int tid=0; \
	float orders_delta = 1.0;  \
	float alpha = 1.0;  \
	float cmix = 1.0;  \
    float attrib=0.0; \
    vec2 coords; \
    vec2 offset=vec2(0.0); \
 	vec4 tval; \
	vec4 tcolor; \
    float alpha_fade=0.0; \
    float delta; \
    float bump_fade=1.0; \
    float dlogf; \
    float orders_bump=1e-3; \
	float tex_orders=0.0; \
	float tex_rem=0.0; \
	float bump_max=0.0; \
	int tex_n=0; \
	vec4 last_color=vec4(0.0); \
	float last_bmpht; \
    vec3 last_bump=vec3(0.0); \
	amplitude = 1.0; \
	g=0.0;

#define BUMP_VARS \
 	vec2 tc2; \
	float s,t; \
	vec3 tc; \
	vec2 ds,dt; \
    mat3 model=mat3(gl_ModelViewMatrix); \
    vec3 tangent=normalize(vec3(Tangent.x,Tangent.y,0.0)); \
    vec3 binormal=normalize(cross(tangent, normal)); \
    mat3 trans_mat=model*transpose(mat3(tangent, binormal, normal));

// ########## end tex_funcs.frag #########################
#endif

// ########## main section #########################
void main(void) {
#ifdef COLOR
	vec4 color=Color;
#else
	vec4 color=vec4(1.0);
	bump=vec3(0.0);
#endif
    vec3 normal=normalize(Normal.xyz);
#ifdef NCC
	NOISE_COLOR(NCC);
#endif

#if NTEXS >0
#if NTEXS >0
    TEX_VARS
#endif
#if NBUMPS >0
    BUMP_VARS
#endif
#if NVALS >0
    NOISE_VARS
#endif

#ifdef TX0
#ifdef A0
    SET_ATTRIB(A0)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(0,C0)
#ifdef N0
    SET_NOISE(N0)
#endif
#ifdef X0
    SET_TEX(X0)
#endif
    APPLY_TEX
#ifdef M0
    BGN_ORDERS
#endif
#ifdef T0
    SET_COLOR
#endif
#ifdef B0
    SET_BUMP
#endif
#ifdef M0
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX1
#ifdef A1
    SET_ATTRIB(A1)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(1,C1)
#ifdef N1
    SET_NOISE(N1)
#endif
#ifdef X1
    SET_TEX(X1)
#endif
    APPLY_TEX
#ifdef M1
    BGN_ORDERS
#endif
#ifdef T1
    SET_COLOR
#endif
#ifdef B1
    SET_BUMP
#endif
#ifdef M1
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX2
#ifdef A2
    SET_ATTRIB(A2)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(2,C2)
#ifdef N2
    SET_NOISE(N2)
#endif
#ifdef X2
    SET_TEX(X2)
#endif
    APPLY_TEX
#ifdef M2
    BGN_ORDERS
#endif
#ifdef T2
    SET_COLOR
#endif
#ifdef B2
    SET_BUMP
#endif
#ifdef M2
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX3
#ifdef A3
    SET_ATTRIB(A3)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(3,C3)
#ifdef N3
    SET_NOISE(N3)
#endif
#ifdef X3
    SET_TEX(X3)
#endif
    APPLY_TEX
#ifdef M3
    BGN_ORDERS
#endif
#ifdef T3
    SET_COLOR
#endif
#ifdef B3
    SET_BUMP
#endif
#ifdef M3
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX4
#ifdef A4
    SET_ATTRIB(A4)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(4,C4)
#ifdef N4
    SET_NOISE(N4)
#endif
#ifdef X4
    SET_TEX(X4)
#endif
    APPLY_TEX
#ifdef M4
    BGN_ORDERS
#endif
#ifdef T4
    SET_COLOR
#endif
#ifdef B4
    SET_BUMP
#endif
#ifdef M4
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX5
#ifdef A5
    SET_ATTRIB(A5)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(5,C5)
#ifdef N5
    SET_NOISE(N5)
#endif
#ifdef X5
    SET_TEX(X5)
#endif
    APPLY_TEX
#ifdef M5
    BGN_ORDERS
#endif
#ifdef T5
    SET_COLOR
#endif
#ifdef B5
    SET_BUMP
#endif
#ifdef M5
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX6
#ifdef A6
    SET_ATTRIB(A6)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(6,C6)
#ifdef N6
    SET_NOISE(N6)
#endif
#ifdef X6
    SET_TEX(X6)
#endif
    APPLY_TEX
#ifdef M6
    BGN_ORDERS
#endif
#ifdef T6
    SET_COLOR
#endif
#ifdef B6
    SET_BUMP
#endif
#ifdef M6
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX7
#ifdef A7
    SET_ATTRIB(A7)
#else
    SET_ATTRIB(1.0)
#endif
INIT_TEX(7,C7)
#ifdef N7
    SET_NOISE(N7)
#endif
#ifdef X7
    SET_TEX(X7)
#endif
    APPLY_TEX
#ifdef M7
    BGN_ORDERS
#endif
#ifdef T7
    SET_COLOR
#endif
#ifdef B7
    SET_BUMP
#endif
#ifdef M7
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX8
INIT_TEX(8,C8)
#ifdef N8
    SET_NOISE(N8)
#endif
#ifdef X8
    SET_TEX(X8)
#endif
    APPLY_TEX
#ifdef M8
    BGN_ORDERS
#endif
#ifdef T8
    SET_COLOR
#endif
#ifdef B8
    SET_BUMP
#endif
#ifdef M8
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX9
INIT_TEX(9,C9)
#ifdef N9
    SET_NOISE(N9)
#endif
#ifdef X9
    SET_TEX(X9)
#endif
    APPLY_TEX
#ifdef M9
    BGN_ORDERS
#endif
#ifdef T9
    SET_COLOR
#endif
#ifdef B9
    SET_BUMP
#endif
#ifdef M9
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX10
INIT_TEX(10,C10)
#ifdef N10
    SET_NOISE(N10)
#endif
#ifdef X10
    SET_TEX(X10)
#endif
    APPLY_TEX
#ifdef M10
    BGN_ORDERS
#endif
#ifdef T10
    SET_COLOR
#endif
#ifdef B10
    SET_BUMP
#endif
#ifdef M10
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX11
INIT_TEX(11,C11)
#ifdef N11
    SET_NOISE(N11)
#endif
#ifdef X11
    SET_TEX(X11)
#endif
    APPLY_TEX
#ifdef M11
    BGN_ORDERS
#endif
#ifdef T11
    SET_COLOR
#endif
#ifdef B11
    SET_BUMP
#endif
#ifdef M11
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX12
INIT_TEX(12,C12)
#ifdef N12
    SET_NOISE(N12)
#endif
#ifdef X12
    SET_TEX(X12)
#endif
    APPLY_TEX
#ifdef M12
    BGN_ORDERS
#endif
#ifdef T12
    SET_COLOR
#endif
#ifdef B12
    SET_BUMP
#endif
#ifdef M12
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX13
INIT_TEX(13,C13)
#ifdef N13
    SET_NOISE(N13)
#endif
#ifdef X13
    SET_TEX(X13)
#endif
    APPLY_TEX
#ifdef M13
    BGN_ORDERS
#endif
#ifdef T13
    SET_COLOR
#endif
#ifdef B13
    SET_BUMP
#endif
#ifdef M13
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX14
INIT_TEX(14,C14)
#ifdef N14
    SET_NOISE(N14)
#endif
#ifdef X14
    SET_TEX(X14)
#endif
    APPLY_TEX
#ifdef M14
    BGN_ORDERS
#endif
#ifdef T14
    SET_COLOR
#endif
#ifdef B14
    SET_BUMP
#endif
#ifdef M14
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#ifdef TX15
INIT_TEX(15,C15)
#ifdef N15
    SET_NOISE(N15)
#endif
#ifdef X15
    SET_TEX(X15)
#endif
    APPLY_TEX
#ifdef M15
    BGN_ORDERS
#endif
#ifdef T15
    SET_COLOR
#endif
#ifdef B15
    SET_BUMP
#endif
#ifdef M15
    NEXT_ORDER
    END_ORDERS
#endif
#endif

#endif
    float illumination = 0.0;
	color.a=1.0;
    if(lighting){
		vec4 c=setLighting(color.rgb,normal,bump);
    	color.rgb=c.rgb;
    	illumination=c.a;//sqrt(c.a);
    }
#ifdef SHADOWS
	else{
    	float shadow=1.0-texture2DRect(SHADOWTEX, gl_FragCoord.xy).r;
    	color.rgb=mix(color.rgb,Shadow.rgb,shadow*Shadow.a);
    }
#endif    
	//if (fbo_write){
		vec4 data2=vec4(1.0);
		data2.r=illumination;
		gl_FragData[1]=vec4(illumination,0.0,0.0,1.0);
		gl_FragData[2]=vec4(0.0,0.0,0.0,1.0);
	//}
#ifdef HAZE
	float d=min(DEPTH/haze_zfar,1.0);
	float h = Haze.a*pow(d,1.5*haze_grad);
	color.rgb=mix(color.rgb,Haze.rgb*illumination,h);
#endif
	gl_FragData[0] = color;

}
// ########## end planetoid.frag #########################

