#define LMODE 0
#define NLIGHTS 1
#define BACK
#define HAZE
#define COLOR
#define NTEXS 0
#define NBUMPS 0
#define NVALS 0

// ########## begin clouds.frag #########################
#ifndef _COMMON_H
#define _COMMON_H
// ########## begin common.h #########################
#ifdef COLOR
varying vec4 Color;
#endif


#if NVALS >0
varying vec4 Vertex1;
varying vec4 Vertex2;
#endif
#if NTEXS >0
varying vec4 Tangent;
#endif

varying vec4 Constants;

float bump_ampl=1.0;
float bump_delta=1e-6;
float logf=0.0;
float nbamp=0.0;
vec4 gv=vec4(0.0);
float amplitude = 1.0;
vec3 bump;
float g=0.0;
float b=0.0;
bool newcell=false;

uniform float texmip;
uniform float bumpmip;
uniform float colormip;
uniform float freqmip;

#define HT Constants.x
#define DEPTH Constants.y
#define PHI Constants.z

#define PI		3.14159265359
#define RT2		1.414213562373

float RPD=2.0*PI/360.0;
float DPR=360.0/2.0/PI;

//const float MILES = 1.0e-5;
float bmpht=0.0;
#define BMPHT bmpht
#define SLOPE 0.0
float RED=1.0;
float GREEN=1.0;
float BLUE=1.0;
float ALPHA=1.0;

#define LAT abs(PHI)
#define EQU (1-LAT)
#define X Vertex1.x
#define THETA 0.0

// ########## end common.h #########################

#endif
#ifndef _UTILS_H
#define _UTILS_H
// ########## begin utils.h #########################
float lerp(float x, float xmin, float xmax, float ymin, float ymax){
	x=x<xmin?xmin:x;
	x=x>xmax?xmax:x;
	float a=(ymax-ymin)/(xmax-xmin);
	float b=ymin-a*xmin;
	float y=a*x+b;
	return y;
}
// ########## end  utils.h #########################
#endif

#ifndef LMODE
#define LMODE 0
#endif

// Phong shading variables

uniform bool lighting;
uniform float twilite_min;
uniform float twilite_max;
uniform float twilite_dph; // dot product between point-center light-point at horizon
uniform float sky_ht;
uniform float eye_ht;

varying vec4 EyeDirection;
varying vec4 Normal;

uniform vec3 center;

uniform vec4 Haze;
uniform vec4 Halo;
uniform float haze_grad;
uniform float haze_zfar;
uniform float day_grad;

uniform float dpmax;
uniform float dpmin;

//
// Phong Lighting model
//

uniform vec4 Diffuse;   // for some reason can't seem to set & use gl_FrontMaterial.diffuse ??

vec3 setLighting(vec3 BaseColor, vec3 n) {
	vec3 normal  = normalize(n);
	vec3 eye = normalize(EyeDirection.xyz);
	vec3 radius = -normalize(EyeDirection.xyz+center);
	vec3 ambient = vec3(1, 1, 1);
	vec3 diffuse = vec3(0, 0, 0);
	vec3 specular = vec3(0, 0, 0);
	vec3 emission = vec3(0, 0, 0);
	float RdotN   = abs(dot(radius,normal));   // constant top & bottom lighting (starglow, groundglow)
	float top_shading  = 0.5*RdotN+0.5;   // models hemispherical lighting (light from all angles)
	//float top_shading  = RdotN;   // models single light source from above or below
	vec3 ec = normalize(center);          // viewdir-center
	float dp=dot(ec, radius); // angle between radius and viewdir direction
	float transmission=Constants.z;

    //vec3 topcolor=gl_FrontMaterial.ambient.rgb*(top_shading*gl_FrontMaterial.ambient.a);
    vec3 topcolor=gl_FrontMaterial.ambient.rgb*top_shading;
	ambient        = topcolor;
	emission = gl_FrontMaterial.emission.rgb;
	float illumination=length(emission);

	//eye=normalize(-eye);
	vec3 haze=Haze.rgb;
	float halo=Halo.a;

	for(int i=0;i<NLIGHTS;i++){
		vec3 light      = normalize(gl_LightSource[i].position.xyz+EyeDirection.xyz);
		float LdotN     = dot(light,normal);// for day side diffuse lighting
		float LdotR     = dot(light,radius); // for horizon band calculation
		float horizon   = lerp(LdotR,twilite_dph+twilite_min,twilite_dph+twilite_max,0.0,1.0); // twilite band
		float amplitude = 1.0/gl_LightSource[i].constantAttenuation;
		float lpn       = LdotN*amplitude*horizon;
		diffuse        += Diffuse.rgb*gl_LightSource[i].diffuse.rgb*max(lpn,top_shading*gl_FrontMaterial.ambient.a);
		illumination   += horizon;
		if(LdotN>0.0){ // top side
			vec3 R = reflect(-light,normal);  // normalize(((2.0*normal )*LdotN)-light);
			float sdp   = max(0.0, dot(R, eye));
			float pf    = amplitude*horizon*pow(sdp, gl_FrontMaterial.shininess);
			specular   += gl_LightSource[i].specular.rgb * pf;
		}
#ifdef BACK
		if(day_grad>0.0 && LdotR>twilite_min){ // mix in star color
			float dpLE=dot(light, -eye); // angle between vertex and light to viewdir direction
			dpLE=clamp(dpLE, 0.0, 1.0); // only positive angles
			float pf =pow(dpLE,100.0*day_grad);
			transmission*=pow(dpLE,10.0*day_grad);
		}
#endif
	}
	vec3 TotalDiffuse = diffuse * BaseColor * Diffuse.a;
	vec3 TotalSpecular = specular.rgb;
	vec3 TotalEmission = emission.rgb;
	vec3 TotalAmbient = ambient.rgb * BaseColor;
	vec3 TotalColor=TotalAmbient + TotalDiffuse+ TotalEmission +TotalSpecular;
	illumination=clamp(illumination,0.0,1.0);
#ifdef BACK
#ifdef HAZE
	// horizon+fog height to zenith gradient
	//dp=max(dp,0.0);
	float s=lerp(dp, dpmax-2.0*dpmin, dpmax-dpmin, 0.0, 1.0);
	s=clamp(s,1e-5,1.0);  // for some reason pow(x,..) causes black pixels if x<=0
	float dv=pow(s,4.0*haze_grad);
	// eye to max distance gradient
	float d=min(DEPTH/haze_zfar,1.0);
	float dh=1.0;//pow(d,4.0*haze_grad);
	float h=Haze.a*dv*dh;
	transmission*=lerp(haze_grad,0.0,0.2,0.0,1.0);
	TotalColor.rgb=mix(TotalColor.rgb,haze.rgb*illumination,h);
#endif
	TotalColor.rgb=mix(TotalColor.rgb,Halo.rgb*illumination,transmission);
#endif

	return TotalColor;
}
// ########## end clouds.frag #########################

#if NVALS >0
// ########## begin noise_funcs.frag #########################
uniform sampler3D noise3DTexture;
uniform float fmax;

vec3 v1;
vec3 v2;
vec3 v3;
vec3 df;

#ifdef N3D
// classic Perlin noise using a 3D texture 
#define FSCALE 0.03125
#ifdef VNOISE
vec4 noise3D(vec3 p) {
	return (texture3D (noise3DTexture, FSCALE*p) - 0.5); 
}
#else
float noise3D(vec3 p) {
	return 2.0 * (texture3D (noise3DTexture, FSCALE*p ).r - 0.5); 
}
#endif
#else
#define FSCALE 1.0
// ########## begin noise.frag #########################

uniform sampler2D permTexture;

#ifndef CPX
#ifdef _BUMPS_
//#define VNOISE
#endif
#endif

/*
 * To create offsets of one texel and one half texel in the
 * texture lookup, we need to know the texture image size.
 */
#define ONE 0.00390625
#define ONEHALF 0.001953125

// The numbers above are 1/256 and 0.5/256, change accordingly
// if you change the code to use another texture size.

#define fade(t) t*t*t*(t*(t*6.0-15.0)+10.0)

// returns classic Perlin noise and derivatives using a 2D texture

vec4 noise3D(vec3 P){
    vec4 vout=vec4(0.0);
    vec3 Pi = ONE*(floor(P));
    vec3 Pf = fract(P);

    float b00 = texture2D(permTexture, Pi.xy).a;
    float b10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a;
    float b01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a;
    float b11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;
     
    // contributions from (x=0, y=0), z=0 and z=1
    vec3 grad000 = texture2D(permTexture, vec2(b00, Pi.z)).rgb * 2.0-1.0;
    vec3 grad001 = texture2D(permTexture, vec2(b00, Pi.z + ONE)).rgb * 2.0-1.0;
 
    // contributions from (x=0, y=1), z=0 and z=1
    vec3 grad010 = texture2D(permTexture, vec2(b01, Pi.z)).rgb * 2.0-1.0;
    vec3 grad011 = texture2D(permTexture, vec2(b01, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=0), z=0 and z=1
    vec3 grad100 = texture2D(permTexture, vec2(b10, Pi.z)).rgb *2.0- 1.0;
    vec3 grad101 = texture2D(permTexture, vec2(b10, Pi.z + ONE)).rgb * 2.0-1.0;

    // contributions from (x=1, y=1), z=0 and z=1
    vec3 grad110 = texture2D(permTexture, vec2(b11, Pi.z)).rgb * 2.0- 1.0;
    vec3 grad111 = texture2D(permTexture, vec2(b11, Pi.z + ONE)).rgb * 2.0-1.0;

    float n000 = dot(grad000, Pf);
    float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));    
    float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));
    float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));    
    float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));
    float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));    
    float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));
    float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));
    
    vec4 n1=vec4(n000, n001, n010, n011);
    vec4 n2=vec4(n100, n101, n110, n111);
 
    vec3 fpt=fade(Pf);
   
   // Blend contributions along x
   
    vec4 n_x = mix(n1, n2, fpt.x);
    // Blend contributions along y
    vec2 n_xy = mix(n_x.xy, n_x.zw, fpt.y);
    // Blend contributions along z
    float n_xyz = mix(n_xy.x, n_xy.y, fpt.z);
    vout.x=n_xyz;
    
#ifdef VNOISE

#define DELTA (1.15*ONEHALF)
    
    vec3 Pid = ONE*floor(P+DELTA);
    vec3 Pfd = fract(P+DELTA);

    if(Pid.x>Pi.x)
   	 	Pfd.x=1.0;
    if(Pid.y>Pi.y)
   	 	Pfd.y=1.0;
    if(Pid.z>Pi.z)
   	 	Pfd.z=1.0;
     
    // estimate x derivative
 
    vec3 Pd=P+vec3(DELTA);
    vec3 dpt=fade(Pfd);
    
    vec4 gx1=vec4(grad000.x, grad001.x, grad010.x,  grad011.x);
    vec4 gx2=vec4(grad100.x, grad101.x, grad110.x,  grad111.x);
   
    vec4 x1=n1+gx1*DELTA;
    vec4 x2=n2+gx2*DELTA;
              
    vec4 x_delta = mix(x1,x2,dpt.x);
    vec2 vx = mix(x_delta.xy, x_delta.zw, fpt.y); 
    vout.y=(mix(vx.x, vx.y, fpt.z)-n_xyz)/DELTA;

   // estimate y derivative

    vec4 gy1=vec4(grad000.y, grad001.y, grad010.y,  grad011.y);
    vec4 gy2=vec4(grad100.y, grad101.y, grad110.y,  grad111.y);
 
    vec4 y1=n1+gy1*DELTA;
    vec4 y2=n2+gy2*DELTA;
 
    vec4 y_delta = mix(y1,y2,fpt.x);
    vec2 vy = mix(y_delta.xy, y_delta.zw, dpt.y); 
    vout.z=(mix(vy.x, vy.y, fpt.z)-n_xyz)/DELTA;

   // estimate z derivative

    vec4 gz1=vec4(grad000.z, grad001.z, grad010.z,  grad011.z);
    vec4 gz2=vec4(grad100.z, grad101.z, grad110.z,  grad111.z);
 
    vec4 z1=n1+gz1*DELTA;
    vec4 z2=n2+gz2*DELTA;
    vec4 z_delta = mix(z1,z2,fpt.x);
    vec2 vz = mix(z_delta.xy, z_delta.zw, fpt.y); 
    vout.w=(mix(vz.x, vz.y, dpt.z)-n_xyz)/DELTA;
#endif
    return vout;
}

// ########## end noise.frag #########################
#endif

#define GCURVE1(t) (0.5*t*t*(3.0-t))
#define DCURVE1(t) 1.5*t*(2.0-t)
#define SCURVE1(t) (t*t*(3.0 - 2.0*t) )

struct noise_info {
	float fact;
	float delta;
	float orders;
	float freq;
	float H;
	float L;
	float bias;
	float ampl;
	float offset;
	float smooth;
	float clamp;
	float logf;
	float ma;
	float mb;
	bool sqr;
	bool invert;
	bool absval;
	bool uns;
};

uniform noise_info nvars[NVALS];

#define VMAX 0.5

float noise_fade=0.0;

float reset(){
	v1=Vertex1.xyz;
	return 0.0;
}
float corialis(float a){
    vec3 vt=(v1-0.5)*2.0;
    
	float x=vt.x;
	float y=vt.z;
	float z=vt.y;
	float r=(x*x+y*y);
	float angle=a*2.0*PI*r;
	float s=sin(angle);
	float c=cos(angle);
	vt=vec3(x*c-y*s,x*s+y*c,z);
	v1=vt*0.5+0.5;
	return 0.0;
}

#define twist(a,b) corialis(a)+b+reset()

// multi-order procedural 3d noise

vec4 Noise(int index) {
	noise_info info=nvars[index];

    float orders=min(info.orders, Vertex1.w-info.logf-freqmip);
    noise_fade = lerp(orders,-1.0,1.0,0.0,1.0);

    if(noise_fade<=0.0)
    	return vec4(0.0);

	float gval=0.0,x,y;
	float fact=info.fact;
	vec4 result=vec4(0.0);
	vec4 last_val=vec4(0.0);
	vec4 val,nvec;
	
	float f=info.freq;
	float gain=1.0-info.bias;
	float weight=1.0;
    float octaves=max(orders,1.0);

	int n=int(octaves);
	float rem=octaves-float(n);
	n=rem>0.0?n+1:n;
	float rmin=info.smooth*VMAX;
	if(!info.absval)
		rmin *=2.0;
	float clip=info.clamp*VMAX;
	for(int i=0;i<n;i++) {
		float df=f/fmax;
		/*
		if(df>1)
			nvec=noise3D(v2*f);
		else
		nvec=noise3D(v1*f);
		*/
	    //if(df>=1)
	    //    nvec=noise3D(v2*f);
	   // else if(df<0.25)
	   //     nvec=noise3D(v1*f);
	   // else{
	        float m=smoothstep(0.1,1.75,df);
	        vec4 P1=noise3D(v1*f);
	        vec4 P2=noise3D(v2*f);
	        nvec=mix(P1,P2,m);
	   // }
	    
        //nvec=noise3D(f);
		nvec.yzw*=f;
		if(nvec.x>clip+0.1*nvec.x){
			nvec.x=clip+0.1*nvec.x;
			nvec.yzw*=0.1;
		}		
		f*=info.L;
		if(info.absval) {
			if(nvec.x<0.0)
			    nvec=-nvec;
			if(rmin>0.0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
				x=GCURVE1(x);
			    nvec.x=rmin*x;
			}
			nvec.x=VMAX-nvec.x;
			nvec.yzw=-nvec.yzw;
			nvec*=2;
		}
		else{
			nvec.x=VMAX+nvec.x;
		    if(rmin>0.0 && nvec.x<=rmin){
		    	x=nvec.x/rmin;
			    y=DCURVE1(x);
			    nvec.yzw*=y;
			    x=GCURVE1(x);
			    nvec.x=rmin*x;
		    }
		}
		val=nvec*weight*fact;
		last_val=result;
		result += val;
		fact*=info.delta;
		if(weight<=0.0)
		    break;
		weight*=nvec.x*gain+info.bias;
		weight=clamp(weight,0.0,1.0);
	}
	if(rem>0.0)
		result=last_val+rem*val;
	if(info.sqr){
		result.yzw*=2.0*abs(result.x);  // derivative of x^2 ?
		if(info.uns)
			result.x*=result.x;
		else
		    result.x*=abs(result.x);
	}
	if(info.invert)
		result=-result;
	result*=noise_fade*info.ampl;
	result.x+=noise_fade*info.offset;
	return result;	
}
#ifdef _BUMPS_
#ifdef VNOISE
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x; \
 	if(lighting) { \
 	    df=gv.yzw; \
 	    df*=0.1*noise_fade*bump_ampl; \
		bump = bump + amplitude*df; \
    }
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g= gv.x; \
 	if(lighting) { \
 	    float delta=bump_delta; \
		nbamp = 0.1*noise_fade*bump_ampl/delta; \
		b = g; \
		v1 = vec3(Vertex1.x+delta,Vertex1.y,Vertex1.z);  \
		v2 = vec3(Vertex2.x+delta,Vertex2.y,Vertex2.z);  \
 		gv = func; \
		df.x =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y+delta,Vertex1.z); \
		v2 = vec3(Vertex2.x,Vertex2.y+delta,Vertex2.z); \
 		gv = func; \
		df.y =gv.x; \
		v1 = vec3(Vertex1.x,Vertex1.y,Vertex1.z+delta); \
		v2 = vec3(Vertex2.x,Vertex2.y,Vertex2.z+delta); \
 		gv = func; \
		df.z =gv.x; \
		df = (df-vec3(b,b,b))*(nbamp); \
		bump = bump + amplitude*df; \
    }
#endif
#else
#define SET_NOISE(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
 	gv = func; \
 	g=gv.x;
#endif

#define NOISE_COLOR(func) \
	v1= Vertex1.xyz; \
    v2= Vertex2.xyz; \
    vec4 ncolor=func; \
 	color =ncolor+color;

#define NOISE_VARS \
    df=vec3(0); \
    nbamp=0.0; \
    g=0.0; \
    b=0.0; \
    noise_fade=0.0; \
	gv=vec4(0.0);

// ########## end noise_funcs.frag #########################
#endif
uniform sampler2D sprites;
uniform vec3 offset;

uniform bool textures;

uniform float INVROWS;

// ########## main section #########################
void main(void) {
#ifdef COLOR
	vec4 color=Color;
#else
	vec4 color=vec4(1.0);
#endif
    vec3 normal=normalize(Normal.xyz);

    vec2 l_uv=INVROWS*(gl_TexCoord[0].xy);

	vec4 texcol=texture2D(sprites,l_uv);
	if(textures)
		color.a*=texcol.a;
    if(lighting)
    	color.rgb=setLighting(color.rgb,normal);

	gl_FragData[0]=color;
	gl_FragData[1]=vec4(0,0,0,1);
	gl_FragData[2]=vec4(0,0,0,1);

}
// ########## end clouds.frag #########################

