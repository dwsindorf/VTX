
//************************************************************
// classes Rock, RockMgr
//************************************************************
#include "SceneClass.h"
#include "RenderOptions.h"
#include "Rocks.h"
#include "Util.h"
#include "MapNode.h"
#include "ModelClass.h"
#include "AdaptOptions.h"
#include "TerrainClass.h"
#include "ImageClass.h"
#include "UniverseModel.h"
#include "GLSLMgr.h"
#include "Effects.h"

#include <map>
#include <set>

extern double Hscale,Gscale, Drop, MaxSize,Height,Theta,Phi,Slope,MaxHt;
extern int test7, test8;

extern Point MapPt;
extern double ptable[];

static const char *def_rnoise_expr="noise(GRADIENT,0,2)\n";

static TerrainData Td;

#define PSCALE 0.008 // placement scale factor

static bool first=true;
static int tid=0;
static int pid=0;
static int nbumps=0;
static bool cvalid;

#define PRINT_STATS
//#define PRINT_ROCK_STATS
//#define PRINT_ROCK_CACHE_STATS
//#define PRINT_ACTIVE_TEX
//#define USE_TEMPLATES
//#define PRINT_LOD_STATS

static bool shadow_start=false;

// 3d rocks using marching cubes
// Tasks:
// 1. generate color test if 3d flag is set - done
// 2. set density gradient on surface if 3d - done
// 3. capture size and position information for placement - done
// 4. create array of 3d rocks with placement and size info - done
// 7. for each layer and rock in layer emit rock as a marchingCubes Object - done
// 8. refactor rock3d and rock classes to use the same wxWidgets GUI
//    - change both to use Point in base [] for modulation rather than argument 
//      note: 2d rocks now always map from surface
//    - in both modify arguments to "standard" as in plants and sprites
//      so all rocks can have biases
//    - add "3d" checkbox to UI
//      in UI change only class name (rock or rock3d) to regenerate
// 9. add noise modulation to 3d rocks using existing methods - done
// 10. support for shadows - done
// 11. improve lighting model (done)
// 12. add color -done 
// 13. add single texture (triplanar) using simple shader - done
// 14. add bump-map
// 15  multi-textures
//
// Notes:
// (1) the terrain stack may have one or more "layers"
//     - each "layer" has a separate Rock3DObjMgr
// (2) each Rock3DObjMgr can have multiple Rock types (PlaceObjs)
//     - typically 1 or 2
// (3) each rock type has a single TNRock, Rock3DMgr and Rock3D instance
//     - TNRock: generated by parsing the scene file (child of terrain stack)
//     - Rock3DMgr: responsible for creating rock instance candidates
//     - Rock3D: used by Rock3DObjMgr to produce final array of 3d rocks (utility class)
// (4) generation sequence
//     - In MapClass(render_objects) 
//       * called for each terrain layer and 3DObjMgr type instance in each layer (Plants, Sprites 3DRocks)
//       * traverses map data and generates array of visible objects (MapNodes) as seed candidates for placements 
//       * for each MapNode: calls MapNode->setSurface() to put 3d vertex(point) etc. into global objects
//       * calls Rock3DObjMgr: eval(): 
//     - Rock3DObjMgr(eval)
//       * for each type(TNrock), calls TNrock->eval() which calls Rock3Dmgr->eval()
//       * Rock3Dmgr populates global hash table with placement candidates
//     - Rock3DObjMgr(collect)
//       * traverses hash table and fills static array PlaceData(data)
//     - Rock3DObjMgr (render)
//       * parses data array and fills vertex buffer with OpenGL data (if need rebuild determined)
//     - Rock3DObjMgr (setProgram)
//       * sets up OpenGl environment for all objects to be rendered
//       * sets shader program
//     - Rock3DObjMgr (render_object)
//       * uploads/ renders data using vertex buffers

//************************************************************
// Rock3D class
//************************************************************
Rock3D::Rock3D(int t, TNode *e):PlaceObj(t,e)
{
	texid=0;
}
PlacementMgr *Rock3D::mgr() { 
	return ((TNrocks3D*)expr)->mgr;
}

bool Rock3D::initProgram(){
	Rock3DMgr* rmgr=(Rock3DMgr*)mgr();
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();
	TNcolor *color=(TNcolor*)rmgr->color;
	if(color && color->isEnabled())
		cvalid=true;
	//for(int i=0;i<rmgr->texs.size;i++){	
	for(int i=rmgr->texs.size-1;i>=0;i--){
		TNtexture *tntex=rmgr->texs[i];
		Texture *texture=tntex->texture;
		if(!tntex->isEnabled())
			continue;
		texture->set3D();

		TerrainProperties::tid=tid;
		if(texture->bump_active && Render.bumps())
			nbumps++;
		texture->tid=tid;
		texture->eval();
		texture->initProgram();
		tid++;
	}
	CurrentScope->set_passmode(mode);
	return true;
}

bool Rock3D::setProgram(){
	Rock3DMgr* rmgr=(Rock3DMgr*)mgr();
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();
		
	for(int i=rmgr->texs.size-1;i>=0;i--){  // reverse needed so 1-d tex is drawn last as in 2d rocks
	//for(int i=0;i<rmgr->texs.size;i++){
		TNtexture *tntex=rmgr->texs[i];
		Texture *texture=tntex->texture;
		if(!tntex->isEnabled())
			continue;
		TerrainProperties::tid=tid;
		texture->eval();
		texture->pid=pid;
		texture->setProgram();
		tid++;
	}
	CurrentScope->set_passmode(mode);
	return true;
}
//************************************************************
// helper functions
//************************************************************

Color rock_color(0.6, 0.5, 0.4);

static SurfaceFunction makeRockField(const Point& center, PlaceData *s) {
    return [center, s](double x, double y, double z) -> double {
        Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
        TNode *tc = pmgr->rnoise;
        double noiseAmpl = pmgr->noise_amp;
        double comp = pmgr->comp;
        bool noisy = (noiseAmpl > 1e-6);
             
        double comp_factor=std::max((1.0 - 2*comp),0.2);
       
        double dx = x - center.x;
        double dy = y - center.y;
        double dz = z/comp_factor - center.z;
        
        // Ellipsoid distance (not sphere)
        double ex = 2*dx;
        double ey = 2*dy;
        double ez = 2*dz;
        double ellipsoidDist = sqrt(ex*ex + ey*ey + ez*ez);
        
        // Base ellipsoid (positive inside)
        double baseEllipsoid = 1.0 - ellipsoidDist;
        
        if(tc && noisy){
			Point np = Point(dx, dy, dz);
			TheNoise.set(np);
			tc->eval();
			baseEllipsoid-=S0.s * noiseAmpl;
        }
        return baseEllipsoid;
    };
}

// Post-mesh vertex displacement and color: uses standard noise function
static void applyVertexAttributes(MCObject* rock, double amplitude, TNode *tv, TNode *tc) {
    
    Point center = rock->worldPosition;
    double rockSize = rock->baseSize;
        
    for (auto& tri : rock->mesh) {
        for (int v = 0; v < 3; v++) {
            Point &vertex = tri.vertices[v];
            Color &color =tri.colors[v];
            
            // Direction from center to vertex (outward normal)
            Point dir = (vertex - center).normalize();
            
            // Normalize position relative to rock center and size
            // This gives us unit-scale coordinates for noise sampling
            double nx = (vertex.x - center.x) / rockSize;
            double ny = (vertex.y - center.y) / rockSize;
            double nz = (vertex.z - center.z) / rockSize;
			Point np(nx,ny,nz);
			TheNoise.set(np);
			Point pn;
			double rz=0;
			Point pv=vertex;
			if(tv && tv->isEnabled()){
				SINIT;
				tv->eval();	
				if(S0.pvalid()){
					Point pd=S0.p;
					Point delta=dir*pd*amplitude;
					vertex=vertex-delta;
				}
			}
			color=rock_color;
			if(tc && tc->isEnabled()){
				SINIT;
				tc->eval();	
				if(S0.cvalid())
					color=S0.c;
			}
        }
    }
}

static MCObject* getTemplateForLOD(PlaceData *s) {
    Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
    double pts = s->pts;
    int rval = s->rval;
    double comp = pmgr->comp;
    int resolution = Rock3DMgr::getLODResolution(pts);
    double noiseAmpl = pmgr->noise_amp;
	bool noisy=(noiseAmpl>1e-6);
#ifdef USE_TEMPLATES
    int k1=resolution * 100;
    int k2=(int)(rval)%Rock3DObjMgr::templates_per_lod;
    int k3=s->instance*1000;
    int key = k1 + k2 +k3;
    auto it = Rock3DObjMgr::lodTemplates.find(key);
    if (it != Rock3DObjMgr::lodTemplates.end()) {
    	Rock3DObjMgr::lodCacheHits++;
        return it->second;
    }
#endif   
    Point origin(0, 0, 0);
    MCObject* templateSphere = new MCObject(origin, 1.0);
    
    MCGenerator generator;
 
    // Adjust bounds to match ellipsoid size
    // Add extra margin for noise (especially when noiseAmpl is high)
    double margin = 1 + 3*noiseAmpl;  // Increase margin with noise amplitude
    Point boundsMin(-0.5 * margin, -0.5 * margin, -0.5 * margin);
    Point boundsMax(0.5 * margin, 0.5 * margin, 0.5 * margin);    
   
    SurfaceFunction field = makeRockField(origin, s);
    templateSphere->mesh = generator.generateMesh(field, boundsMin, boundsMax, resolution, 0.0);
    templateSphere->meshValid = true;    
#ifdef USE_TEMPLATES
    Rock3DObjMgr::lodTemplates[key] = templateSphere;
#ifdef PRINT_LOD_STATS    
    cout << "Created LOD template: resolution:" << resolution<< " key:"<<key 
         << " k1:"<< k1 << " k2:" << k2 
         << " Triangles:" << templateSphere->mesh.size() << endl;
#endif 
#endif
    Rock3DObjMgr::lodCacheMisses++;
    return templateSphere;
}

//************************************************************
// Rock3DMgr class
//************************************************************
int Rock3DMgr::stats[MAX_ROCK_STATS][2];
double Rock3DMgr::resScale=1;

Rock3DMgr::Rock3DMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,MCROCKS);
	comp=0.0;
	drop=0.0;
	vnoise=0;
	rnoise=0;
	color=0;

#ifdef TEST_ROCKS
    set_testColor(true);
#endif
   set_testDensity(true);
   set_useaveht(true);
}

void Rock3DMgr::eval(){	
	PlacementMgr::eval(); 
}

void Rock3DMgr::init()
{
	PlacementMgr::init();
  	reset();
}

//-------------------------------------------------------------
// Rock3DMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *Rock3DMgr::make(Point4DL &p, int n)
{
    return new Placement(*this,p,n);
}
PlaceData *Rock3DMgr::make(Placement*s)
{
    return new Rock3DData(s);
}

//bool Rock3DMgr::testColor() { 
//	return PlacementMgr::testColor()?true:false;
//}
//bool Rock3DMgr::testDensity(){ 
//	return true;
//}

void Rock3DMgr::clearStats(){
	for(int i=0;i<MAX_ROCK_STATS;i++){
		stats[i][0]=stats[i][1]=0;
	}
}

struct RockLodEntry {
    int    res;     // voxel resolution
    double maxPts;  // upper bound for pts (pts < maxPts)
};

static const RockLodEntry kRockLodTable[MAX_ROCK_STATS] = {
    {  2,  2.0 },
    {  4,  5.0 },
    {  8,  10.0 },
    {  16, 20.0 },
    { 32, 30.0 },
    { 48, 50.0 },
    { 64, 90.0 },
    { 128,  1e9 }  // default 
};

void Rock3DMgr::printStats(){
    int rcnt = 0;
    int tcnt = 0;
    int kcnt = 0;
    std::cout << "------- 3D Rocks stats --------" << std::endl;
#ifdef USE_TEMPLATES
    int lod_calls=(Rock3DObjMgr::lodCacheHits+Rock3DObjMgr::lodCacheMisses);
    std::cout << "LOD Cache calls:"<<lod_calls<<" hits:"<<100.0*Rock3DObjMgr::lodCacheHits/lod_calls<<" %"<<endl;
#endif

    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
#ifdef PRINT_ROCK_STATS
        std::cout << "res:"       << (int)(kRockLodTable[i].res*resScale)
                  << " cnt:"      << stats[i][0]
                  << " triangles:"<< stats[i][1]/1000<<" k"
                  << std::endl;
#endif
        rcnt  += stats[i][0];
        tcnt  += stats[i][1];
    }
    std::cout << "Totals rocks:"    << rcnt
              << " triangles:"      << tcnt/1000<<" k"
              << std::endl;
}

void Rock3DMgr::setStats(int res, int tris,bool add){
    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
        if ((int)(kRockLodTable[i].res*resScale) == res) {
        	if(add){
				stats[i][0]++;           // count of rocks at this res
				stats[i][1] += tris;     // total triangles

        	}
        	else{
				stats[i][0]--;           // count of rocks at this res
				stats[i][1] -= tris;     // total triangles
        	}
            return;
        }
    }
}

int Rock3DMgr::getLODResolution(double pts) {
	int res=kRockLodTable[MAX_ROCK_STATS - 1].res; // fallback
 	for (int i = 0; i < MAX_ROCK_STATS; ++i) {
		if (pts < kRockLodTable[i].maxPts) {
			res=kRockLodTable[i].res;
			break;
		}
	}
 	double cellsize=TheScene->cellsize;

 	if (cellsize <= 3.5) {// Between best and normal: lerp from 2.0 to 1.0	        
 	   resScale = lerp(cellsize, 1, 3.5, 2.0, 1.0);
 	} else {// Between normal and draft: lerp from 1.0 to 0.5 	        
 	   resScale = lerp(cellsize, 3.5, 7, 1.0, 0.5);
    }
 	int newres=(int)(res*resScale);
 	newres=newres<2?2:newres;
 	//resScale=lerp(TheScene->cellsize-3.5,-2.5,2.5,2,0.5);	
 	//cout<<"scale:"<<resScale<<" res "<<res<<"->"<<newres<<endl;
	return newres;
}
//************************************************************
// Rock3DObjMgr class
//************************************************************
MCObjectManager Rock3DObjMgr::rocks;
ValueList<PlaceData*> Rock3DObjMgr::data(10000, 5000);
std::map<Rock3DObjMgr::RockCacheKey, Rock3DObjMgr::RockCacheEntry> Rock3DObjMgr::rockCache;
int Rock3DObjMgr::cacheHits = 0;
int Rock3DObjMgr::cacheMisses = 0;
int Rock3DObjMgr::cacheRegens = 0;
int Rock3DObjMgr::maxTexs = 0;
int Rock3DObjMgr::lodCacheHits=0;
int Rock3DObjMgr::lodCacheMisses=0;
int Rock3DObjMgr::templates_per_lod=2;
std::map<int, MCObject*> Rock3DObjMgr::lodTemplates;
Rock3DObjMgr::~Rock3DObjMgr(){
	freeLODTemplates();
}

void Rock3DObjMgr::freeLODTemplates() {
    for (auto& pair : lodTemplates) {
        delete pair.second;
    }
    lodTemplates.clear();
}

double calculateNightLighting(double tod) {
    const double dawnStart = 0.20, dawnEnd = 0.3;
    const double duskStart = 0.7, duskEnd = 0.85;   
    // Night (before dawn or after dusk)
    if (tod < dawnStart || tod > duskEnd) 
        return 0.0;  
    // Full day (between dawn and dusk)
    if (tod >= dawnEnd && tod <= duskStart) 
        return 1.0;    
    // Dawn transition (smoothstep from 0 to 1)
    if (tod < dawnEnd) 
        return smoothstep(dawnStart, dawnEnd, tod);   
    // Dusk transition (smoothstep from 1 to 0)
    return 1.0 - smoothstep(duskStart, duskEnd, tod);
}
//-------------------------------------------------------------
// Rock3DObjMgr::setProgram() initialize shader
//-------------------------------------------------------------
bool Rock3DObjMgr::setProgram() {
    if (!data.size || !objs.size)
        return false;   
 
	if(PlaceObjMgr::shadow_mode)
		return false;
		
    char defs[1024] = "";
    sprintf(defs+strlen(defs), "#define NLIGHTS %d\n", Lights.size);

    bool do_shadows=Raster.shadows();
 	if(do_shadows && !TheScene->light_view()&& !TheScene->test_view())
 		sprintf(defs+strlen(defs),"#define SHADOWS\n");

    GLSLMgr::setDefString(defs);
    maxTexs=0;
    if(Render.textures()){
    	tid=0;
    	nbumps=0;
    	cvalid=false;
    	Texture::reset();
		for(int i=0;i<objs.size;i++){
			objs[i]->initProgram();
		}
		maxTexs=tid;
    }
    if(cvalid)
    	sprintf(defs,"#define COLOR \n#define NTEXS %d\n#define NBUMPS %d\n",maxTexs,nbumps);
    else
		sprintf(defs,"#define NTEXS %d\n#define NBUMPS %d\n",tid,nbumps);

	strcat(GLSLMgr::defString,defs);
    GLSLMgr::loadProgram("rocks3d_tex.vert", "rocks3d_tex.frag");
	tid=0;
	pid=0;
	for(int i=0;i<objs.size;i++){
		objs[i]->setProgram();
		pid++;
	}
   GLhandleARB program = GLSLMgr::programHandle();
    if (!program)
        return false;
     GLSLVarMgr vars;

    Planetoid *orb = (Planetoid*)TheScene->viewobj;
    Color diffuse = orb->diffuse;
    Color ambient = orb->ambient;
	Color shadow=orb->shadow_color;
	Color haze=Raster.haze_color;
	
	double tod=orb->tod;
	
	double night_lighting=1;
	if(!TheScene->changed_file())
		night_lighting=calculateNightLighting(tod);
	//cout<<"tod:"<<tod<<" "<<night_lighting<<endl;
     
    vars.newFloatVec("Diffuse", diffuse.red(), diffuse.green(), diffuse.blue(), diffuse.alpha());
    vars.newFloatVec("Ambient", ambient.red(), ambient.green(), ambient.blue(), ambient.alpha());
	vars.newFloatVec("Shadow",shadow.red(),shadow.green(),shadow.blue(),orb->shadow_intensity);
	vars.newFloatVec("Haze",haze.red(),haze.green(),haze.blue(),haze.alpha());
	
	vars.newFloatVar("night_lighting",night_lighting);
	vars.newBoolVar("lighting",Render.lighting());
	vars.newIntVar("activeTexture",0);

    vars.setProgram(program);
    vars.loadVars();

    GLSLMgr::setProgram();
    GLSLMgr::loadVars();
    
    return true;
}
void Rock3DObjMgr::free() { 
	data.free();
}

//-------------------------------------------------------------
// Rock3DObjMgr::collect() generate array of placements (data)
//-------------------------------------------------------------
void Rock3DObjMgr::collect() {
    data.free();
    for (int i = 0; i < objs.size; i++) {
        PlaceObj *obj = objs[i];
        obj->mgr()->collect(data);
    }
    if (data.size) // now sorted by instance instead of distance
        data.sort();
//    for(int i=0;i<data.size;i++)
//    	cout<<data[i]->instance;
}

void Rock3DObjMgr::render_zvals(){

	if(objs.size==0)
		return;
	//cout<<"Rock3DObjMgr::render_zvals() view:"<<Raster.shadow_vcnt<<":"<<Raster.shadow_vsteps<<endl;
	if(Raster.shadow_vcnt==0)
		shadow_start=true;
	shadow_mode=true;
	render();
    shadow_start=false;

	shadow_mode=false;
}

void Rock3DObjMgr::render_shadows(){
	if(objs.size==0)
		return;
	shadow_mode=true;
    
	// not really needed - these are the defaults for shadow mode
	Raster.setShadowProgram("shadows.vert",0,0);
	Raster.setProgram(Raster.PLACE_SHADOWS);
	render();
//	if(Raster.shadow_vcnt==Raster.shadow_vsteps-1)
	shadow_mode=false;
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render() {
    int n = data.size;
    if (n == 0)
        return;
    
	//cout<<"Hscale:"<<Hscale<<" Gscale:"<<1000/Gscale<<endl;

    bool wireframe = test7;
    bool smooth =Render.avenorms();//test8;
    
    bool moved = TheScene->moved();
    bool changed=TheScene->changed_detail();
    
    if (PlaceObjMgr::shadow_mode && !shadow_start) {
        moved = false;
        changed = false;
    }
    
    bool placement_needs_update = moved;
    bool mesh_needs_rebuild = changed;
    
    if (changed) {
        std::cout << "Settings changed - invalidating" <<endl;
        rockCache.clear();
        rocks.clear();
        freeLODTemplates();
        Rock3DMgr::clearStats();
    }    	
      
    if (placement_needs_update || mesh_needs_rebuild) {
        rocks.clear();
        Rock3DMgr::clearStats();
        
        Point xpoint = TheScene->xpoint;
        
        // Mark all cached as not used
        for (auto& pair : rockCache) {
            pair.second.framesSinceUsed++;
        }
        
        int hits = 0, misses = 0, regens = 0;

        for (int i = 0; i < n; i++)  {
            Rock3DData *s = data[i];
            
            Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
            TNode *tr = pmgr->rnoise;
            
            char tmp[1024];
            tmp[0] = 0;
            if (tr)
                tr->valueString(tmp);
            TNode *tv = pmgr->vnoise;  
            if (tv)
                tv->valueString(tmp);
            TNode *tc = pmgr->color;  
            if (tc)
                tc->valueString(tmp);
            std::string estr = tmp;
            
            double isoNoiseAmpl = pmgr->noise_amp;
            
            bool useNoisyIsoSurface = isoNoiseAmpl > 0;
            bool useVertexDisplacement = (tv != nullptr && tv->isEnabled());
            bool setVertexColor = (tc != nullptr && tc->isEnabled());
            
            double vertexNoiseAmpl = useVertexDisplacement ?0.5*pmgr->noise_amp : 0;

            Point eyePos = s->vertex - xpoint;
            double size = 4*Hscale * s->radius;
            double pts = s->pts;
            double dist = s->dist;
            int rval = s->rval;
            double comp = pmgr->comp;
            double drop = pmgr->drop;
            int instance=s->instance;
             
            int resolution = Rock3DMgr::getLODResolution(pts);
            
            // Create cache key from world position
            RockCacheKey key(s->vertex,instance);
           
            char name[64];
            sprintf(name, "rock_%d", i);
            
            // Check cache
            auto it = rockCache.find(key);
            
            bool needsGeneration = true;
            std::vector<MCTriangle> templateMesh;
            bool cacheHit=false;
            
            if (it != rockCache.end()) {
                RockCacheEntry& entry = it->second;
                entry.framesSinceUsed = 0;
                
                // Check what's different
                bool resMatch = (entry.resolution == resolution);
                bool seedMatch = (entry.seed == rval);
                bool isoNoiseExprMatch = (estr == entry.estr);
                bool instanceMatch = (instance == entry.instance); 
                if (!resMatch || !seedMatch || !isoNoiseExprMatch|| !instanceMatch) {
#ifdef DEBUG_REGEN               
                    // DEBUG: Show why regenerating
                    static int regenDebugCount = 0;
                    if (regenDebugCount < 10) {
                        std::cout << "REGEN rock " << i << " pos(" << s->vertex.x << "," << s->vertex.y << "): ";
                        if (!resMatch) std::cout << "res " << entry.resolution << "->" << resolution << " ";
                        if (!seedMatch) std::cout << "seed " << entry.seed << "->" << rval << " ";
                        if (!instanceMatch) std::cout << "inst " << entry.instance << "->" << instance << " ";
                        std::cout << std::endl;
                        regenDebugCount++;
                    }
#endif                   
                    regens++;
                    rockCache.erase(it);
                    needsGeneration = true;
                } else {
                    // CACHE HIT
                    templateMesh = entry.mesh;
                    needsGeneration = false;
                    cacheHit=true;
                    hits++;
                }
            } else {
                misses++;
            }

            // Generate if needed
            
            if (needsGeneration) {
                int rseed=TheNoise.rseed;
                TheNoise.rseed=rval;
                MCObject* templateSphere = getTemplateForLOD(s);                
                if (!templateSphere || templateSphere->mesh.empty()){
                    TheNoise.rseed = rseed;
                    continue;   
                }
                
                // Copy mesh without modification
                for (const auto& tri : templateSphere->mesh) {
                    MCTriangle newTri;
                    for (int v = 0; v < 3; v++) {
                        newTri.vertices[v] = tri.vertices[v];
                        newTri.templatePos[v] = tri.templatePos[v];  // COPY TEMPLATE POSITIONS!
                        newTri.colors[v] = tri.colors[v];            // And colors while we're at it
                    }
                    newTri.normal = Point(-tri.normal.x, -tri.normal.y, -tri.normal.z);
                    newTri.faceNormal = tri.faceNormal;  // Copy face normal too
                    templateMesh.push_back(newTri);
                }               
                
                // Apply vertex displacement in template space
                if (useVertexDisplacement || setVertexColor) {
                    MCObject tempRock(Point(0,0,0), 1.0);
                    tempRock.mesh = templateMesh;
                    applyVertexAttributes(&tempRock,vertexNoiseAmpl, tv, tc);
                    templateMesh = tempRock.mesh;
                 }
                                
                // Store in cache
                RockCacheEntry entry;
                entry.mesh = templateMesh;
                entry.worldVertex = s->vertex;
                entry.resolution = resolution;
                entry.estr = estr;
                entry.seed = rval;
                entry.framesSinceUsed = 0;
                entry.instance=instance;
                
                rockCache[key] = entry;
        	
                TheNoise.rseed = rseed;
            }
            
            // Create rock and transform to eye space
            MCObject* rock = rocks.addObject(eyePos, size);
            
            if (rock) {
                rock->setDistanceInfo(dist, pts);
                rock->mesh.clear();
                rock->instanceId = instance;
                rock->dataIndex = i;  // Store the data array index!
                
                // Get world position and surface normal
                Point worldPos = s->vertex;
                Point up = s->normal;
                
                double dscale=Hscale*drop*(1-0.5*comp)*0.5;
                
                // Apply drop: lower the rock center along surface normal
                Point rockCenter = worldPos - up*(s->radius * dscale);
                
                Point right, forward;
                if (fabs(up.z) < 0.9)
                    right = Point(up.y, -up.x, 0).normalize();
                else
                    right = Point(0, up.z, -up.y).normalize();
                
                forward = Point(up.y * right.z - up.z * right.y,
                        up.z * right.x - up.x * right.z,
                        up.x * right.y - up.y * right.x);
 
                for (const auto& tri : templateMesh) {
                    MCTriangle newTri;   
                    
                    for (int v = 0; v < 3; v++) {
                        Point tv = tri.vertices[v];         
                        newTri.templatePos[v] = tv+0.002*(s->rval);  // STORE template position
                        Point rotated = Point(
                                    tv.x * right.x + tv.y * forward.x + tv.z * up.x,
                                    tv.x * right.y + tv.y * forward.y + tv.z * up.y,
                                    tv.x * right.z + tv.y * forward.z + tv.z * up.z);
                        //newTri.templatePos[v] = rotated;  // STORE template position
                        Point worldVertex = rockCenter+rotated*size;
                        newTri.vertices[v] = worldVertex - xpoint; // Convert to eye space
                        newTri.colors[v]=tri.colors[v];
                    } 
 
                    // Calculate normal in eye space from the 3 eye-space vertices
                    Point edge1 = newTri.vertices[1] - newTri.vertices[0];
                    Point edge2 = newTri.vertices[2] - newTri.vertices[0];
                    Point eyeNormal = edge2.cross(edge1);
                    
                    // face normal for texture mapping                    
                    Point edge3 = newTri.templatePos[1] - newTri.templatePos[0];
                    Point edge4 = newTri.templatePos[2] - newTri.templatePos[0];
                    Point faceNormal = edge4.cross(edge3);
                     	
                    static Point lastGoodEye=Point(0, 1, 0);
                    static Point lastGoodFace=Point(0, 1, 0);
                    if (eyeNormal.length() > 1e-30) {
                    	lastGoodEye = eyeNormal;               	
                    } 
                    if (faceNormal.length() > 1e-30) {
                    	lastGoodFace = faceNormal;               	
                    }
                    newTri.normal = lastGoodEye.normalize();
                    newTri.faceNormal = lastGoodFace.normalize();  
                    rock->mesh.push_back(newTri);
                }
                rock->meshValid = true;
                rock->worldPosition = eyePos;
                
                // Upload VBO
                if (smooth || useVertexDisplacement)
                    rock->uploadToVBODisplaced(smooth);
                else 
                    rock->uploadToVBO(); 
                Rock3DMgr::setStats(resolution, rock->mesh.size(),true);
            }
        }
        
        // Cull old cache entries
        int culledCount = 0;
        for (auto it = rockCache.begin(); it != rockCache.end(); ) {
            if (it->second.framesSinceUsed > 20) {
                it = rockCache.erase(it);
                culledCount++;
            } else {
                ++it;
            }
        }
        
        // Cache size limit
        const size_t MAX_CACHE_SIZE = 10000;
        if (rockCache.size() > MAX_CACHE_SIZE) {
            std::vector<std::pair<RockCacheKey, int>> ages;
            for (auto& pair : rockCache) {
                ages.push_back({pair.first, pair.second.framesSinceUsed});
            }
            std::sort(ages.begin(), ages.end(), 
                      [](auto& a, auto& b) { return a.second > b.second; });
            
            size_t toRemove = rockCache.size() - MAX_CACHE_SIZE;
            for (size_t i = 0; i < toRemove; i++) {
                rockCache.erase(ages[i].first);
            }
            std::cout << "Cache limit reached - removed " << toRemove << " oldest entries" << std::endl;
        }
        
        // DEBUG: Summary
        std::cout << "Cache: " << hits << " hits, " << misses << " misses, " << regens << " regens, " 
                  << culledCount << " culled, " << rockCache.size() << " total cached" << std::endl;
        Rock3DMgr::printStats();
    }
     render_objects();
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render_objects() {
    bool wireframe = test7;

    static std::set<int> lastFrameRocks;
    std::set<int> thisFrameRocks;

    int currentRockType = -1;
    int rockIndex = 0;
    int drawnCount = 0;

    if(!PlaceObjMgr::shadow_mode){
    	if (!setProgram()) {
    	  cout << "Rock3DObjMgr::setProgram FAILED" << endl;
    	  return;
    	}
    }
    if (wireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	else
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    const std::vector<MCObject*>& rockList = rocks.getObjects();
    int validCount = 0, invalidVboCount = 0, emptyMeshCount = 0;

	GLhandleARB program = GLSLMgr::programHandle();
	for (MCObject *rock : rockList) {
		if (!rock->vboValid) {
		        invalidVboCount++;
		        continue;
		    }
		    if (rock->mesh.size() == 0) {
		        emptyMeshCount++;
		        continue;
		    }
		    validCount++;
		if (rock->vboValid && rock->mesh.size() > 0) {
			thisFrameRocks.insert(rockIndex);
			PlaceData* placeData = data[rockIndex];
			//int rockType = placeData->instance;  // 0, 1, 2, etc.
			int rockType = rock->instanceId;
			
			int mgrInstance = placeData->mgr->instance;

			for (int i = 0; i < maxTexs; i++) { // set active status for all textures
				char str[64];
				sprintf(str, "tex2d[%d].active", i);
				GLint loc = glGetUniformLocationARB(program, str);
				if (loc >= 0) {
					glUniform1iARB(loc, rockType);
				}
			}
			// show when active texture changes
#ifdef PRINT_ACTIVE_TEX
			if (rockType != currentRockType) {				
				std::cout << "Switching active rock instance " << currentRockType <<"->"<<rockType<<std::endl;				
				currentRockType = rockType;
			}
#endif             
			glBindBuffer(GL_ARRAY_BUFFER, rock->vboVertices);
			glVertexPointer(3, GL_FLOAT, 0, 0);
			glEnableClientState(GL_VERTEX_ARRAY);

			glBindBuffer(GL_ARRAY_BUFFER, rock->vboNormals);
			glNormalPointer(GL_FLOAT, 0, 0);
			glEnableClientState(GL_NORMAL_ARRAY);
			
            glBindBuffer(GL_ARRAY_BUFFER, rock->vboColors);
            glColorPointer(3, GL_FLOAT, 0, 0);
            glEnableClientState(GL_COLOR_ARRAY);

			GLint attribLoc1 = glGetAttribLocation(program, "templatePosition");
			if (attribLoc1 >= 0) {
				glBindBuffer(GL_ARRAY_BUFFER, rock->vboTemplatePos);
				glVertexAttribPointer(attribLoc1, 3, GL_FLOAT, GL_FALSE, 0, 0);
				glEnableVertexAttribArray(attribLoc1);
			}
			GLint attribLoc2 = glGetAttribLocation(program, "faceNormal");
			if (attribLoc2 >= 0) {
				glBindBuffer(GL_ARRAY_BUFFER, rock->vboFaceNormals);
				glVertexAttribPointer(attribLoc2, 3, GL_FLOAT, GL_FALSE, 0, 0);
				glEnableVertexAttribArray(attribLoc2);
			}
			glDrawArrays(GL_TRIANGLES, 0, rock->mesh.size() * 3);
			
			// Disable template position attribute
			if (attribLoc1 >= 0) 
			    glDisableVertexAttribArray(attribLoc1);
			if (attribLoc2 >= 0) 
			    glDisableVertexAttribArray(attribLoc2);
			glDisableClientState(GL_VERTEX_ARRAY);
			glDisableClientState(GL_NORMAL_ARRAY);
			glDisableClientState(GL_COLOR_ARRAY);
			rockIndex++;

		}
	}
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}
//************************************************************
// TNrocks3D class
//************************************************************
TNrocks3D::TNrocks3D(int t,TNode *l, TNode *r, TNode *b) : TNrocks(t|MCROCKS,l,r,b)
{
	delete mgr;
	mgr=new Rock3DMgr(type);
	rock=0;
}

static Rock3DMgr *rm;
static void collectTexs(NodeIF *obj){
	int type=obj->typeValue();
	if(type==ID_TEXTURE){
		TNtexture *tex=(TNtexture *)obj;
		if(tex->texture)
			tex->texture->tid=tid;
		rm->texs.add(tex);
	}
}

//-------------------------------------------------------------
// TNrocks3D::init() initialize the node
//-------------------------------------------------------------
void TNrocks3D::init()
{
	Rock3DMgr *rmgr=(Rock3DMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);
	rmgr->rnoise=0;
	TNode *tv=findChild(ID_POINT);
	if(tv)
		rmgr->vnoise=tv;
	else
		rmgr->vnoise=0;
	if(args[7]){
		if(args[7]->typeValue()==ID_POINT)
			rmgr->vnoise=args[7];
		else
			rmgr->rnoise=args[7];
	}
	TNode *tc=findChild(ID_COLOR);
	if(tc)
		rmgr->color=tc;
	else
		rmgr->color=0;
	rmgr->texs.reset();
	rm=rmgr;
	tid=0;
	if(base){
		base->visitNode(collectTexs);
		//rmgr->texs.sort();
	}
	mgr->set_first(1);
	if(rock==0)
		rock=new Rock3D(type,this);	
}

//-------------------------------------------------------------
// TNrocks3D::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks3D::eval()
{
	TerrainData ground;
	static int cnt=0;
	
	if(!isEnabled() || TheScene->viewtype !=SURFACE){
		if(right)
			right->eval();
		return;
	}
	SINIT;
	if(CurrentScope->rpass()){
		int layer=inLayer()?Td.tp->type():0; // layer id
		int instance=Td.tp->Rocks.objects();
		mgr->instance=instance;
		mgr->layer=layer;
		if(rock){
			rock->set_id(instance);
			rock->layer=layer;
		}
		Td.tp->Rocks.addObject(rock);
		mgr->setHashcode();
		if(right)
			right->eval();
		return;
	}
	if(right)
		right->eval();
	
	if(!CurrentScope->spass()){
		ground.copy(S0);
	}
	INIT;

	mgr->type=type;

	mgr->getArgs((TNarg *)left);
	
	MaxSize=mgr->maxsize;
	
	double density=mgr->density;

	if(density>0)
		mgr->eval();  // calls PlantPoint.set_terrain (need MapPt)
	S0.copy(ground); // restore S0.p.z etc
	S0.clr_flag(ROCKBODY);
	if(!CurrentScope->spass()){ // adapt pass only
		if(mgr->setTests())
			S0.set_flag(ROCKBODY);
	}
}

//------------------- 2D Rocks ------------------------------

//************************************************************
// Rock class
//************************************************************
Rock::Rock(PlacementMgr&m, Point4DL&p,int n) : Placement(m,p,n)
{
}
//-------------------------------------------------------------
// Rock::set_terrain()	impact terrain 
//-------------------------------------------------------------
bool Rock::set_terrain(PlacementMgr &pmgr)
{
	double r,z,rm=0;
	RockMgr &mgr=(RockMgr&)pmgr;
	
	mgr.pdist=1;
	if(radius==0)
		return false;
	
	double d=pmgr.mpt.distance(center);
	
	double thresh=mgr.noise_amp;
	double td=mgr.drop*mgr.maxsize;
	double t=1.75*radius;

	r=radius;

	if(d>t)
		return false;

	if(pmgr.testColor())
		Placement::set_terrain(pmgr);
	
	mgr.pdist=d/radius;
	mgr.pdist=clamp(mgr.pdist,0,1);

 	if(mgr.noise_amp>0){
 		double nf=mgr.noise_amp*radius/Hscale;
 		SPUSH;
		Point4D np;
		if(mgr.offset_valid())
		    np=(mgr.mpt-mgr.offset)*(1/radius);
		else
		    np=(mgr.mpt)*(1/radius);
 		np=np+1/radius;
 		if(TheNoise.noise3D())
 		    np.w=0;
 		TheNoise.push(np);
 		CurrentScope->revaluate();
 		double z=0;
 		if(mgr.vnoise){
 			mgr.vnoise->eval();
 		//if(mgr.rnoise->typeValue()==ID_POINT){
 			z=S0.p.z;
 			mgr.rx=nf*S0.p.x;
 			mgr.ry=nf*S0.p.y; 	
  		}
 		if(mgr.rnoise){
 			mgr.rnoise->eval();
 			z+=S0.s;
 		}
 		TheNoise.pop();
 		rm=0.25*z*mgr.noise_amp*radius;
 		SPOP;
		d+=rm;
		r-=rm;
 	}
	mgr.rdist=d/r;
	
	d=clamp(d,0,1);
	
	z=mgr.base;
	
	S0.set_flag(ROCKBODY);

	setActive(true);

    z-=0.5*mgr.comp*r/Hscale;
	if(r>d)
		z+=(1-mgr.comp)*sqrt(r*r-d*d)/Hscale;
    if(z>mgr.ht)
        mgr.ht=z;
    return true;
}

//************************************************************
// RockMgr class
//************************************************************
//	arg[0]  levels   		scale levels
//	arg[1]  maxsize			size of largest craters
//	arg[2]  mult			size multiplier per level
//	arg[3]  density			density or dexpr
//
//	arg[4]  zcomp			z compression factor
//	arg[5]  drop			z drop factor or function
//	arg[6]  noise		    noise amplitude
//	arg[7]  noise_expr		noise function
//-------------------------------------------------------------
TNode *RockMgr::default_noise=0;
RockMgr::RockMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,ROCKS);
	noise_amp=1;
	comp=0.1;
	drop=0.1;
	rnoise=0;
	vnoise=0;
	rdist=0;
	pdist=1;
	rx=ry=0;
#ifdef TEST_ROCKS
    set_testColor(true);
#endif

}
RockMgr::~RockMgr()
{
  	if(finalizer()){
#ifdef DEBUG_PMEM
  		printf("RockMgr::free()\n");
#endif
        DFREE(default_noise);
	}
}

//-------------------------------------------------------------
// RockMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *RockMgr::make(Point4DL &p, int n)
{
    return new Rock(*this,p,n);
}

//-------------------------------------------------------------
// RockMgr::init()	initialize global objects
//-------------------------------------------------------------
void RockMgr::init()
{
	if(default_noise==0){
#ifdef DEBUG_PMEM
  		printf("RockMgr::init()\n");
#endif
	   default_noise=(TNode*)TheScene->parse_node((char*)def_rnoise_expr);
	}
	PlacementMgr::init();
}

//************************************************************
// TNrocks class
//************************************************************
TNrocks::TNrocks(int t, TNode *l, TNode *r, TNode *b) : TNplacements(t|ROCKS,l,r,b)
{
    mgr=new RockMgr(type);
	TNarg &args=*((TNarg *)left);
	TNode *arg=args[8];
	if(arg && (arg->typeValue() != ID_CONST))
		mgr->dexpr=arg;
	set_collapsed();
}

//-------------------------------------------------------------
// TNrocks::applyExpr() apply expr value
//-------------------------------------------------------------
void TNrocks::applyExpr()
{
	if(!expr)
		return;
 	TNrocks* rocks=(TNrocks*)expr;
 	if(rocks->typeValue()!=typeValue()){
    	NodeIF *p=getParent();
  		rocks->base=base;
 		if(base)
 			base->setParent(rocks);
 		rocks->setParent(p);
		rocks->right=right;
 		if(right)
 			right->setParent(rocks);
  		p->replaceChild(this,rocks);
		rocks->init();
 		right=0;
 		base=0;
 		expr=0;
 		DFREE(left);
 	}
	else{ // args changed only
		DFREE(left);
		left=rocks->left;
		left->setParent(this);
		rocks->init();
		delete mgr;
		type=rocks->type;
		mgr=rocks->mgr;
		rocks->left=0;
		rocks->mgr=0;
		rocks->base=0;
		eval();
		delete rocks;
		expr=0;
	}
 }

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceChild(NodeIF *c,NodeIF *n)
{
	return TNbase::replaceChild(c,n);
}

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceNode(NodeIF *c)
{
	((TNrocks*)c)->right=right;
	((TNrocks*)c)->parent=parent;
	parent->replaceChild(this,c);
	delete base;
	base=0;
	TheScene->rebuild_all();
	return c;
}

//-------------------------------------------------------------
// TNrocks::addAfter append x after base if c==this
// - used when adding a TNnode object to a TerrainMgr stack
// - always want to append other objects after Rocks in tree
//-------------------------------------------------------------
NodeIF *TNrocks::addAfter(NodeIF *c,NodeIF *x){
	if(c==this){
		TNode *node=(TNode*)x;
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else if(c)
		c->addChild(x);
	else
		addChild(x);
	return x;
}
//-------------------------------------------------------------
// TNrocks::addChild
//-------------------------------------------------------------
NodeIF *TNrocks::addChild(NodeIF *x){
	TNode *node=(TNode*)x;
	//cout<<"rocks::addChild "<<x->typeName()<<end;
	if(collapsed() && base){
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else{
		if(base){
			node=new TNadd(node,base);
			node->setParent(this);
			base=node;
		}
		else{
			base=node;
			base->setParent(this);
		}
	}
	return x;
}

//-------------------------------------------------------------
// TNrocks::init() initialize the node
//-------------------------------------------------------------
void TNrocks::init()
{
	RockMgr *rmgr=(RockMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);
	
	TNode *tv=findChild(ID_POINT);
	if(tv)
		rmgr->vnoise=tv;
	
	if(args[7]){
		if(!tv && args[7]->typeValue()==ID_POINT)
			rmgr->vnoise=args[7];
		else	
			rmgr->rnoise=args[7];			
	}
	rmgr->noise_amp=1;
	if(args[6]){
		TNarg *tamp=args[6];
		tamp->eval();
		rmgr->noise_amp=S0.s;
	}

	mgr->set_first(1);
	TNplacements::init();
}

#define ROCK_LAYER
//-------------------------------------------------------------
// TNrocks::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks::eval() {
	if (!isEnabled() || TheScene->viewtype != SURFACE) {
		if (right)
			right->eval();
		return;
	}

	TerrainData rock;
	TerrainData ground;
	int i;
	bool first = (right && right->typeValue() != ID_ROCKS);
	bool last = getParent()->typeValue() != ID_ROCKS;
	INIT;
#ifdef ROCK_LAYER
	S0.set_flag(ROCKLAYER);
#endif
	int in_map = S0.get_flag(CLRTEXS);

	if (CurrentScope->rpass()) {
		INIT;
		if(right) // ground
			right->eval();
		INIT;
#ifdef ROCK_LAYER
		Td.add_id();
		Td.tp->set_rock(true);
		Td.tp->ntexs=0;
		Td.tp->set_rock(true);
		if(!in_map)
			S0.set_flag(CLRTEXS);
		if(base)// rock texs
			base->eval();
		if(!in_map)// in case we were in another map on entry
			S0.clr_flag(CLRTEXS);
#else
		if(base)// rock texs
			base->eval();
#endif
		mgr->setHashcode();
		return;
	}
#ifdef ROCK_LAYER
	if (!in_map && first)
		Td.begin();
#endif
	ground.p.z = 0;

	INIT;
	bool other_rock = false;
	if (right)
		right->eval(); // ground
	other_rock = S0.get_flag(ROCKBODY);
	S0.p.z-=Drop;
	if (first) {
		S0.next_id();
		Td.insert_strata(S0);
	}
	ground.copy(S0);
	INIT;

	RockMgr *rmgr = (RockMgr*) mgr;
	
	mgr->getArgs((TNarg *)left);
	INIT;
	if (base)
		base->eval();
	S0.p.z=ground.p.z;
	rmgr->base = S0.p.z-rmgr->drop*rmgr->maxsize/Hscale;
	INIT;
#ifdef ROCK_LAYER
	S0.next_id();
#endif
	rock.copy(S0);
	INIT;
	rmgr->ht = mgr->base;
	rmgr->eval();  // calls set_terrain sets mgr->ht

	if (rmgr->noise_amp)
		CurrentScope->revaluate();
	rock.p.z = rmgr->ht;
	double delta = (rock.p.z - ground.p.z) / fabs(ground.p.z);
	if (delta > 0) {
		rock.p.x = rmgr->rx * (1 - rmgr->rdist);
		rock.p.y = rmgr->ry * (1 - rmgr->rdist);
		S0.copy(rock);
#ifdef ROCK_LAYER
		Td.tp->set_rock(true);
		S0.set_flag(ROCKBODY);
#endif
	}
	else {
		Td.tp->set_rock(false);
		S0.copy(ground);
#ifdef ROCK_LAYER
		if(!other_rock)
			S0.clr_flag(ROCKBODY);
#endif
	}
#ifdef ROCK_LAYER
	Td.insert_strata(rock);
	if (!in_map && last)
		Td.end();
#endif
}

// called by VtxSceneDialog ->scene->makeObject
// called by Scene->makeObject
// this = prototype obj=parent(layer) m=GN_TYPE
// this->setParent(obj) already set
// VtxSceneDialog ->addtoTree(this)
NodeIF *TNrocks::getInstance(NodeIF *obj, int m){	
	return newInstance(m);
}
bool TNrocks::randomize(){
	double f=0.2;
	TNarg *arg=(TNarg*)left;
	char buff[1024];
	buff[0]=0;
	arg=arg->index(1);
	int i=0;
	while(arg){
		if(arg->left->typeValue()==ID_CONST){
			TNconst *val=(TNconst*)arg->left;
			//cout<<s[i]<<" before:"<<val->value;
			val->value*=(1+f*s[i]);
			//cout<<" after:"<<val->value<<endl;
		}
		else if(arg->left->typeValue()==ID_NOISE){
			TNnoise *val=(TNnoise*)arg->left;
			buff[0]=0;
			val->valueString(buff);
			//cout<<"before:"<<buff<<endl;
			std::string str=TNnoise::randomize(buff,f,1);
			TNnoise *newval=TheScene->parse_node((char*)str.c_str());
			arg->left=newval;
			//cout<<"after:"<<str<<endl;
			delete val;
		}
		i++;
     	arg=arg->next();
	}
	return true;
}

// this=prototype, this->parent=layer
TNrocks *TNrocks::newInstance(int m){
	NodeIF::setRands();
	int gtype=m&GN_TYPES;
	Planetoid *orb=(Planetoid *)getOrbital(this);
	Planetoid::makeLists();
	std::string str=Planetoid::newRocks(orb,gtype);
	TNrocks *rocks=TheScene->parse_node((char*)str.c_str());
	rocks->setParent(parent);
	rocks->randomize();
	return rocks;
}
