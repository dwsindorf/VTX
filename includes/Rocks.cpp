
//************************************************************
// classes Rock, RockMgr
//************************************************************
#include "SceneClass.h"
#include "RenderOptions.h"
#include "Rocks.h"
#include "Util.h"
#include "MapNode.h"
#include "ModelClass.h"
#include "AdaptOptions.h"
#include "TerrainClass.h"
#include "ImageClass.h"
#include "UniverseModel.h"
#include "GLSLMgr.h"
#include "Effects.h"

#include <map>
#include <set>
#include <algorithm>

extern double Hscale,Gscale, Drop, MaxSize,Height,Theta,Phi,Slope,MaxHt;
extern int test7, test8;

extern Point MapPt;
extern double ptable[];

static const char *def_rnoise_expr="noise(GRADIENT,0,2)\n";

static TerrainData Td;

static bool first=true;
static int tid=0;
static int pid=0;
static int nbumps=0;
static bool cvalid;

#define PRINT_STATS
#define PRINT_ROCK_STATS
//#define PRINT_ROCK_CACHE_STATS
//#define PRINT_ACTIVE_TEX
//#define PRINT_LOD_STATS
//#define DEBUG_REGEN


bool use_templates=true;
static bool shadow_start=false;

// 3d rocks using marching cubes
// Tasks:
// 1. generate color test if 3d flag is set - done
// 2. set density gradient on surface if 3d - done
// 3. capture size and position information for placement - done
// 4. create array of 3d rocks with placement and size info - done
// 7. for each layer and rock in layer emit rock as a marchingCubes Object - done
// 8. refactor rock3d and rock classes to use the same wxWidgets GUI
//    - change both to use Point in base [] for modulation rather than argument 
//      note: 2d rocks now always map from surface
//    - in both modify arguments to "standard" as in plants and sprites
//      so all rocks can have biases
//    - add "3d" checkbox to UI
//      in UI change only class name (rock or rock3d) to regenerate
// 9. add noise modulation to 3d rocks using existing methods - done
// 10. support for shadows - done
// 11. improve lighting model (done)
// 12. add color -done 
// 13. add single texture (triplanar) using simple shader - done
// 14. add bump-map
// 15  multi-textures
//
// Notes:
// (1) the terrain stack may have one or more "layers"
//     - each "layer" has a separate Rock3DObjMgr
// (2) each Rock3DObjMgr can have multiple Rock types (PlaceObjs)
//     - typically 1 or 2
// (3) each rock type has a single TNRock, Rock3DMgr and Rock3D instance
//     - TNRock: generated by parsing the scene file (child of terrain stack)
//     - Rock3DMgr: responsible for creating rock instance candidates
//     - Rock3D: used by Rock3DObjMgr to produce final array of 3d rocks (utility class)
// (4) generation sequence
//     - In MapClass(render_objects) 
//       * called for each terrain layer and 3DObjMgr type instance in each layer (Plants, Sprites 3DRocks)
//       * traverses map data and generates array of visible objects (MapNodes) as seed candidates for placements 
//       * for each MapNode: calls MapNode->setSurface() to put 3d vertex(point) etc. into global objects
//       * calls Rock3DObjMgr: eval(): 
//     - Rock3DObjMgr(eval)
//       * for each type(TNrock), calls TNrock->eval() which calls Rock3Dmgr->eval()
//       * Rock3Dmgr populates global hash table with placement candidates
//     - Rock3DObjMgr(collect)
//       * traverses hash table and fills static array PlaceData(data)
//     - Rock3DObjMgr (render)
//       * parses data array and fills vertex buffer with OpenGL data (if need rebuild determined)
//     - Rock3DObjMgr (setProgram)
//       * sets up OpenGl environment for all objects to be rendered
//       * sets shader program
//     - Rock3DObjMgr (render_object)
//       * uploads/ renders data using vertex buffers

//************************************************************
// Rock3D class
//************************************************************
Rock3D::Rock3D(int t, TNode *e):PlaceObj(t,e)
{
	texid=0;
}
PlacementMgr *Rock3D::mgr() { 
	return ((TNrocks3D*)expr)->mgr;
}

bool Rock3D::initProgram(){
	Rock3DMgr* rmgr=(Rock3DMgr*)mgr();
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();
	TNcolor *color=(TNcolor*)rmgr->color;
	if(color && color->isEnabled())
		cvalid=true;
	//for(int i=0;i<rmgr->texs.size;i++){	
	for(int i=rmgr->texs.size-1;i>=0;i--){
		TNtexture *tntex=rmgr->texs[i];
		Texture *texture=tntex->texture;
		if(!tntex->isEnabled())
			continue;
		texture->set3D();

		TerrainProperties::tid=tid;
		if(texture->bump_active && Render.bumps())
			nbumps++;
		texture->tid=tid;
		texture->eval();
		texture->initProgram();
		tid++;
	}
	CurrentScope->set_passmode(mode);
	return true;
}

bool Rock3D::setProgram(){
	Rock3DMgr* rmgr=(Rock3DMgr*)mgr();
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();
		
	for(int i=rmgr->texs.size-1;i>=0;i--){  // reverse needed so 1-d tex is drawn last as in 2d rocks
	//for(int i=0;i<rmgr->texs.size;i++){
		TNtexture *tntex=rmgr->texs[i];
		Texture *texture=tntex->texture;
		if(!tntex->isEnabled())
			continue;
		TerrainProperties::tid=tid;
		texture->eval();
		texture->pid=pid;
		texture->setProgram();
		tid++;
	}
	CurrentScope->set_passmode(mode);
	return true;
}
//************************************************************
// helper functions
//************************************************************

Color rock_color(0.6, 0.5, 0.4);

struct RockLodEntry {
    int    res;     // voxel resolution
    double maxPts;  // upper bound for pts (pts < maxPts)
};

static const RockLodEntry kRockLodTable[MAX_ROCK_STATS] = {
    {  2,  2.0},
    {  4,  10.0},
    {  8,  20.0},
    {  16, 50.0},
    { 32, 100.0},
    { 48, 150.0},
    { 64, 200.0},
    { 128, 400.0},
    { 200,  1e9}  // default 
};

static int getLodIndex(int scaledRes, double resScale) {
    // Reverse the scaling with rounding
    int unscaledRes = (int)(scaledRes / resScale + 0.5);  // Round instead of truncate
    
    // Find closest match in table
    int bestIndex = 0;
    int minDiff = abs(kRockLodTable[0].res - unscaledRes);
    
    for (int i = 1; i < MAX_ROCK_STATS; i++) {
        int diff = abs(kRockLodTable[i].res - unscaledRes);
        if (diff < minDiff) {
            minDiff = diff;
            bestIndex = i;
        }
    }   
    return bestIndex;
}


static Point rotateNormal(const Point& normal, const Point& right, const Point& forward, const Point& up) {
    Point rotated(
        normal.x * right.x + normal.y * forward.x + normal.z * up.x,
        normal.x * right.y + normal.y * forward.y + normal.z * up.y,
        normal.x * right.z + normal.y * forward.z + normal.z * up.z
    );
    double len = rotated.length();
    if (len > 1e-30) {
        return rotated / len;
    }
    return Point(0, 1, 0);  // ADD THIS LINE
}


//************************************************************
// Rock3DMgr class
//************************************************************
int Rock3DMgr::stats[MAX_ROCK_STATS][3];
double Rock3DMgr::resScale=1;

Rock3DMgr::Rock3DMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,MCROCKS);
	comp=0.0;
	drop=0.0;
	vnoise=0;
	rnoise=0;
	color=0;

#ifdef TEST_ROCKS
    set_testColor(true);
#endif
   set_testDensity(true);
   set_useaveht(true);
}

void Rock3DMgr::eval(){	
	PlacementMgr::eval(); 
}

void Rock3DMgr::init()
{
	PlacementMgr::init();
  	reset();
}

//-------------------------------------------------------------
// Rock3DMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *Rock3DMgr::make(Point4DL &p, int n)
{
    return new Placement(*this,p,n);
}
PlaceData *Rock3DMgr::make(Placement*s)
{
    return new Rock3DData(s);
}

void Rock3DMgr::clearStats(){
	cout<<"Rock3DMgr::clearStats"<<endl;
	for(int i=0;i<MAX_ROCK_STATS;i++){
		stats[i][0]=stats[i][1]=0;
	}
}

void Rock3DMgr::printStats(){
    int rcnt = 0;
    int tcnt = 0;
    int kcnt = 0;
    std::cout << "------- 3D Rocks stats --------" << std::endl;
    if(use_templates){
    	int lod_calls=(Rock3DObjMgr::lodCacheHits+Rock3DObjMgr::lodCacheMisses);
    	std::cout << "LOD Cache calls:"<<lod_calls<<" hits:"<<100.0*Rock3DObjMgr::lodCacheHits/lod_calls<<" %"<<endl;
	}
    char buff[256];
    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
#ifdef PRINT_ROCK_STATS
    	sprintf(buff,"resolution:%3d templates:%d instances:%3d triangles:%3d K",
        (int)(kRockLodTable[i].res*resScale+0.1),stats[i][2],stats[i][0],stats[i][1]/1000);
        cout<<buff<< std::endl;
#endif
        rcnt  += stats[i][0];
        tcnt  += stats[i][1];
    }
    std::cout << "Totals rocks:"    << rcnt
              << " triangles:"      << tcnt/1000<<" K"
              << std::endl;
}

void Rock3DMgr::setStats(int res, int tris,bool add){
    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
        if ((int)(kRockLodTable[i].res*resScale) == res) {
        	if(add){
				stats[i][0]++;           // count of rocks at this res
				stats[i][1] += tris;     // total triangles

        	}
        	else{
				stats[i][0]--;           // count of rocks at this res
				stats[i][1] -= tris;     // total triangles
        	}
            return;
        }
    }
}

int Rock3DMgr::getLODResolution(double pntsize) {
	double pts=floor(pntsize);
	int res=kRockLodTable[MAX_ROCK_STATS - 1].res; // fallback
 	for (int i = 0; i < MAX_ROCK_STATS; ++i) {
		if (pts <= kRockLodTable[i].maxPts) {
			res=kRockLodTable[i].res;
			break;
		}
	}

 	double cellsize=TheScene->cellsize;

 	if (cellsize <= 3.5) {// Between best and normal: lerp from 2.0 to 1.0	        
 	   resScale = remap(cellsize, 1, 3.5, 2.0, 1.0);
 	} else {// Between normal and draft: lerp from 1.0 to 0.5 	        
 	   resScale = remap(cellsize, 3.5, 7, 1.0, 0.5);
    }
 	int newres=(int)(res*resScale);
 	newres=newres<2?2:newres;
	return newres;
}
//************************************************************
// Rock3DObjMgr class
//************************************************************
MCObjectManager Rock3DObjMgr::rocks;
ValueList<PlaceData*> Rock3DObjMgr::data(10000, 5000);
std::map<Rock3DObjMgr::RockCacheKey, Rock3DObjMgr::RockCacheEntry> Rock3DObjMgr::rockCache;
int Rock3DObjMgr::cacheHits = 0;
int Rock3DObjMgr::cacheMisses = 0;
int Rock3DObjMgr::cacheRegens = 0;
int Rock3DObjMgr::maxTexs = 0;
int Rock3DObjMgr::lodCacheHits=0;
int Rock3DObjMgr::lodCacheMisses=0;
int Rock3DObjMgr::templates_per_lod=3;
std::map<int, MCObject*> Rock3DObjMgr::lodTemplates;
Rock3DObjMgr::~Rock3DObjMgr(){
	//cout<<"Rock3DObjMgr::~Rock3DObjMgr()"<<endl;
	//freeLODTemplates();
}

void Rock3DObjMgr::freeLODTemplates() {
	cout<<"Rock3DObjMgr::freeLODTemplates()"<<endl;
    for (auto& pair : lodTemplates) {
        delete pair.second;
    }
    lodTemplates.clear();
    for(int i=0;i<MAX_ROCK_STATS;i++){
    	Rock3DMgr::stats[i][2]=0;
    }
}

double calculateNightLighting(double tod) {
    const double dawnStart = 0.20, dawnEnd = 0.3;
    const double duskStart = 0.7, duskEnd = 0.85;   
    // Night (before dawn or after dusk)
    if (tod < dawnStart || tod > duskEnd) 
        return 0.0;  
    // Full day (between dawn and dusk)
    if (tod >= dawnEnd && tod <= duskStart) 
        return 1.0;    
    // Dawn transition (smoothstep from 0 to 1)
    if (tod < dawnEnd) 
        return smoothstep(dawnStart, dawnEnd, tod);   
    // Dusk transition (smoothstep from 1 to 0)
    return 1.0 - smoothstep(duskStart, duskEnd, tod);
}
//-------------------------------------------------------------
// Rock3DObjMgr::setProgram() initialize shader
//-------------------------------------------------------------
bool Rock3DObjMgr::setProgram() {
    if (!data.size || !objs.size)
        return false;   
 
	if(PlaceObjMgr::shadow_mode)
		return false;
		
    char defs[1024] = "";
    sprintf(defs+strlen(defs), "#define NLIGHTS %d\n", Lights.size);

    bool do_shadows=Raster.shadows();
 	if(do_shadows && !TheScene->light_view()&& !TheScene->test_view())
 		sprintf(defs+strlen(defs),"#define SHADOWS\n");

    GLSLMgr::setDefString(defs);
    maxTexs=0;
    if(Render.textures()){
    	tid=0;
    	nbumps=0;
    	cvalid=false;
    	Texture::reset();
		for(int i=0;i<objs.size;i++){
			objs[i]->initProgram();
		}
		maxTexs=tid;
    }
    if(cvalid)
    	sprintf(defs,"#define COLOR \n#define NTEXS %d\n#define NBUMPS %d\n",maxTexs,nbumps);
    else
		sprintf(defs,"#define NTEXS %d\n#define NBUMPS %d\n",tid,nbumps);

	strcat(GLSLMgr::defString,defs);
    GLSLMgr::loadProgram("rocks3d_tex.vert", "rocks3d_tex.frag");
	tid=0;
	pid=0;
	for(int i=0;i<objs.size;i++){
		objs[i]->setProgram();
		pid++;
	}
   GLhandleARB program = GLSLMgr::programHandle();
    if (!program)
        return false;
     GLSLVarMgr vars;

    Planetoid *orb = (Planetoid*)TheScene->viewobj;
    Color diffuse = orb->diffuse;
    Color ambient = orb->ambient;
	Color shadow=orb->shadow_color;
	Color haze=Raster.haze_color;
	
	double tod=orb->tod;
	
	double night_lighting=1;
	if(!TheScene->changed_file())
		night_lighting=calculateNightLighting(tod);
     
    vars.newFloatVec("Diffuse", diffuse.red(), diffuse.green(), diffuse.blue(), diffuse.alpha());
    vars.newFloatVec("Ambient", ambient.red(), ambient.green(), ambient.blue(), ambient.alpha());
	vars.newFloatVec("Shadow",shadow.red(),shadow.green(),shadow.blue(),orb->shadow_intensity);
	vars.newFloatVec("Haze",haze.red(),haze.green(),haze.blue(),haze.alpha());
	
	vars.newFloatVar("night_lighting",night_lighting);
	vars.newBoolVar("lighting",Render.lighting());
	vars.newIntVar("activeTexture",0);

    vars.setProgram(program);
    vars.loadVars();

    GLSLMgr::setProgram();
    GLSLMgr::loadVars();
    
    return true;
}
void Rock3DObjMgr::free() { 
	data.free();
}

//-------------------------------------------------------------
// Rock3DObjMgr::collect() generate array of placements (data)
//-------------------------------------------------------------
void Rock3DObjMgr::collect() {
    data.free();
    for (int i = 0; i < objs.size; i++) {
        PlaceObj *obj = objs[i];
        obj->mgr()->collect(data);
    }
    if (data.size) // now sorted by instance instead of distance
        data.sort();
//    for(int i=0;i<data.size;i++)
//    	cout<<data[i]->instance;
}

void Rock3DObjMgr::render_zvals(){

	if(objs.size==0)
		return;
	//cout<<"Rock3DObjMgr::render_zvals() view:"<<Raster.shadow_vcnt<<":"<<Raster.shadow_vsteps<<endl;
	if(Raster.shadow_vcnt==0)
		shadow_start=true;
	shadow_mode=true;
	render();
    shadow_start=false;

	shadow_mode=false;
}

void Rock3DObjMgr::render_shadows(){
	if(objs.size==0)
		return;
	shadow_mode=true;
    
	// not really needed - these are the defaults for shadow mode
	Raster.setShadowProgram("shadows.vert",0,0);
	Raster.setProgram(Raster.PLACE_SHADOWS);
	render();
//	if(Raster.shadow_vcnt==Raster.shadow_vsteps-1)
	shadow_mode=false;
}
// Post-mesh vertex displacement and color: uses standard noise function
void Rock3DObjMgr::applyVertexAttributes(MCObject* rock, double amplitude, TNode *tv, TNode *tc) {
    
    Point center = rock->worldPosition;
    double rockSize = rock->baseSize;
        
    for (auto& tri : rock->mesh) {
        for (int v = 0; v < 3; v++) {
            Point &vertex = tri.vertices[v];
            Color &color =tri.colors[v];
            
            // Direction from center to vertex (outward normal)
            Point dir = (vertex - center).normalize();
            
            // Normalize position relative to rock center and size
            // This gives us unit-scale coordinates for noise sampling
            double nx = (vertex.x - center.x) / rockSize;
            double ny = (vertex.y - center.y) / rockSize;
            double nz = (vertex.z - center.z) / rockSize;
			Point np(nx,ny,nz);
			TheNoise.set(np);
			Point pn;
			double rz=0;
			Point pv=vertex;
			if(tv && tv->isEnabled()){  // vertex displacement
				SINIT;
				tv->eval();	
				if(S0.pvalid()){
					Point pd=S0.p;
					Point delta=dir*pd*amplitude;
					vertex=vertex-delta;
				}
			}
			color=rock_color;
			if(tc && tc->isEnabled()){ // color calculation
				SINIT;
				tc->eval();	
				if(S0.cvalid())
					color=S0.c;
			}
        }
    }
}

MCObject* Rock3DObjMgr::getTemplateForLOD(Rock3DData *s) {
    Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
    TNode *tr = pmgr->rnoise;
    TNode *tv = pmgr->vnoise;
    TNode *tc = pmgr->color;
    
    char tmp[1024];
    tmp[0] = 0;
    if (tr) tr->valueString(tmp);
    if (tv) tv->valueString(tmp);
    if (tc) tc->valueString(tmp);
    std::string estr = tmp;
    
    double isoNoiseAmpl = pmgr->noise_amp;
    bool useNoisyIsoSurface = isoNoiseAmpl > 0;
    bool useVertexDisplacement = (tv != nullptr && tv->isEnabled() && useNoisyIsoSurface);
    bool setVertexColor = (tc != nullptr && tc->isEnabled());
    double vertexNoiseAmpl = useVertexDisplacement ? 0.5 * pmgr->noise_amp : 0;
    
    double pts = floor(s->pts);
    int rval = s->rval;
    int instance = s->instance;
    int resolution = Rock3DMgr::getLODResolution(pts);
    
    // Create cache key including smoothing state
    bool smooth = Render.avenorms() && !test8;
    
    // Build key: resolution + seed + expression + instance + smooth
    int k1 = resolution * 100;
    int k2 = (int)(rval)% Map::tessLevel();
    int k3 = instance * 1000;
    //int k4 = smooth ? 10000 : 0;  // Include smoothing in key
    int key = k1 + k2 +k3;   
	auto it = Rock3DObjMgr::lodTemplates.find(key);
	if (it != Rock3DObjMgr::lodTemplates.end()) {
		Rock3DObjMgr::lodCacheHits++;
		return it->second;
	}
    // Template not in cache - generate it fully processed
    MCObject* templateSphere = new MCObject(Point(0, 0, 0), 1.0);
    
    // Generate base marching cubes mesh
    double comp = pmgr->comp;
    double comp_factor = std::max((1.0 - 2*comp), 0.2);
    Point center(0, 0, 0);  // Template centered at origin
    
    SurfaceFunction field = [&](double x, double y, double z) -> double {
		if (!useNoisyIsoSurface) {
			// Simple ellipsoid
			double ex = 2*x;
			double ey = 2*y;
			double ez = 2*(z/comp_factor);
			double ellipsoidDist = sqrt(ex*ex + ey*ey + ez*ez);
			return ellipsoidDist - 1.0;  // Inside-positive
		}
		
		// Noisy ellipsoid
		double ex = 2*x;
		double ey = 2*y;
		double ez = 2*(z/comp_factor);
		double ellipsoidDist = sqrt(ex*ex + ey*ey + ez*ez);
		double baseEllipsoid = ellipsoidDist - 1.0;
		
		if (tr && tr->isEnabled()) {
			Point np(x, y, z);
			TheNoise.set(np);
			SINIT;
			tr->eval();
			if (S0.s) {
				baseEllipsoid += S0.s * isoNoiseAmpl;  // SUBTRACT noise
			}
		}
		
		return baseEllipsoid;
    };
    
    MCGenerator generator;
    double margin = 1 + 3*isoNoiseAmpl;  // Increase margin with noise amplitude
    Point boundsMin(-0.5 * margin, -0.5 * margin, -0.5 * margin);
    Point boundsMax(0.5 * margin, 0.5 * margin, 0.5 * margin);    
    
    templateSphere->mesh = generator.generateMesh(
        field, boundsMin, boundsMax,
        resolution, 0.0  // CORRECT - single resolution
    );
    
    if (templateSphere->mesh.empty()) {
        delete templateSphere;
        return nullptr;
    }
    
    // Apply vertex displacement in template space
    if (useVertexDisplacement || setVertexColor) {
    	int rseed = TheNoise.rseed;
    	TheNoise.rseed = rval;  // Set the seed!
        applyVertexAttributes(templateSphere, vertexNoiseAmpl, tv, tc);
        TheNoise.rseed = rseed;  // Restore
    }
    
    // Calculate normals in template space
    for (auto& tri : templateSphere->mesh) {
        Point edge1 = tri.vertices[1] - tri.vertices[0];
        Point edge2 = tri.vertices[2] - tri.vertices[0];
        Point normal = edge2.cross(edge1);
        
        if (normal.length() > 1e-30) {
            // DON'T negate - winding order change already flipped it!
            tri.normal = normal.normalize();  // NO negation
        } else {
            tri.normal = Point(0, 1, 0);  // NO negation
        }
        
        // Face normal for texture mapping
        Point edge3 = tri.templatePos[1] - tri.templatePos[0];
        Point edge4 = tri.templatePos[2] - tri.templatePos[0];
        Point faceNormal = edge4.cross(edge3);
        
        if (faceNormal.length() > 1e-30) {
            tri.faceNormal = faceNormal.normalize();
        } else {
            tri.faceNormal = Point(0, 1, 0);
        }
    }
    
    // Apply smoothing if enabled
    if (smooth) {
        templateSphere->generateSmoothNormals();
    }
    
    // Store in cache
    lodTemplates[key] = templateSphere;
    Rock3DObjMgr::lodCacheMisses++;
#ifdef PRINT_LOD_STATS     
    std::cout << "Created LOD template: resolution:" << resolution 
              << " instance:" << instance 
              << " Triangles:" << templateSphere->mesh.size() << std::endl;
#endif 
    int index = getLodIndex(resolution, Rock3DMgr::resScale);
   
    if (index >= 0)
    	 Rock3DMgr::stats[index][2]++;
 
    return templateSphere;
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render() {
    int n = data.size;
    if (n == 0)
        return;
    
    bool wireframe = test7;
    
    bool moved = TheScene->moved();
    bool changed = TheScene->changed_detail();
      
    if (PlaceObjMgr::shadow_mode && !shadow_start) {
        moved = false;
        changed = false;
    }
    
    bool placement_needs_update = moved;
    bool mesh_needs_rebuild = changed;
    double t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, d0 = 0, d1 = 0, d2 = 0;
    
    if (mesh_needs_rebuild) {
        std::cout << "Settings changed - invalidating" << endl;
        rockCache.clear();
        rocks.clear();
        freeLODTemplates();
        Rock3DMgr::clearStats();
    }    	
      
    if (placement_needs_update || mesh_needs_rebuild) {
        d0 = clock();
        
        rocks.clear();  // Clear old rocks
        
        if (!mesh_needs_rebuild)
            Rock3DMgr::clearStats();
        
        Point xpoint = TheScene->xpoint;
        
        int hits = 0, misses = 0;

        for (int i = 0; i < n; i++) {
            Rock3DData *s = data[i];
            
            Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
            
            Point eyePos = s->vertex - xpoint;
            double size = 4 * Hscale * s->radius;
            double pts = floor(s->pts);
            double dist = s->dist;
            int rval = s->rval;
            double comp = pmgr->comp;
            double drop = pmgr->drop;
            int instance = s->instance;
            
            int resolution = Rock3DMgr::getLODResolution(pts);
            
            // Get fully-processed template (includes displacement, color, normals, smoothing)
            d1 = clock();
            int rseed = TheNoise.rseed;
            TheNoise.rseed = rval;
            
            MCObject* templateSphere = getTemplateForLOD(s);
            
            TheNoise.rseed = rseed;
            
            if (!templateSphere || templateSphere->mesh.empty()) {
                continue;
            }
            
            d2 = clock();
            t2 += d2 - d1;  // Template retrieval time (should be ~0 after first frame)
            
            // Create rock and transform template to world/eye space
            MCObject* rock = rocks.addObject(eyePos, size);
            
            if (rock) {
                d1 = clock();
                rock->setDistanceInfo(dist, pts);
                rock->mesh.clear();
                rock->instanceId = instance;
                rock->dataIndex = i;
                
                // Get world position and surface normal
                Point worldPos = s->vertex;
                Point up = s->normal;
                
                double dscale = Hscale * drop * (1 - 0.5 * comp) * 0.5;
                Point rockCenter = worldPos - up * (s->radius * dscale);
                
                // Create rotation basis vectors
                Point right, forward;
                if (fabs(up.z) < 0.9)
                    right = Point(up.y, -up.x, 0).normalize();
                else
                    right = Point(0, up.z, -up.y).normalize();
                
                forward = Point(up.y * right.z - up.z * right.y,
                                up.z * right.x - up.x * right.z,
                                up.x * right.y - up.y * right.x);
                
                // Transform fully-processed template mesh to world/eye space
                for (const auto& tri : templateSphere->mesh) {
                    MCTriangle newTri;
                    
                    for (int v = 0; v < 3; v++) {
                        Point tv = tri.vertices[v];
                        
                        // Apply rotation matrix (scale is included in 'size' below)
                        Point rotated = Point(
                            tv.x * right.x + tv.y * forward.x + tv.z * up.x,
                            tv.x * right.y + tv.y * forward.y + tv.z * up.y,
                            tv.x * right.z + tv.y * forward.z + tv.z * up.z);
                        
                        // Scale, translate to world position, convert to eye space
                        Point worldVertex = rockCenter + rotated * size;
                        newTri.vertices[v] = worldVertex - xpoint;
                        
                        // Copy pre-processed attributes from template
                        newTri.colors[v] = tri.colors[v];
                        newTri.templatePos[v] = tri.templatePos[v];
                    }
                    
                    // Rotate the pre-calculated normals
                    newTri.normal = rotateNormal(tri.normal, right, forward, up);
                    newTri.faceNormal = tri.faceNormal;
                    
                    rock->mesh.push_back(newTri);
                }
                
                rock->meshValid = true;
                
                t5 += clock() - d1;  // Mesh transformation time
                d1 = clock();
                
                // Simple VBO upload (no smoothing - already in template)
                rock->uploadToVBO();
                
                t4 += clock() - d1;  // VBO upload time
                
                Rock3DMgr::setStats(resolution, rock->mesh.size(), true);
            }
        }
        
        std::cout << "Processed " << n << " rocks" << std::endl;
        Rock3DMgr::printStats();
        
        double total = (clock() - d0) * TS;
        cout << "t1:" << t1*TS << " t2:" << t2*TS << " t3:" << t3*TS 
             << " t4:" << t4*TS << " t5:" << t5*TS << " total:" << total << endl;
    }
    
    render_objects();
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render_objects() {
    bool wireframe = test7;

    static std::set<int> lastFrameRocks;
    std::set<int> thisFrameRocks;

    int currentRockType = -1;
    int rockIndex = 0;
    int drawnCount = 0;

    if(!PlaceObjMgr::shadow_mode){
    	if (!setProgram()) {
    	  cout << "Rock3DObjMgr::setProgram FAILED" << endl;
    	  return;
    	}
    }
    if (wireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	else
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    const std::vector<MCObject*>& rockList = rocks.getObjects();
    int validCount = 0, invalidVboCount = 0, emptyMeshCount = 0;

	GLhandleARB program = GLSLMgr::programHandle();
	
	for (MCObject *rock : rockList) {
		if (!rock->vboValid) {
		        invalidVboCount++;
		        continue;
		    }
		    if (rock->mesh.size() == 0) {
		        emptyMeshCount++;
		        continue;
		    }
		    validCount++;
		if (rock->vboValid && rock->mesh.size() > 0) {
			thisFrameRocks.insert(rockIndex);
			PlaceData* placeData = data[rockIndex];
			//int rockType = placeData->instance;  // 0, 1, 2, etc.
			int rockType = rock->instanceId;
			
			int mgrInstance = placeData->mgr->instance;

			for (int i = 0; i < maxTexs; i++) { // set active status for all textures
				char str[64];
				sprintf(str, "tex2d[%d].active", i);
				GLint loc = glGetUniformLocationARB(program, str);
				if (loc >= 0) {
					glUniform1iARB(loc, rockType);
				}
			}
			// show when active texture changes
#ifdef PRINT_ACTIVE_TEX
			if (rockType != currentRockType) {				
				std::cout << "Switching active rock instance " << currentRockType <<"->"<<rockType<<std::endl;				
				currentRockType = rockType;
			}
#endif             
			glBindBuffer(GL_ARRAY_BUFFER, rock->vboVertices);
			glVertexPointer(3, GL_FLOAT, 0, 0);
			glEnableClientState(GL_VERTEX_ARRAY);

			glBindBuffer(GL_ARRAY_BUFFER, rock->vboNormals);
			glNormalPointer(GL_FLOAT, 0, 0);
			glEnableClientState(GL_NORMAL_ARRAY);
			
            glBindBuffer(GL_ARRAY_BUFFER, rock->vboColors);
            glColorPointer(3, GL_FLOAT, 0, 0);
            glEnableClientState(GL_COLOR_ARRAY);

			GLint attribLoc1 = glGetAttribLocation(program, "templatePosition");
			if (attribLoc1 >= 0) {
				glBindBuffer(GL_ARRAY_BUFFER, rock->vboTemplatePos);
				glVertexAttribPointer(attribLoc1, 3, GL_FLOAT, GL_FALSE, 0, 0);
				glEnableVertexAttribArray(attribLoc1);
			}
			GLint attribLoc2 = glGetAttribLocation(program, "faceNormal");
			if (attribLoc2 >= 0) {
				glBindBuffer(GL_ARRAY_BUFFER, rock->vboFaceNormals);
				glVertexAttribPointer(attribLoc2, 3, GL_FLOAT, GL_FALSE, 0, 0);
				glEnableVertexAttribArray(attribLoc2);
			}
			glDrawArrays(GL_TRIANGLES, 0, rock->mesh.size() * 3);
			
			// Disable template position attribute
			if (attribLoc1 >= 0) 
			    glDisableVertexAttribArray(attribLoc1);
			if (attribLoc2 >= 0) 
			    glDisableVertexAttribArray(attribLoc2);
			glDisableClientState(GL_VERTEX_ARRAY);
			glDisableClientState(GL_NORMAL_ARRAY);
			glDisableClientState(GL_COLOR_ARRAY);
			rockIndex++;

		}
	}
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}
//************************************************************
// TNrocks3D class
//************************************************************
TNrocks3D::TNrocks3D(int t,TNode *l, TNode *r, TNode *b) : TNrocks(t|MCROCKS,l,r,b)
{
	delete mgr;
	mgr=new Rock3DMgr(type);
	rock=0;
}

static Rock3DMgr *rm;
static void collectTexs(NodeIF *obj){
	int type=obj->typeValue();
	if(type==ID_TEXTURE){
		TNtexture *tex=(TNtexture *)obj;
		if(tex->texture)
			tex->texture->tid=tid;
		rm->texs.add(tex);
	}
}

//-------------------------------------------------------------
// TNrocks3D::init() initialize the node
//-------------------------------------------------------------
void TNrocks3D::init()
{
	Rock3DMgr *rmgr=(Rock3DMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);
	rmgr->rnoise=0;
	TNode *tv=findChild(ID_POINT);
	if(tv)
		rmgr->vnoise=tv;
	else
		rmgr->vnoise=0;
	if(args[6]){
		args[6]->eval();
		rmgr->noise_amp=S0.s;
		rmgr->pts_scale=1+2*rmgr->noise_amp;
		//cout <<rmgr->pts_scale<<endl;
	}
	if(args[7]){
		if(args[7]->typeValue()==ID_POINT)
			rmgr->vnoise=args[7];
		else
			rmgr->rnoise=args[7];
	}
	TNode *tc=findChild(ID_COLOR);
	if(tc)
		rmgr->color=tc;
	else
		rmgr->color=0;
	rmgr->texs.reset();
	rm=rmgr;
	tid=0;
	if(base){
		base->visitNode(collectTexs);
		//rmgr->texs.sort();
	}
	mgr->set_first(1);
	if(rock==0)
		rock=new Rock3D(type,this);	
}

//-------------------------------------------------------------
// TNrocks3D::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks3D::eval()
{
	TerrainData ground;
	static int cnt=0;
	
	if(!isEnabled() || TheScene->viewtype !=SURFACE){
		if(right)
			right->eval();
		return;
	}
	SINIT;
	if(CurrentScope->rpass()){
		int layer=inLayer()?Td.tp->type():0; // layer id
		int instance=Td.tp->Rocks.objects();
		mgr->instance=instance;
		mgr->layer=layer;
		if(rock){
			rock->set_id(instance);
			rock->layer=layer;
		}
		Td.tp->Rocks.addObject(rock);
		mgr->setHashcode();
		if(right)
			right->eval();
		return;
	}
	if(right)
		right->eval();
	
	if(!CurrentScope->spass()){
		ground.copy(S0);
	}
	INIT;

	mgr->type=type;

	mgr->getArgs((TNarg *)left);
	
	MaxSize=mgr->maxsize;
	
	double density=mgr->density;

	if(density>0)
		mgr->eval();  // calls PlantPoint.set_terrain (need MapPt)
	S0.copy(ground); // restore S0.p.z etc
	S0.clr_flag(ROCKBODY);
	if(!CurrentScope->spass()){ // adapt pass only
		if(mgr->setTests())
			S0.set_flag(ROCKBODY);
	}
}

//------------------- 2D Rocks ------------------------------

//************************************************************
// Rock class
//************************************************************
Rock::Rock(PlacementMgr&m, Point4DL&p,int n) : Placement(m,p,n)
{
}
//-------------------------------------------------------------
// Rock::set_terrain()	impact terrain 
//-------------------------------------------------------------
bool Rock::set_terrain(PlacementMgr &pmgr)
{
	double r,z,rm=0;
	RockMgr &mgr=(RockMgr&)pmgr;
	
	mgr.pdist=1;
	if(radius==0)
		return false;
	
	double d=pmgr.mpt.distance(center);
	
	double thresh=mgr.noise_amp;
	double td=mgr.drop*mgr.maxsize;
	double t=1.75*radius;

	r=radius;

	if(d>t)
		return false;

	if(pmgr.testColor())
		Placement::set_terrain(pmgr);
	
	mgr.pdist=d/radius;
	mgr.pdist=clamp(mgr.pdist,0,1);

 	if(mgr.noise_amp>0){
 		double nf=mgr.noise_amp*radius/Hscale;
 		SPUSH;
		Point4D np;
		if(mgr.offset_valid())
		    np=(mgr.mpt-mgr.offset)*(1/radius);
		else
		    np=(mgr.mpt)*(1/radius);
 		np=np+1/radius;
 		if(TheNoise.noise3D())
 		    np.w=0;
 		TheNoise.push(np);
 		CurrentScope->revaluate();
 		double z=0;
 		if(mgr.vnoise){
 			mgr.vnoise->eval();
 		//if(mgr.rnoise->typeValue()==ID_POINT){
 			z=S0.p.z;
 			mgr.rx=nf*S0.p.x;
 			mgr.ry=nf*S0.p.y; 	
  		}
 		if(mgr.rnoise){
 			mgr.rnoise->eval();
 			z+=S0.s;
 		}
 		TheNoise.pop();
 		rm=0.25*z*mgr.noise_amp*radius;
 		SPOP;
		d+=rm;
		r-=rm;
 	}
	mgr.rdist=d/r;
	
	d=clamp(d,0,1);
	
	z=mgr.base;
	
	S0.set_flag(ROCKBODY);

	setActive(true);

    z-=0.5*mgr.comp*r/Hscale;
	if(r>d)
		z+=(1-mgr.comp)*sqrt(r*r-d*d)/Hscale;
    if(z>mgr.ht)
        mgr.ht=z;
    return true;
}

//************************************************************
// RockMgr class
//************************************************************
//	arg[0]  levels   		scale levels
//	arg[1]  maxsize			size of largest craters
//	arg[2]  mult			size multiplier per level
//	arg[3]  density			density or dexpr
//
//	arg[4]  zcomp			z compression factor
//	arg[5]  drop			z drop factor or function
//	arg[6]  noise		    noise amplitude
//	arg[7]  noise_expr		noise function
//-------------------------------------------------------------
TNode *RockMgr::default_noise=0;
RockMgr::RockMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,ROCKS);
	noise_amp=1;
	comp=0.1;
	drop=0.1;
	rnoise=0;
	vnoise=0;
	rdist=0;
	pdist=1;
	rx=ry=0;
#ifdef TEST_ROCKS
    set_testColor(true);
#endif

}
RockMgr::~RockMgr()
{
  	if(finalizer()){
#ifdef DEBUG_PMEM
  		printf("RockMgr::free()\n");
#endif
        DFREE(default_noise);
	}
}

//-------------------------------------------------------------
// RockMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *RockMgr::make(Point4DL &p, int n)
{
    return new Rock(*this,p,n);
}

//-------------------------------------------------------------
// RockMgr::init()	initialize global objects
//-------------------------------------------------------------
void RockMgr::init()
{
	if(default_noise==0){
#ifdef DEBUG_PMEM
  		printf("RockMgr::init()\n");
#endif
	   default_noise=(TNode*)TheScene->parse_node((char*)def_rnoise_expr);
	}
	PlacementMgr::init();
}

//************************************************************
// TNrocks class
//************************************************************
TNrocks::TNrocks(int t, TNode *l, TNode *r, TNode *b) : TNplacements(t|ROCKS,l,r,b)
{
    mgr=new RockMgr(type);
	TNarg &args=*((TNarg *)left);
	TNode *arg=args[8];
	if(arg && (arg->typeValue() != ID_CONST))
		mgr->dexpr=arg;
	set_collapsed();
}

//-------------------------------------------------------------
// TNrocks::applyExpr() apply expr value
//-------------------------------------------------------------
void TNrocks::applyExpr()
{
	if(!expr)
		return;
 	TNrocks* rocks=(TNrocks*)expr;
 	if(rocks->typeValue()!=typeValue()){
    	NodeIF *p=getParent();
  		rocks->base=base;
 		if(base)
 			base->setParent(rocks);
 		rocks->setParent(p);
		rocks->right=right;
 		if(right)
 			right->setParent(rocks);
  		p->replaceChild(this,rocks);
		rocks->init();
 		right=0;
 		base=0;
 		expr=0;
 		DFREE(left);
 	}
	else{ // args changed only
		DFREE(left);
		left=rocks->left;
		left->setParent(this);
		rocks->init();
		delete mgr;
		type=rocks->type;
		mgr=rocks->mgr;
		rocks->left=0;
		rocks->mgr=0;
		rocks->base=0;
		eval();
		delete rocks;
		expr=0;
	}
 }

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceChild(NodeIF *c,NodeIF *n)
{
	return TNbase::replaceChild(c,n);
}

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceNode(NodeIF *c)
{
	((TNrocks*)c)->right=right;
	((TNrocks*)c)->parent=parent;
	parent->replaceChild(this,c);
	delete base;
	base=0;
	TheScene->rebuild_all();
	return c;
}

//-------------------------------------------------------------
// TNrocks::addAfter append x after base if c==this
// - used when adding a TNnode object to a TerrainMgr stack
// - always want to append other objects after Rocks in tree
//-------------------------------------------------------------
NodeIF *TNrocks::addAfter(NodeIF *c,NodeIF *x){
	if(c==this){
		TNode *node=(TNode*)x;
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else if(c)
		c->addChild(x);
	else
		addChild(x);
	return x;
}
//-------------------------------------------------------------
// TNrocks::addChild
//-------------------------------------------------------------
NodeIF *TNrocks::addChild(NodeIF *x){
	TNode *node=(TNode*)x;
	//cout<<"rocks::addChild "<<x->typeName()<<end;
	if(collapsed() && base){
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else{
		if(base){
			node=new TNadd(node,base);
			node->setParent(this);
			base=node;
		}
		else{
			base=node;
			base->setParent(this);
		}
	}
	return x;
}

//-------------------------------------------------------------
// TNrocks::init() initialize the node
//-------------------------------------------------------------
void TNrocks::init()
{
	RockMgr *rmgr=(RockMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);
	
	TNode *tv=findChild(ID_POINT);
	if(tv)
		rmgr->vnoise=tv;
	
	if(args[7]){
		if(!tv && args[7]->typeValue()==ID_POINT)
			rmgr->vnoise=args[7];
		else	
			rmgr->rnoise=args[7];			
	}
	rmgr->noise_amp=1;
	if(args[6]){
		TNarg *tamp=args[6];
		tamp->eval();
		rmgr->noise_amp=S0.s;
	}

	mgr->set_first(1);
	TNplacements::init();
}

#define ROCK_LAYER
//-------------------------------------------------------------
// TNrocks::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks::eval() {
	if (!isEnabled() || TheScene->viewtype != SURFACE) {
		if (right)
			right->eval();
		return;
	}

	TerrainData rock;
	TerrainData ground;
	int i;
	bool first = (right && right->typeValue() != ID_ROCKS);
	bool last = getParent()->typeValue() != ID_ROCKS;
	INIT;
#ifdef ROCK_LAYER
	S0.set_flag(ROCKLAYER);
#endif
	int in_map = S0.get_flag(CLRTEXS);

	if (CurrentScope->rpass()) {
		INIT;
		if(right) // ground
			right->eval();
		INIT;
#ifdef ROCK_LAYER
		Td.add_id();
		Td.tp->set_rock(true);
		Td.tp->ntexs=0;
		Td.tp->set_rock(true);
		if(!in_map)
			S0.set_flag(CLRTEXS);
		if(base)// rock texs
			base->eval();
		if(!in_map)// in case we were in another map on entry
			S0.clr_flag(CLRTEXS);
#else
		if(base)// rock texs
			base->eval();
#endif
		mgr->setHashcode();
		return;
	}
#ifdef ROCK_LAYER
	if (!in_map && first)
		Td.begin();
#endif
	ground.p.z = 0;

	INIT;
	bool other_rock = false;
	if (right)
		right->eval(); // ground
	other_rock = S0.get_flag(ROCKBODY);
	S0.p.z-=Drop;
	if (first) {
		S0.next_id();
		Td.insert_strata(S0);
	}
	ground.copy(S0);
	INIT;

	RockMgr *rmgr = (RockMgr*) mgr;
	
	mgr->getArgs((TNarg *)left);
	INIT;
	if (base)
		base->eval();
	S0.p.z=ground.p.z;
	rmgr->base = S0.p.z-rmgr->drop*rmgr->maxsize/Hscale;
	INIT;
#ifdef ROCK_LAYER
	S0.next_id();
#endif
	rock.copy(S0);
	INIT;
	rmgr->ht = mgr->base;
	rmgr->eval();  // calls set_terrain sets mgr->ht

	if (rmgr->noise_amp)
		CurrentScope->revaluate();
	rock.p.z = rmgr->ht;
	double delta = (rock.p.z - ground.p.z) / fabs(ground.p.z);
	if (delta > 0) {
		rock.p.x = rmgr->rx * (1 - rmgr->rdist);
		rock.p.y = rmgr->ry * (1 - rmgr->rdist);
		S0.copy(rock);
#ifdef ROCK_LAYER
		Td.tp->set_rock(true);
		S0.set_flag(ROCKBODY);
#endif
	}
	else {
		Td.tp->set_rock(false);
		S0.copy(ground);
#ifdef ROCK_LAYER
		if(!other_rock)
			S0.clr_flag(ROCKBODY);
#endif
	}
#ifdef ROCK_LAYER
	Td.insert_strata(rock);
	if (!in_map && last)
		Td.end();
#endif
}

// called by VtxSceneDialog ->scene->makeObject
// called by Scene->makeObject
// this = prototype obj=parent(layer) m=GN_TYPE
// this->setParent(obj) already set
// VtxSceneDialog ->addtoTree(this)
NodeIF *TNrocks::getInstance(NodeIF *obj, int m){	
	return newInstance(m);
}
bool TNrocks::randomize(){
	double f=0.2;
	TNarg *arg=(TNarg*)left;
	char buff[1024];
	buff[0]=0;
	arg=arg->index(1);
	int i=0;
	while(arg){
		if(arg->left->typeValue()==ID_CONST){
			TNconst *val=(TNconst*)arg->left;
			//cout<<s[i]<<" before:"<<val->value;
			val->value*=(1+f*s[i]);
			//cout<<" after:"<<val->value<<endl;
		}
		else if(arg->left->typeValue()==ID_NOISE){
			TNnoise *val=(TNnoise*)arg->left;
			buff[0]=0;
			val->valueString(buff);
			//cout<<"before:"<<buff<<endl;
			std::string str=TNnoise::randomize(buff,f,1);
			TNnoise *newval=TheScene->parse_node((char*)str.c_str());
			arg->left=newval;
			//cout<<"after:"<<str<<endl;
			delete val;
		}
		i++;
     	arg=arg->next();
	}
	return true;
}

// this=prototype, this->parent=layer
TNrocks *TNrocks::newInstance(int m){
	NodeIF::setRands();
	int gtype=m&GN_TYPES;
	Planetoid *orb=(Planetoid *)getOrbital(this);
	Planetoid::makeLists();
	std::string str=Planetoid::newRocks(orb,gtype);
	TNrocks *rocks=TheScene->parse_node((char*)str.c_str());
	rocks->setParent(parent);
	rocks->randomize();
	return rocks;
}
