
//************************************************************
// classes Rock, RockMgr
//************************************************************
#include "SceneClass.h"
#include "RenderOptions.h"
#include "Rocks.h"
#include "Util.h"
#include "MapNode.h"
#include "ModelClass.h"
#include "AdaptOptions.h"
#include "TerrainClass.h"
#include "ImageClass.h"
#include "UniverseModel.h"
#include "GLSLMgr.h"
#include "Effects.h"

#include <map>
#include <set>

extern double Hscale, Drop, MaxSize,Height,Theta,Phi,Slope,MaxHt;
extern int test7, test8;

extern Point MapPt;
extern double ptable[];

static const char *def_rnoise_expr="noise(GRADIENT,0,2)\n";

static TerrainData Td;

#define PSCALE 0.006 // placement scale factor

static bool first=true;
static int tid=0;
static int nbumps=0;

//#define PERLIN_NOISE // use built in noise functions

//#define PRINT_STATS
//#define PRINT_LOD_STATS
//#define PRINT_ROCK_STATS
//#define PRINT_CACHE_STATS
//#define PRINT_ROCK_CACHE_STATS

#define TEST_TEXTURES

static bool shadow_start=false;

// 3d rocks using marching cubes
// Tasks:
// 1. generate color test if 3d flag is set - done
// 2. set density gradient on surface if 3d - done
// 3. capture size and position information for placement - done
// 4. create array of 3d rocks with placement and size info - done
// 7. for each layer and rock in layer emit rock as a marchingCubes Object - done
// 8. refactor rock3d and rock classes to use the same wxWidgets GUI
//    - change both to use Point in base [] for modulation rather than argument 
//      note: 2d rocks now always map from surface
//    - in both modify arguments to "standard" as in plants and sprites
//      so all rocks can have biases
//    - add "3d" checkbox to UI
//      in UI change only class name (rock or rock3d) to regenerate
// 9. add noise modulation to 3d rocks using existing methods - done
// 10. support for shadows - done
// 11. improve lighting model (done)
// 12. add color -done 
// 13. add single texture (triplanar) using simple shader - done
// 14. add bump-map
// 15  multi-textures
//
// Notes:
// (1) the terrain stack may have one or more "layers"
//     - each "layer" has a separate Rock3DObjMgr
// (2) each Rock3DObjMgr can have multiple Rock types (PlaceObjs)
//     - typically 1 or 2
// (3) each rock type has a single TNRock, Rock3DMgr and Rock3D instance
//     - TNRock: generated by parsing the scene file (child of terrain stack)
//     - Rock3DMgr: responsible for creating rock instance candidates
//     - Rock3D: used by Rock3DObjMgr to produce final array of 3d rocks (utility class)
// (4) generation sequence
//     - In MapClass(render_objects) 
//       * called for each terrain layer and 3DObjMgr type instance in each layer (Plants, Sprites 3DRocks)
//       * traverses map data and generates array of visible objects (MapNodes) as seed candidates for placements 
//       * for each MapNode: calls MapNode->setSurface() to put 3d vertex(point) etc. into global objects
//       * calls Rock3DObjMgr: eval(): 
//     - Rock3DObjMgr(eval)
//       * for each type(TNrock), calls TNrock->eval() which calls Rock3Dmgr->eval()
//       * Rock3Dmgr populates global hash table with placement candidates
//     - Rock3DObjMgr(collect)
//       * traverses hash table and fills static array PlaceData(data)
//     - Rock3DObjMgr (render)
//       * parses data array and fills vertex buffer with OpenGL data (if need rebuild determied)
//     - Rock3DObjMgr (setProgram)
//       * sets up OpenGl environment for all objects to be rendered
//       * sets shader program
//     - Rock3DObjMgr (render_object)
//       * uploads/ renders data using vertex buffers

TexInfo::TexInfo(Texture *texture){
	texactive=texture->tex_active;
	bumpactive=texture->bump_active;
	texamp=texture->texamp;
	bumpamp=texture->bumpamp;
	scale=texture->scale;
	t2d=texture->t2d();
	texid=Rock3DObjMgr::texs.size();
	//cout<<"new tex 1d:"<<t1d<<endl;	
}
void TexInfo::print(){
	cout<<"tex id:"<<tid<<" texamp:"<<texamp<<" bumpamp:"<<bumpamp<<" scale:"<<scale<<endl;	
}
//************************************************************
// Rock3D class
//************************************************************
Rock3D::Rock3D(int t, TNode *e):PlaceObj(t,e)
{
	texid=0;
}
PlacementMgr *Rock3D::mgr() { 
	return ((TNrocks3D*)expr)->mgr;
}

bool Rock3D::setProgram(){
	Rock3DMgr* rmgr=(Rock3DMgr*)mgr();
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();	
	for(int i=0;i<rmgr->texs.size;i++){
		TNtexture *tntex=rmgr->texs[i];
		Texture *texture=tntex->texture;
		if(!tntex->isEnabled() || texture->t1d())
			continue;
#ifdef TEST_TEXTURES
		TerrainProperties::tid=tid;
		if(texture->bump_active && Render.bumps())
			nbumps++;
		texture->setProgram();
		texture->initProgram();
		tid++;
#else
		if((!texture->valid || Render.invalid_textures()) && texture->id[0]>0) {
			glDeleteTextures(1, (GLuint*)&texture->id[0]);
			texture->id[0]=0;
		}
#endif
#ifndef TEST_TEXTURES
		
		tntex->eval();
		TexInfo tex=TexInfo(texture);
		Rock3DObjMgr::texs.push_back(tex);
		
		if(texture->id[0]==0){
			Image *image=texture->timage;
			texid=tid++;
			glGenTextures(1, &texture->id[0]);
			glBindTexture(GL_TEXTURE_2D, texture->id[0]);
			
			// Texture parameters
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
			
			int w = image->width;
			int h = image->height;
			unsigned char* pixels = (unsigned char*)image->data;
			
			if(image->alpha_image() || image->gltype() == GL_RGBA)
				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
			else
	            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);			
		}
		glBindTexture(GL_TEXTURE_2D, texture->id[0]);
#endif
	}
	CurrentScope->set_passmode(mode);
	return true;
}


//************************************************************
// helper functions
//************************************************************

Color rock_color(0.6, 0.5, 0.4);

static SurfaceFunction makeCenteredSphere(const Point& center, double radius) {
    return [center, radius](double x, double y, double z) -> double {
        double dx = x - center.x;
        double dy = y - center.y;
        double dz = z - center.z;
        double distance = sqrt(dx*dx + dy*dy + dz*dz);
        return radius - distance;  // Positive inside sphere of given radius
    };
}

static SurfaceFunction makeCenteredEllipsoid(const Point& center, double rx, double ry, double rz) {
    return [center, rx, ry, rz](double x, double y, double z) -> double {
        double dx = (x - center.x) / rx;
        double dy = (y - center.y) / ry;
        double dz = (z - center.z) / rz;
        double distance = sqrt(dx*dx + dy*dy + dz*dz);
        return 1.0 - distance;  // Positive inside ellipsoid
    };
}

// Noisy sphere field for marching cubes iso-surface extraction using standard noise function
// Noisy ellipsoid field for marching cubes iso-surface extraction using standard noise function

#ifdef PERLIN_NOISE
// Noisy sphere field for marching cubes iso-surface extraction using built-in noise function
static SurfaceFunction makeNoisyRockField(const Point& center, double radius, int seed, double noiseAmpl) {
    return [center, radius, seed, noiseAmpl](double x, double y, double z) -> double {
        static std::map<int, PerlinNoise> noiseGens;
        if (noiseGens.find(seed) == noiseGens.end()) {
            noiseGens[seed] = PerlinNoise(seed);
        }
        PerlinNoise& noise = noiseGens[seed];
        
        double dx = x - center.x;
        double dy = y - center.y;
        double dz = z - center.z;
        double distance = sqrt(dx*dx + dy*dy + dz*dz);
        
        // Base sphere
        double baseSphere = radius - distance;
        
        // Add noise to the iso-surface
        // Scale sample position to get consistent look regardless of rock size
        double scale = 2.0 / radius;
        double n = noise.octaveNoise(dx * scale, dy * scale, dz * scale, 6, 0.5, 2.0, 0.5, 0.5);
        
        return baseSphere + n * noiseAmpl * radius;
    };
}

// Post-mesh vertex displacement OLD uses Perlin noise function
static void applyVertexDisplacement(MCObject* rock, int seed, double amplitude) {
    static std::map<int, PerlinNoise> noiseGens;
    if (noiseGens.find(seed) == noiseGens.end()) {
        noiseGens[seed] = PerlinNoise(seed);
    }
    PerlinNoise& noise = noiseGens[seed];
    
    Point center = rock->worldPosition;
    double rockSize = rock->baseSize;
    
    for (auto& tri : rock->mesh) {
        for (int v = 0; v < 3; v++) {
            Point& vertex = tri.vertices[v];
            
            // Direction from center to vertex (outward normal)
            Point dir = (vertex - center).normalize();
            
            // Normalize position relative to rock center and size
            // This gives us unit-scale coordinates for noise sampling
            double nx = (vertex.x - center.x) / rockSize;
            double ny = (vertex.y - center.y) / rockSize;
            double nz = (vertex.z - center.z) / rockSize;
            
            // Sample noise at normalized coordinates with some frequency
            double scale = 4.0;
            double n = noise.octaveNoise(
                nx * scale + seed * 0.1,  // Offset by seed for variation
                ny * scale, 
                nz * scale, 
                3, 0.5, 2.0, 0.5, 0.5
            );
            
            // Displace vertex along normal direction
            vertex.x += dir.x * n * amplitude;
            vertex.y += dir.y * n * amplitude;
            vertex.z += dir.z * n * amplitude;
        }
    }
}
#endif
static SurfaceFunction makeRockField(const Point& center, double rx, double ry, double rz, double noiseAmpl, TNode *tc) {
    return [center, rx, ry, rz, noiseAmpl, tc](double x, double y, double z) -> double {
     	//TheNoise.rseed = seed;
        
        double dx = x - center.x;
        double dy = y - center.y;
        double dz = z - center.z;
        
        // Ellipsoid distance (not sphere)
        double ex = dx / rx;
        double ey = dy / ry;
        double ez = dz / rz;
        double ellipsoidDist = sqrt(ex*ex + ey*ey + ez*ez);
        
        // Base ellipsoid (positive inside)
        double baseEllipsoid = 1.0 - ellipsoidDist;
        
        double scale = 2.0 / ((rx + ry + rz) / 3.0);  // Average radius for scale
        Point np = Point(dx, dy, dz);
 		TheNoise.set(np);
 		double rz = 0;
 		tc->eval();
		if (tc->typeValue() == ID_POINT)
 			rz = S0.p.z;
 		else
 			rz = S0.s;
        return baseEllipsoid - rz * noiseAmpl;
    };
}

// Post-mesh vertex displacement and color: uses standard noise function
static void applyVertexAttributes(MCObject* rock, double amplitude, TNode *tv, TNode *tc) {
    
    Point center = rock->worldPosition;
    double rockSize = rock->baseSize;
        
    for (auto& tri : rock->mesh) {
        for (int v = 0; v < 3; v++) {
            Point &vertex = tri.vertices[v];
            Color &color =tri.colors[v];
            
            // Direction from center to vertex (outward normal)
            Point dir = (vertex - center).normalize();
            
            // Normalize position relative to rock center and size
            // This gives us unit-scale coordinates for noise sampling
            double nx = (vertex.x - center.x) / rockSize;
            double ny = (vertex.y - center.y) / rockSize;
            double nz = (vertex.z - center.z) / rockSize;
			Point np(nx,ny,nz);
			TheNoise.set(np);
			Point pn;
			double rz=0;
			Point pv=vertex;
			if(tv && tv->isEnabled()){
				SINIT;
				tv->eval();	
				if(S0.pvalid()){
					Point pd=S0.p;
					Point delta=dir*pd*amplitude;
					vertex=vertex+delta;
				}
			}
			color=rock_color;
			if(tc && tc->isEnabled()){
				SINIT;
				tc->eval();	
				if(S0.cvalid())
					color=S0.c;
			}
        }
    }
}
// LOD template cache - now keyed by resolution AND noise parameters
struct LODKey {
    int resolution;
    bool noisy;
    
    bool operator<(const LODKey& other) const {
        if (resolution != other.resolution) return resolution < other.resolution;
        return noisy < other.noisy;
    }
};

int lodCacheHits=0;
int lodCacheMisses=0;
static std::map<int, MCObject*> lodTemplates;

static MCObject* getTemplateForLOD(PlaceData *s) {
    Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
    TNode *tc = pmgr->rnoise;
    double pts = s->pts;
    int rval = s->rval;
    double comp = pmgr->comp;
    int resolution = Rock3DMgr::getLODResolution(pts);
    double noiseAmpl = pmgr->noise_amp;
	bool noisy=(noiseAmpl>1e-6);

    int k1=resolution * 100;
    //int k2=(int)(rval)&7;
    int k2=(int)(rval * 10)/50;
    int key = k1 + k2;
    auto it = lodTemplates.find(key);
    if (it != lodTemplates.end()) {
    	lodCacheHits++;
        return it->second;
    }

    Point origin(0, 0, 0);
    MCObject* templateSphere = new MCObject(origin, 1.0);
    
    MCGenerator generator;
    
    double rx = 0.5;
    double ry = 0.5;
    double rz = 0.5 * (1.0 - comp);
    if (rz < 0.05) rz = 0.05;

    // Adjust bounds to match ellipsoid size
    // Add extra margin for noise (especially when noiseAmpl is high)
    double margin = 1.1 + noiseAmpl * 2.0;  // Increase margin with noise amplitude
    Point boundsMin(-rx * margin, -ry * margin, -rz * margin);
    Point boundsMax(rx * margin, ry * margin, rz * margin);    
   
    SurfaceFunction field;
    if (noisy) {
#ifdef PERLIN_NOISE
        field = makeNoisyRockField(origin, 0.5, 0, rval, noiseAmpl);
#else
        field = makeRockField(origin, rx, ry, rz, noiseAmpl, tc);
#endif
    } else {
        field = makeCenteredEllipsoid(origin, rx, ry, rz);
    }   
    templateSphere->mesh = generator.generateMesh(field, boundsMin, boundsMax, resolution, 0.0);
    templateSphere->meshValid = true;    
   lodTemplates[key] = templateSphere;
#ifdef PRINT_LOD_STATS    
    cout << "Created LOD template: resolution:" << resolution<< " key:"<<key 
         << " k1:"<< k1 << " k2:" << k2 
         << " Triangles:" << templateSphere->mesh.size() << endl;
#endif 
    lodCacheMisses++;
    return templateSphere;
}

//************************************************************
// Rock3DMgr class
//************************************************************
int Rock3DMgr::stats[MAX_ROCK_STATS][2];

Rock3DMgr::Rock3DMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,MCROCKS);
	comp=0.0;
	drop=0.0;
	vnoise=0;
	rnoise=0;
	color=0;

#ifdef TEST_ROCKS
    set_testColor(true);
#endif
    set_testDensity(true);
}

void Rock3DMgr::eval(){	
	PlacementMgr::eval(); 
}

void Rock3DMgr::init()
{
	PlacementMgr::init();
  	reset();
}

//-------------------------------------------------------------
// Rock3DMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *Rock3DMgr::make(Point4DL &p, int n)
{
    return new Placement(*this,p,n);
}
bool Rock3DMgr::testColor() { 
	return PlacementMgr::testColor()?true:false;
}
bool Rock3DMgr::testDensity(){ 
	return true;
}

struct RockLodEntry {
    int    res;     // voxel resolution
    double maxPts;  // upper bound for pts (pts < maxPts)
};

static const RockLodEntry kRockLodTable[MAX_ROCK_STATS] = {
    {  1,  2.0 },
    {  2,  5.0 },
    {  4,  8.0 },
    {  8, 12.0 },
    { 16, 20.0 },
    { 32, 50.0 },
    { 48, 90.0 },
    { 96,  1e9 }  // default / max detail (increased from 24)
};
void Rock3DMgr::clearStats(){
	for(int i=0;i<MAX_ROCK_STATS;i++){
		stats[i][0]=stats[i][1]==0;
	}
}

void Rock3DMgr::printStats(){
    int rcnt = 0;
    int tcnt = 0;
    int kcnt = 0;
    std::cout << "------- 3D Rocks stats --------" << std::endl;
    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
#ifdef PRINT_ROCK_STATS
        std::cout << "res:"       << kRockLodTable[i].res
                  << " cnt:"      << stats[i][0]
                  << " triangles:"<< stats[i][1]/1000<<" k"
                  << std::endl;
#endif
        rcnt  += stats[i][0];
        tcnt  += stats[i][1];
    }
    std::cout << "Totals rocks:"    << rcnt
 	          << " lod keys:"           << lodTemplates.size()
	          << " lod reuse:"      << 	100.0*lodCacheHits/(lodCacheHits+lodCacheMisses)<<" %"
              << " triangles:"      << tcnt/1000<<" k"
              << std::endl;
}

void Rock3DMgr::setStats(int res, int tris){
    for (int i = 0; i < MAX_ROCK_STATS; ++i) {
        if (kRockLodTable[i].res == res) {
            stats[i][0]++;           // count of rocks at this res
            stats[i][1] += tris;     // total triangles
            return;
        }
    }
}

int Rock3DMgr::getLODResolution(double pts) {
   extern int test2;
	if (test2)
		return 24;

	for (int i = 0; i < MAX_ROCK_STATS; ++i) {
		if (pts < kRockLodTable[i].maxPts) {
			return kRockLodTable[i].res;
		}
	}
	// Fallback (shouldn't hit if table is well-formed):
	return kRockLodTable[MAX_ROCK_STATS - 1].res;
}
//************************************************************
// Rock3DObjMgr class
//************************************************************
MCObjectManager Rock3DObjMgr::rocks;
bool Rock3DObjMgr::vbo_valid = false;
ValueList<PlaceData*> Rock3DObjMgr::data(10000, 5000);
std::map<Rock3DObjMgr::RockCacheKey, Rock3DObjMgr::RockCacheEntry> Rock3DObjMgr::rockCache;
int Rock3DObjMgr::cacheHits = 0;
int Rock3DObjMgr::cacheMisses = 0;
int Rock3DObjMgr::cacheRegens = 0;
std::list<TexInfo> Rock3DObjMgr::texs;

Rock3DObjMgr::~Rock3DObjMgr(){
	freeLODTemplates();
}

void Rock3DObjMgr::freeLODTemplates() {
    for (auto& pair : lodTemplates) {
        delete pair.second;
    }
    lodTemplates.clear();
}

double calculateNightLighting(double tod) {
    const double dawnStart = 0.20, dawnEnd = 0.3;
    const double duskStart = 0.7, duskEnd = 0.8;   
    // Night (before dawn or after dusk)
    if (tod < dawnStart || tod > duskEnd) 
        return 0.0;  
    // Full day (between dawn and dusk)
    if (tod >= dawnEnd && tod <= duskStart) 
        return 1.0;    
    // Dawn transition (smoothstep from 0 to 1)
    if (tod < dawnEnd) 
        return smoothstep(dawnStart, dawnEnd, tod);   
    // Dusk transition (smoothstep from 1 to 0)
    return 1.0 - smoothstep(duskStart, duskEnd, tod);
}
//-------------------------------------------------------------
// Rock3DObjMgr::setProgram() initialize shader
//-------------------------------------------------------------
bool Rock3DObjMgr::setProgram() {
    if (!data.size || !objs.size)
        return false;   
 
	if(PlaceObjMgr::shadow_mode)
		return false;
	cout<<"Rock3DObjMgr::setProgram() objs="<<objs.size<<endl;

#ifndef TEST_TEXTURES
	texs.clear();
	//tid=0;
	for(int i=0;i<objs.size;i++){
		objs[i]->setProgram();
	}
	int useTexture = 1;
	double textureScale=0;
	double bumpScale=0;
	
	for (const auto& tex : texs) {
		if(tex.bumpactive)
			bumpScale=tex.bumpamp;
		if(tex.texactive)
			textureScale=0.01*tex.scale;
		else
			useTexture=0;
		//tex.print();
	}
#endif
    char defs[1024] = "";
    sprintf(defs, "#define NLIGHTS %d\n", Lights.size);
    sprintf(defs+strlen(defs), "#define COLOR\n");

    bool do_shadows=Raster.shadows();
 	if(do_shadows && !TheScene->light_view()&& !TheScene->test_view())
 		sprintf(defs+strlen(defs),"#define SHADOWS\n");

    GLSLMgr::setDefString(defs);

#ifdef TEST_TEXTURES
    if(Render.textures()){
    	tid=0;
    	nbumps=0;
    	Texture::reset();
		for(int i=0;i<objs.size;i++){
			objs[i]->setProgram();
		}  
    }
	sprintf(defs,"#define NTEXS %d\n#define NBUMPS %d\n",tid,nbumps);

    //sprintf(defs,"#define NTEXS %d\n",tid);
	strcat(GLSLMgr::defString,defs);
    GLSLMgr::loadProgram("rocks3d_tex.vert", "rocks3d_tex.frag");
#else
    GLSLMgr::loadProgram("rocks3d.vert", "rocks3d_triplanar.frag");
#endif

    GLhandleARB program = GLSLMgr::programHandle();
    if (!program)
        return false;
     GLSLVarMgr vars;

    Planetoid *orb = (Planetoid*)TheScene->viewobj;
    Color diffuse = orb->diffuse;
    Color ambient = orb->ambient;
	Color shadow=orb->shadow_color;
	Color haze=Raster.haze_color;
	
	double tod=orb->tod;
	
	double night_lighting=1;
	if(!TheScene->changed_file())
		night_lighting=calculateNightLighting(tod);
	//cout<<"tod:"<<tod<<" "<<night_lighting<<endl;
     
    vars.newFloatVec("Diffuse", diffuse.red(), diffuse.green(), diffuse.blue(), diffuse.alpha());
    vars.newFloatVec("Ambient", ambient.red(), ambient.green(), ambient.blue(), ambient.alpha());
	vars.newFloatVec("Shadow",shadow.red(),shadow.green(),shadow.blue(),orb->shadow_intensity);
	vars.newFloatVec("Haze",haze.red(),haze.green(),haze.blue(),haze.alpha());
	vars.newFloatVar("night_lighting",night_lighting);
#ifndef TEST_TEXTURES
	vars.newFloatVar("textureScale",textureScale);
	vars.newFloatVar("bumpScale",bumpScale);
	vars.newIntVar("useTexture",useTexture);
	
	glEnable(GL_TEXTURE_2D);
	cout<<"tex scale:"<<textureScale<<" bump:"<<bumpScale<<endl;
	GLuint texLoc = glGetUniformLocation(program, "rockTexture");
	glUniform1i(texLoc, 0);
	// TODO - add support for multiple textures
	// (4) each rock type can have 0,1 or 2 textures 
	//     - expect just single 2d texture for image/bumps but maybe later a 1D color overlay
	// (5) each rock type will produce multiple instances at various size scales (already supported)
	// for each texture in "texs"
	// add here
	// (1)set sampler in shader to samplers2d[i] vs rockTexture
	//    sprintf(str,"samplers2d[%d]",tex.texid);    		glUniform1iARB(glGetUniformLocationARB(program,str),tex.texid);
    // (2) pass a data structure for each sampler (e.g.)
	//    sprintf(str,"tex2d[%d].texamp",tex.texid);   		glUniform1fARB(glGetUniformLocationARB(program,str),tex.texamp);
	//	  sprintf(str,"tex2d[%d].bumpamp",tex.texid);  		glUniform1fARB(glGetUniformLocationARB(program,str),tex.bumpamp);
	//	  sprintf(str,"tex2d[%d].texscale",tex.texid);  	glUniform1fARB(glGetUniformLocationARB(program,str),tex.scale);
	//    ... others as needed (e.g. 1d texture overlays etc.)
	// in frag shader
	// struct tex2d_info {
	//   float scale;
	//   float bumpamp;
	//   float texamp;
	//   ...
	// };
	// uniform tex2d_info tex2d[NTEXS];
	// uniform sampler2D samplers2d[NTEXS];
#endif  



    vars.setProgram(program);
    vars.loadVars();

    GLSLMgr::setProgram();
    GLSLMgr::loadVars();
    
    return true;
}
void Rock3DObjMgr::free() { 
	data.free();
    rocks.clear(); 
    vbo_valid = false; 
}

//-------------------------------------------------------------
// Rock3DObjMgr::collect() generate array of placements (data)
//-------------------------------------------------------------
void Rock3DObjMgr::collect() {
    data.free();
    for (int i = 0; i < objs.size; i++) {
        PlaceObj *obj = objs[i];
        obj->mgr()->collect(data);
    }
    if (data.size)
        data.sort();
    vbo_valid = false;
}

void Rock3DObjMgr::render_zvals(){

	if(objs.size==0)
		return;
	//cout<<"Rock3DObjMgr::render_zvals() view:"<<Raster.shadow_vcnt<<":"<<Raster.shadow_vsteps<<endl;
	if(Raster.shadow_vcnt==0)
		shadow_start=true;
	shadow_mode=true;
	render();
    shadow_start=false;

	shadow_mode=false;
}

void Rock3DObjMgr::render_shadows(){
	if(objs.size==0)
		return;
	shadow_mode=true;
    
	// not really needed - these are the defaults for shadow mode
	Raster.setShadowProgram("shadows.vert",0,0);
	Raster.setProgram(Raster.PLACE_SHADOWS);
	render();
//	if(Raster.shadow_vcnt==Raster.shadow_vsteps-1)
	shadow_mode=false;
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render() {
    int n = data.size;
    if (n == 0)
        return;
    
    bool wireframe = test7;
    bool smooth = test8;
         
    bool moved = TheScene->moved();
	bool changed=TheScene->changed_detail();
	//cout<<"moved:"<<moved<<" shadows:"<<PlaceObjMgr::shadow_mode<<" start:"<<shadow_start<<endl;
	if(PlaceObjMgr::shadow_mode && !shadow_start){
		moved=false;
	}
    bool update_needed = moved || changed || !vbo_valid;
    if(TheScene->changed_detail())
    	lodCacheHits=lodCacheMisses=0;
      
    if (update_needed) {
    	//cout<<"Rebuilding shadow_mode:"<<PlaceObjMgr::shadow_mode<<" moved:"<<moved<<" shadow_start:"<<shadow_start<<endl;
        if (changed) {
            std::cout << "Settings changed - clearing cache" << std::endl;
            rockCache.clear();
            rocks.clear();
            vbo_valid = false;
        }

   		Point xpoint = TheScene->xpoint;
        rocks.clear();
        Rock3DMgr::clearStats();
        
        // Mark all cached as not used
        for (auto& pair : rockCache) {
            pair.second.framesSinceUsed++;
        }
        
        int hits = 0, misses = 0, regens = 0;

        for (int i = n - 1; i >= 0; i--) {
            PlaceData *s = data[i];
            
            Rock3DMgr *pmgr = (Rock3DMgr*)s->mgr;
            TNode *tr = pmgr->rnoise;
            
            char tmp[1024];
            tmp[0] = 0;
            if (tr)
                tr->valueString(tmp);
            TNode *tv = pmgr->vnoise;  
            if (tv)
                tv->valueString(tmp);
            TNode *tc = pmgr->color;  
            if (tc)
                tc->valueString(tmp);
            std::string estr = tmp;
            
            double isoNoiseAmpl = pmgr->noise_amp;
            
            bool useNoisyIsoSurface = isoNoiseAmpl > 0;
            bool useVertexDisplacement = (tv != nullptr && tv->isEnabled());
            bool setVertexColor = (tc != nullptr && tc->isEnabled());
            
            double vertexNoiseAmpl = useVertexDisplacement ? 0.5 * pmgr->noise_amp : 0;

            Point eyePos = s->vertex - xpoint;
            double size = PSCALE * s->radius;
            double pts = s->pts;
            double dist = s->dist;
            int rval = s->rval;
            double comp = pmgr->comp;
            double drop = pmgr->drop;
             
            int resolution = Rock3DMgr::getLODResolution(pts);
            
            // Create cache key from world position
            RockCacheKey key(s->vertex);
            
            // Use frame-unique name (not cache key based)
            char name[64];
            sprintf(name, "rock_%d", i);
            
            // Check cache
            auto it = rockCache.find(key);
            
            bool needsGeneration = true;
            std::vector<MCTriangle> templateMesh;
            
            if (it != rockCache.end()) {
                RockCacheEntry& entry = it->second;
                entry.framesSinceUsed = 0;
                
                // Check what's different
                bool resMatch = (entry.resolution == resolution);
                bool seedMatch = (entry.seed == rval);
                bool isoNoiseExprMatch = (estr == entry.estr);
                 
                if (!resMatch || !seedMatch || !isoNoiseExprMatch) {
 #ifdef PRINT_ROCK_CACHE_STATS
                    if (regens < 5) {
                        std::cout << "Regen rock " << i << ": ";
                        if (!resMatch) std::cout << "res " << entry.resolution << "->" << resolution << " ";
                        if (!seedMatch) std::cout << "seed " << entry.seed << "->" << rval << " ";
                        std::cout << std::endl;
                    }
#endif
                    regens++;
                    rockCache.erase(it);
                    needsGeneration = true;
                } else {
                    // CACHE HIT
                    templateMesh = entry.mesh;
                    needsGeneration = false;
                    hits++;
                }
            } else {
                misses++;
            }           
            // Generate if needed
            if (needsGeneration) {
            	int rseed=TheNoise.rseed;
            	TheNoise.rseed=rval;
                MCObject* templateSphere = getTemplateForLOD(s);                
                if (!templateSphere || templateSphere->mesh.empty()){
             		TheNoise.rseed = rseed;
                    continue;   
                }
                // Copy mesh without modification
                for (const auto& tri : templateSphere->mesh) {
                    MCTriangle newTri;
                    for (int v = 0; v < 3; v++) {
                        newTri.vertices[v] = tri.vertices[v];
                    }
                    newTri.normal = Point(-tri.normal.x, -tri.normal.y, -tri.normal.z);
                    templateMesh.push_back(newTri);
                }               
                // Apply vertex displacement in template space
                if (useVertexDisplacement || setVertexColor) {
                    MCObject tempRock(Point(0,0,0), 1.0);
                    tempRock.mesh = templateMesh;
#ifdef PERLIN_NOISE
                    applyVertexDisplacement(&tempRock, rval, vertexNoiseAmpl);     // use built-in perlin noise
#else
                    applyVertexAttributes(&tempRock,vertexNoiseAmpl, tv, tc); // use standard TNoise function
#endif
                    templateMesh = tempRock.mesh;  // COPY THE DISPLACED MESH BACK!
                 }
                                
                // Store in cache
                RockCacheEntry entry;
                entry.mesh = templateMesh;
                entry.worldVertex = s->vertex;
                entry.resolution = resolution;
                entry.estr = estr;
                entry.seed = rval;
                entry.framesSinceUsed = 0;
                rockCache[key] = entry;
        	
         		TheNoise.rseed = rseed;
            }
            
            // Create rock and transform to eye space
            MCObject* rock = rocks.addObject(eyePos, size);
            //MCObject *rock = rocks.addObject(name, eyePos, size);
            //cout<<name<<endl;
            if (rock) {
                rock->setDistanceInfo(dist, pts);
                rock->mesh.clear();
                
                // Get world position and surface normal
                Point worldPos = s->vertex;
                Point up = s->normal;
                
                double dscale=PSCALE*drop*(1-0.5*comp)*0.5;
                
                // Apply drop: lower the rock center along surface normal
                Point rockCenter = worldPos - up*(s->radius * dscale);
                
                Point right, forward;
				if (fabs(up.z) < 0.9)
					right = Point(up.y, -up.x, 0).normalize();
				else
					right = Point(0, up.z, -up.y).normalize();
				
				forward = Point(up.y * right.z - up.z * right.y,
						up.z * right.x - up.x * right.z,
						up.x * right.y - up.y * right.x);
 
               // Transform each vertex from world space to eye space
      
                for (const auto& tri : templateMesh) {
                    MCTriangle newTri;                  
                    for (int v = 0; v < 3; v++) {
                        Point tv = tri.vertices[v];                       
						newTri.templatePos[v] = tv;  // STORE template position
                        Point rotated = Point(
								tv.x * right.x + tv.y * forward.x + tv.z * up.x,
								tv.x * right.y + tv.y * forward.y + tv.z * up.y,
								tv.x * right.z + tv.y * forward.z + tv.z * up.z);						
                        Point worldVertex = rockCenter+rotated*size;
						newTri.vertices[v] = worldVertex - xpoint; // Convert to eye space
						newTri.colors[v]=tri.colors[v];
                    }                   
                    // Calculate normal in eye space from the 3 eye-space vertices
                    Point edge1 = newTri.vertices[1] - newTri.vertices[0];
                    Point edge2 = newTri.vertices[2] - newTri.vertices[0];
                    Point eyeNormal = edge2.cross(edge1);
                    newTri.normal = eyeNormal.normalize();
                    rock->mesh.push_back(newTri);
                }
                rock->meshValid = true;
                rock->worldPosition = eyePos;
                
                // Upload VBO
                if (smooth && useVertexDisplacement)
                     rock->uploadToVBODisplaced();
                else 
                    rock->uploadToVBO();                
                Rock3DMgr::setStats(resolution, rock->mesh.size());
            }
        }
        
        // Cull old cache entries
        for (auto it = rockCache.begin(); it != rockCache.end(); ) {
            if (it->second.framesSinceUsed > 5) {
                it = rockCache.erase(it);
            } else {
                ++it;
            }
        }
        
        // Cache size limit
        const size_t MAX_CACHE_SIZE = 10000;
        if (rockCache.size() > MAX_CACHE_SIZE) {
            std::vector<std::pair<RockCacheKey, int>> ages;
            for (auto& pair : rockCache) {
                ages.push_back({pair.first, pair.second.framesSinceUsed});
            }
            std::sort(ages.begin(), ages.end(), 
                      [](auto& a, auto& b) { return a.second > b.second; });
            
            size_t toRemove = rockCache.size() - MAX_CACHE_SIZE;
            for (size_t i = 0; i < toRemove; i++) {
                rockCache.erase(ages[i].first);
            }
            std::cout << "Cache limit reached - removed " << toRemove << " oldest entries" << std::endl;
        }
#ifdef PRINT_CACHE_STATS
        std::cout << "Rock cache: " << hits << " hits, " << misses << " misses, " 
                  << regens << " regens, " << rockCache.size() << " cached" << std::endl;
#endif
#ifdef PRINT_STATS       
        Rock3DMgr::printStats();
#endif
        vbo_valid = true;
    }

    render_objects();
 
}
//-------------------------------------------------------------
// Rock3DObjMgr::render() create and render the 3d rocks
//-------------------------------------------------------------
void Rock3DObjMgr::render_objects() {
    bool wireframe = test7;

    if(!PlaceObjMgr::shadow_mode){
    	if (!setProgram()) {
    	  cout << "Rock3DObjMgr::setProgram FAILED" << endl;
    	  return;
    	}
    }
    if (wireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	else
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    
	const std::vector<MCObject*>& rockList = rocks.getObjects();
	for (MCObject *rock : rockList) {
		if (rock->vboValid && rock->mesh.size() > 0) {
             
			glBindBuffer(GL_ARRAY_BUFFER, rock->vboVertices);
			glVertexPointer(3, GL_FLOAT, 0, 0);
			glEnableClientState(GL_VERTEX_ARRAY);

			glBindBuffer(GL_ARRAY_BUFFER, rock->vboNormals);
			glNormalPointer(GL_FLOAT, 0, 0);
			glEnableClientState(GL_NORMAL_ARRAY);

			glBindBuffer(GL_ARRAY_BUFFER, rock->vboColors);
			glColorPointer(3, GL_FLOAT, 0, 0);
			glEnableClientState(GL_COLOR_ARRAY);

			// ADD THIS - bind template position as vertex attribute
			GLhandleARB program = GLSLMgr::programHandle();
			GLint attribLoc = glGetAttribLocation(program, "templatePosition");
			if (attribLoc >= 0) {
				glBindBuffer(GL_ARRAY_BUFFER, rock->vboTemplatePos);
				glVertexAttribPointer(attribLoc, 3, GL_FLOAT, GL_FALSE, 0, 0);
				glEnableVertexAttribArray(attribLoc);
			}

			glDrawArrays(GL_TRIANGLES, 0, rock->mesh.size() * 3);
			
			// Disable template position attribute
			if (attribLoc >= 0) 
			    glDisableVertexAttribArray(attribLoc);
			glDisableClientState(GL_VERTEX_ARRAY);
			glDisableClientState(GL_NORMAL_ARRAY);
			glDisableClientState(GL_COLOR_ARRAY);
		}
	}
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}
//************************************************************
// TNrocks3D class
//************************************************************
TNrocks3D::TNrocks3D(int t,TNode *l, TNode *r, TNode *b) : TNplacements(t|MCROCKS,l,r,b)
{
	mgr=new Rock3DMgr(type);
	rock=0;
}


static Rock3DMgr *rm;
static void collectTexs(NodeIF *obj){
	int type=obj->typeValue();
	if(type==ID_TEXTURE){
		TNtexture *tex=(TNtexture *)obj;
		if(tex->texture)
			tex->texture->tid=tid;
		rm->texs.add(tex);
	}
}

//-------------------------------------------------------------
// TNrocks3D::init() initialize the node
//-------------------------------------------------------------
void TNrocks3D::init()
{
	Rock3DMgr *rmgr=(Rock3DMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);

	if(args[7]){
		TNarg *tamp=args[6];
		tamp->eval();
		rmgr->rnoise=args[7];			
	}
	
	TNode *tv=findChild(ID_POINT);
	if(tv)
		rmgr->vnoise=tv;
	else
		rmgr->vnoise=0;
	TNode *tc=findChild(ID_COLOR);
	if(tc)
		rmgr->color=tc;
	else
		rmgr->color=0;
	rmgr->texs.reset();
	rm=rmgr;
	tid=0;
	if(base){
		base->visitNode(collectTexs);
	}

	mgr->set_first(1);
	if(rock==0)
		rock=new Rock3D(type,this);	
}

//-------------------------------------------------------------
// TNrocks3D::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks3D::eval()
{
	TerrainData ground;
	static int cnt=0;
	
	if(!isEnabled() || TheScene->viewtype !=SURFACE){
		if(right)
			right->eval();
		return;
	}
	SINIT;
	if(CurrentScope->rpass()){
		int layer=inLayer()?Td.tp->type():0; // layer id
		int instance=Td.tp->Rocks.objects();
		mgr->instance=instance;
		mgr->layer=layer;
		if(rock){
			rock->set_id(instance);
			rock->layer=layer;
		}
		Td.tp->Rocks.addObject(rock);
		mgr->setHashcode();
		if(right)
			right->eval();
		return;
	}
	if(right)
		right->eval();
	
	if(!CurrentScope->spass()){
		ground.copy(S0);
	}
	INIT;

	mgr->type=type;

	mgr->getArgs((TNarg *)left);
	
	MaxSize=mgr->maxsize;
	
	double density=mgr->density;

	if(density>0)
		mgr->eval();  // calls PlantPoint.set_terrain (need MapPt)
	
	if(!CurrentScope->spass()){ // adapt pass only
		S0.copy(ground); // restore S0.p.z etc
		mgr->setTests(); // set S0.c S0.s (density)
	}
}

//------------------- 2D Rocks ------------------------------

//************************************************************
// Rock class
//************************************************************
Rock::Rock(PlacementMgr&m, Point4DL&p,int n) : Placement(m,p,n)
{
}
//-------------------------------------------------------------
// Rock::set_terrain()	impact terrain 
//-------------------------------------------------------------
bool Rock::set_terrain(PlacementMgr &pmgr)
{
	double r,z,rm=0;
	RockMgr &mgr=(RockMgr&)pmgr;
	
	mgr.pdist=1;
	if(radius==0)
		return false;
	
	double d=pmgr.mpt.distance(center);
	
	double thresh=mgr.noise_ampl;
	double td=mgr.drop*mgr.maxsize;
	double t=1.75*radius;

	r=radius;

	if(d>t)
		return false;

	if(pmgr.testColor())
		Placement::set_terrain(pmgr);
	
	mgr.pdist=d/radius;
	mgr.pdist=clamp(mgr.pdist,0,1);

 	if(mgr.noise_ampl>0){
 		double nf=mgr.noise_ampl*radius/Hscale;
 		SPUSH;
		Point4D np;
		if(mgr.offset_valid())
		    np=(mgr.mpt-mgr.offset)*(1/radius);
		else
		    np=(mgr.mpt)*(1/radius);
 		np=np+1/radius;
 		if(TheNoise.noise3D())
 		    np.w=0;
 		TheNoise.push(np);
 		CurrentScope->revaluate();
 		double z=0;
 		mgr.rnoise->eval();
 		if(mgr.rnoise->typeValue()==ID_POINT){
 			z=S0.p.z;
 			mgr.rx=nf*S0.p.x;
 			mgr.ry=nf*S0.p.y; 	
  		}
 		else
 			z=S0.s;
 		TheNoise.pop();
 		rm=0.25*z*mgr.noise_ampl*radius;
 		SPOP;
		d+=rm;
		r-=rm;
 	}
	mgr.rdist=d/r;
	
	d=clamp(d,0,1);
	
	z=mgr.base;
	
	S0.set_flag(ROCKBODY);

	setActive(true);

    z-=0.5*mgr.zcomp*r/Hscale;
	if(r>d)
		z+=(1-mgr.zcomp)*sqrt(r*r-d*d)/Hscale;
    if(z>mgr.ht)
        mgr.ht=z;
    return true;
}

//************************************************************
// RockMgr class
//************************************************************
//	arg[0]  levels   		scale levels
//	arg[1]  maxsize			size of largest craters
//	arg[2]  mult			size multiplier per level
//	arg[3]  density			density or dexpr
//
//	arg[4]  zcomp			z compression factor
//	arg[5]  drop			z drop factor or function
//	arg[6]  noise		    noise amplitude
//	arg[7]  noise_expr		noise function
//-------------------------------------------------------------
TNode *RockMgr::default_noise=0;
RockMgr::RockMgr(int i) : PlacementMgr(i)
{
	MSK_SET(type,PLACETYPE,ROCKS);
	noise_ampl=1;
	zcomp=0.1;
	drop=0.1;
	rnoise=0;
	rdist=0;
	pdist=1;
	rx=ry=0;
#ifdef TEST_ROCKS
    set_testColor(true);
#endif

}
RockMgr::~RockMgr()
{
  	if(finalizer()){
#ifdef DEBUG_PMEM
  		printf("RockMgr::free()\n");
#endif
        DFREE(default_noise);
	}
}

//-------------------------------------------------------------
// RockMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *RockMgr::make(Point4DL &p, int n)
{
    return new Rock(*this,p,n);
}

//-------------------------------------------------------------
// RockMgr::init()	initialize global objects
//-------------------------------------------------------------
void RockMgr::init()
{
	if(default_noise==0){
#ifdef DEBUG_PMEM
  		printf("RockMgr::init()\n");
#endif
	   default_noise=(TNode*)TheScene->parse_node((char*)def_rnoise_expr);
	}
	PlacementMgr::init();
}

//************************************************************
// TNrocks class
//************************************************************
TNrocks::TNrocks(int t, TNode *l, TNode *r, TNode *b) : TNplacements(t|ROCKS,l,r,b)
{
    mgr=new RockMgr(type);
	TNarg &args=*((TNarg *)left);
	TNode *arg=args[8];
	if(arg && (arg->typeValue() != ID_CONST))
		mgr->dexpr=arg;
	set_collapsed();
}

//-------------------------------------------------------------
// TNrocks::applyExpr() apply expr value
//-------------------------------------------------------------
void TNrocks::applyExpr()
{
    if(expr){
 		TNrocks* rocks=(TNrocks*)expr;
        DFREE(left);
        left=rocks->left;
        left->setParent(this);
        rocks->init();
		delete mgr;
		type=rocks->type;
		mgr=rocks->mgr;
		rocks->left=0;
		rocks->mgr=0;
		rocks->base=0;
		eval();
		delete rocks;
        expr=0;
    }
    if(base)
        base->applyExpr();
}

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceChild(NodeIF *c,NodeIF *n)
{
	return TNbase::replaceChild(c,n);
}

//-------------------------------------------------------------
// TNrocks::replaceChild replace content
//-------------------------------------------------------------
NodeIF *TNrocks::replaceNode(NodeIF *c)
{
	((TNrocks*)c)->right=right;
	((TNrocks*)c)->parent=parent;
	parent->replaceChild(this,c);
	delete base;
	base=0;
	TheScene->rebuild_all();
	return c;
}

//-------------------------------------------------------------
// TNrocks::addAfter append x after base if c==this
// - used when adding a TNnode object to a TerrainMgr stack
// - always want to append other objects after Rocks in tree
//-------------------------------------------------------------
NodeIF *TNrocks::addAfter(NodeIF *c,NodeIF *x){
	if(c==this){
		TNode *node=(TNode*)x;
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else if(c)
		c->addChild(x);
	else
		addChild(x);
	return x;
}
//-------------------------------------------------------------
// TNrocks::addChild
//-------------------------------------------------------------
NodeIF *TNrocks::addChild(NodeIF *x){
	TNode *node=(TNode*)x;
	//cout<<"rocks::addChild "<<x->typeName()<<end;
	if(collapsed()){
		if(right){
			if(x->linkable()){
    			x->setParent(this);
    			x->addChild(right);
    			right=(TNode*)x;
			}
			else {
				TNadd *node=new TNadd((TNode*)x,right);
				node->setParent(this);
				right=node;
			}
		}
		else{
			right=node;
			right->setParent(this);
		}
	}
	else{
		if(base){
			node=new TNadd(node,base);
			node->setParent(this);
			base=node;
		}
		else{
			base=node;
			base->setParent(this);
		}
	}
	return x;
}

//-------------------------------------------------------------
// TNrocks::init() initialize the node
//-------------------------------------------------------------
void TNrocks::init()
{
	RockMgr *rmgr=(RockMgr*)mgr;
	rmgr->init();
	TNplacements::init();
	TNarg &args=*((TNarg *)left);

	if(args[7]){
		TNarg *tamp=args[6];
		tamp->eval();
		rmgr->noise_ampl=S0.s;
		rmgr->rnoise=args[7];			
	}
	mgr->set_first(1);
	TNplacements::init();
}

#define ROCK_LAYER
//-------------------------------------------------------------
// TNrocks::eval() evaluate the node
//-------------------------------------------------------------
void TNrocks::eval() {
	if (!isEnabled() || TheScene->viewtype != SURFACE) {
		if (right)
			right->eval();
		return;
	}

	TerrainData rock;
	TerrainData ground;
	int i;
	bool first = (right && right->typeValue() != ID_ROCKS);
	bool last = getParent()->typeValue() != ID_ROCKS;
	INIT;
#ifdef ROCK_LAYER
	S0.set_flag(ROCKLAYER);
#endif
	int in_map = S0.get_flag(CLRTEXS);

	if (CurrentScope->rpass()) {
		INIT;
		if(right) // ground
			right->eval();
		INIT;
#ifdef ROCK_LAYER
		Td.add_id();
		Td.tp->set_rock(true);
		Td.tp->ntexs=0;
		Td.tp->set_rock(true);
		if(!in_map)
			S0.set_flag(CLRTEXS);
		if(base)// rock texs
			base->eval();
		if(!in_map)// in case we were in another map on entry
			S0.clr_flag(CLRTEXS);
#else
		if(base)// rock texs
			base->eval();
#endif
		mgr->setHashcode();
		return;
	}
#ifdef ROCK_LAYER
	if (!in_map && first)
		Td.begin();
#endif
	ground.p.z = 0;

	INIT;
	bool other_rock = false;
	if (right)
		right->eval(); // ground
	other_rock = S0.get_flag(ROCKBODY);
	S0.p.z-=Drop;
	if (first) {
		S0.next_id();
		Td.insert_strata(S0);
	}
	ground.copy(S0);
	INIT;

	RockMgr *rmgr = (RockMgr*) mgr;
	
	mgr->getArgs((TNarg *)left);
	INIT;
	if (base)
		base->eval();
	S0.p.z=ground.p.z;
	rmgr->base = S0.p.z-rmgr->drop*rmgr->maxsize/Hscale;
#ifdef ROCK_LAYER
	S0.next_id();
#endif
	rock.copy(S0);
	INIT;
	rmgr->ht = mgr->base;
	rmgr->eval();  // calls set_terrain sets mgr->ht

	if (rmgr->noise_ampl)
		CurrentScope->revaluate();
	rock.p.z = rmgr->ht;
	double delta = (rock.p.z - ground.p.z) / fabs(ground.p.z);
	if (delta > 0) {
		rock.p.x = rmgr->rx * (1 - rmgr->rdist);
		rock.p.y = rmgr->ry * (1 - rmgr->rdist);
		S0.copy(rock);
#ifdef ROCK_LAYER
		Td.tp->set_rock(true);
		S0.set_flag(ROCKBODY);
#endif
	}
	else {
		Td.tp->set_rock(false);
		S0.copy(ground);
#ifdef ROCK_LAYER
		if(!other_rock)
			S0.clr_flag(ROCKBODY);
#endif
	}
#ifdef ROCK_LAYER
	Td.insert_strata(rock);
	if (!in_map && last)
		Td.end();
#endif
}

// called by VtxSceneDialog ->scene->makeObject
// called by Scene->makeObject
// this = prototype obj=parent(layer) m=GN_TYPE
// this->setParent(obj) already set
// VtxSceneDialog ->addtoTree(this)
NodeIF *TNrocks::getInstance(NodeIF *obj, int m){	
	return newInstance(m);
}
bool TNrocks::randomize(){
	double f=0.2;
	TNarg *arg=(TNarg*)left;
	char buff[1024];
	buff[0]=0;
	arg=arg->index(1);
	int i=0;
	while(arg){
		if(arg->left->typeValue()==ID_CONST){
			TNconst *val=(TNconst*)arg->left;
			//cout<<s[i]<<" before:"<<val->value;
			val->value*=(1+f*s[i]);
			//cout<<" after:"<<val->value<<endl;
		}
		else if(arg->left->typeValue()==ID_NOISE){
			TNnoise *val=(TNnoise*)arg->left;
			buff[0]=0;
			val->valueString(buff);
			//cout<<"before:"<<buff<<endl;
			std::string str=TNnoise::randomize(buff,f,1);
			TNnoise *newval=TheScene->parse_node((char*)str.c_str());
			arg->left=newval;
			//cout<<"after:"<<str<<endl;
			delete val;
		}
		i++;
     	arg=arg->next();
	}
	return true;
}

// this=prototype, this->parent=layer
TNrocks *TNrocks::newInstance(int m){
	NodeIF::setRands();
	int gtype=m&GN_TYPES;
	Planetoid *orb=(Planetoid *)getOrbital(this);
	Planetoid::makeLists();
	std::string str=Planetoid::newRocks(orb,gtype);
	TNrocks *rocks=TheScene->parse_node((char*)str.c_str());
	rocks->setParent(parent);
	rocks->randomize();
	return rocks;
}
