#include "SceneClass.h"
#include "RenderOptions.h"
#include "Plants.h"
#include "Util.h"
#include "MapNode.h"
#include "ModelClass.h"
#include "AdaptOptions.h"
#include "FileUtil.h"
#include "GLSLMgr.h"
#include "Effects.h"
#include "TerrainClass.h"

#define COLOR_TEST
//#define DENSITY_TEST

#define SHOW_STATS
#define SHOW_BRANCH_STATS
//#define DEBUG_SLOPE_BIAS

#define SRAND(x) 	(rands[PERM((x++))])
#define URAND(x) 	(rands[PERM((x++))]+0.5)

#define FIRST_FORK  1
#define FIRST_EMIT  2
#define LAST_EMIT   4

#define LINE_MODE   1

// Basic algorithm
// 1) TNplant class implemented similar to sprites, craters etc (i.e placements)
//    Primary task is to generate a set of surface positions to spawn plant instances
// 2) TNbranch class creates a branching pattern for each plant placement
//    - Branches are implemented as 3d points which are projected into eye space then screen space
//    - successive branch levels are generated by calling "emit" recursively 
//      (or fork on first call if multiple branch types exist)
// 3) in screen space either a line (with width) or a polygon is drawn between connecting branch points
// 4) if a polygon is used base and tip parameter points are calculated based on the angle of the branch
//    - distance between tip points is less than that between base points to simulate branch taper
// 5) lighting (branch curvature) is emulated by changing normal from left to right along branch
//   - in the center normal faces directly out to eye
// TODO: 
// 1) Better branching model (DONE)
//  Currently all branches spawn from the same point in screen space
//  Improve this by trying the following:
//  a) allow branches to spawn at random locations along parent stem vector (DONE)
//    - set 'start' position somewhere between top and base using random variable
//  b) don't require branch starting width to be the same as parents width (DONE)
//    - scale next segment width based on size of child branch
//  c) In multi-branch cases have a minimum level to start producing new branches and max level to stop (DONE)
//    - min level prevents branches from forming lower in parent trunk
//    - child branches should form only towards the tip of parent branches
// 2) implement geometry shader to improve performance (DONE)
//    - pass in vectors in screen space (bot, top) of line
//    - calculate screen space rectangle (or line)
//    - produce vertex's to draw rectangle (or line)
// 3) add support for textures (DONE)
// 4) add support for bump shading for textures (DONE)
// 5) implement TNleaf class
//    - only generate leaves at end of "terminal" branches
//    - if a texture is present may use a point sprite implementation 
//      o probably need to sort if the texture has an alpha channel
//    - could instead use a simple geometry model (single triangle with color ?)
//    - should also allow branch-like forking prior to applying (optional) texture (as a point sprite) or shape geometry
// 6) use a spline function when connecting levels on same branch
//   - generate additional line segments between segment end points (no need for branching)
// 7) better lighting model for branches
//   - currently only uses x-direction in screen space
//   - works good for vertical trunks but makes horizontal look flat
//   - idea:incorporate delta-y to get better effect ?
// 8) add curvature to branches by implementing a spline function
//   - for efficiency probably best done in a geometry shader
// 9) use lists to increase render speed
// 10)generate wxWidgets classes for plants
//    - optional support preview window with option to save generated imaged as sprites
	
// BUGS/problems
// 1) see a lot of jitter on branches when moving around (FIXED)
//   problem traced to starting width variation based on position (size of dot as viewpoint changes)
//   - if width is used for early exit this results in different number of RAND calls
//     for the same plant which changes the "seed" value resulting in a different branching pattern
//   - workaround: don't use width as an exit criteria - but reduce overhead by bypassing
//     drawing and calculation sections in emit if width <1
//     o this only improves speedup marginally (overhead mainly due to stack pushes ?)
//   - better: save and restore randval at start and end of fork function (plus early return if width<1)
//     o no observable difference in result (surprising ?)
//     o decreases "skipped" calls 4-7 fold
//     o speed up ~2x
//     o jitter not observed
// 2) don't get enough plants generated - not all color spots produce a new plant
//     o improvement: added extra argument in TNplant to increase size of "dot" (threshold test)
//     o improvement: moving visits++ before threshold test in set_terrain
// 3) far away plants (e.g. trees) look "denuded" (i.e. lack foliage) because smaller branches arn't drawn
//    - may be fixed later by implementing leaf class and rendering leafs at all terminal nodes ?
// 4) 1 pixel rectangles rendered using GS_SHADER (or without TRIANGLE_LINES)show gaps in branch segments (FIXED)
//    - fixed for GS_SHADER by setting glPolygonMode to GL_LINE when width <2 (i.e draw lines)
//    - surprisingly, setting glLineWidth to 1.0 (vs. variable width) resulted in a speedup from ~15 fps to ~25 fps
// 5) GS_SHADER doesn't work after last changes (get link error for program GL_INVALID_ENUM) (FIXED)
//    - fixed by changing "varying in vec4 Normal_G[1]" etc. to "varying in vec4 Normal_G[]" etc.
// 6) multiple plants don't stack if "+" used to connect
//    - Preceding plant loses last branch
//    - works OK without "+" connection
// 7) problems with normals 
//   - normal hack doesn't work unless light direction is some range of values (FIXED)
//   - get some illumination on one side of branches during night (FIXED)
//     o multiplied intensity by horizon band (time of day)
//   - need to lighten dark side of branches (during day time only)


//************************************************************
// classes PlantPoint, PlantMgr
//************************************************************
extern double Hscale, Drop, MaxSize,Height,Phi,Density,Randval;
extern double ptable[];
extern Point MapPt;
extern double  zslope();
extern NameList<LongSym*> POpts;

extern void inc_tabs();
extern void dec_tabs();
extern char   tabs[];
extern int addtabs;

static int draw_count;

extern int test3;
static double sval=0;
static double cval=0;
static double mind=0;
static double htval=0;
static int ncalls=0;
static int nhits=0;

static double roff_value=1e-6;//0.5*PI;
static double roff2_value=0.5;
static double ht_offset=0.0;
static double threshold=1;
static int cnt=0;
static int tests=0;
static int pts_fails=0;
static int dns_fails=0;

static TerrainData Td;
static PlantMgr *s_mgr=0;
static int hits=0;
static int branch_nodes;
static int trunk_nodes;
static int line_nodes;

static double min_draw_width=1;
static double min_render_pts=1; // for render
static double min_adapt_pts=3; //  for adapt - increase resolution only around nearby plants

#define USE_AVEHT
#define MIN_VISITS 1
#define TEST_NEIGHBORS 1
//#define TEST_PTS 
//#define DUMP
//#define SHOW
//#define DEBUG_PMEM


#define MIN_DRAW_WIDTH min_draw_width // varies with scene quality
#define MIN_LINE_WIDTH MIN_DRAW_WIDTH
#define MIN_TRIANGLE_WIDTH 2*MIN_DRAW_WIDTH

#ifdef DUMP
static void show_stats()
{
	if(s_mgr)
		s_mgr->dump();
	cout<<"calls="<<ncalls<< " hits="<<nhits<<endl;
}
#endif

static int randval=0;
class SData {
public:
    double v;
    double f;
    double value()   { return v;}
};
#define SDATA_SIZE 1024
static SData   sdata[SDATA_SIZE];
static ValueList<SData*> slist(sdata,SDATA_SIZE);
static int          scnt;

//************************************************************
// PlantMgr class
//************************************************************
//	arg[0]  levels   		scale levels
//	arg[1]  maxsize			size of largest craters
//	arg[2]  mult			size multiplier per level
//	arg[3]  density			density or dexpr
//
//-------------------------------------------------------------
PlantMgr::PlantMgr(int i,TNplant *p) : PlacementMgr(i,2*PERMSIZE)
{
#ifdef DUMP
	if(!s_mgr)
		add_finisher(show_stats);
#endif
	type|=SPRITES;
	plant=p;
	s_mgr=this;
	roff=roff_value;
	roff2=roff2_value;
	level_mult=0.2;
	slope_bias=0;
	ht_bias=0;
	lat_bias=0;
	dexpr=0;
	instance=0;

	set_ntest(TEST_NEIGHBORS);
}
PlantMgr::~PlantMgr()
{
  	if(finalizer()){
  		s_mgr=0;
#ifdef DEBUG_PMEM
  		printf("PlantMgr::free()\n");
#endif
	}
}

//-------------------------------------------------------------
// PlantMgr::init()	initialize global objects
//-------------------------------------------------------------
void PlantMgr::init()
{
#ifdef DEBUG_PMEM
  	printf("PlantMgr::init()\n");
#endif
	PlacementMgr::init();
	ncalls=0;
	nhits=0;
	cnt=0;
	ss();
  	reset();
 }

void PlantMgr::eval(){	
	PlacementMgr::eval(); 
	if(!first() || !scnt)
	    return;
	for(int i=0;i<scnt;i++){
	    slist.base[i]=sdata+i;
	}
	slist.size=scnt;
	slist.sort();
	
	for(int i=0;i<scnt;i++){
	   double f=slist.base[i]->f;
	   cval=f;
	}
}

void PlantMgr::reset(){
	PlacementMgr::reset();
	tests=pts_fails=dns_fails=0;
	cval=0;
	scnt=0;
}
//-------------------------------------------------------------
// PlantPoint::set_terrain()	impact terrain
//-------------------------------------------------------------
bool PlantMgr::valid()
{ 
    tests++;
   
#ifdef TEST_PTS
	double mps=min_render_pts;
	if(TheScene->adapt_mode())
		mps=min_adapt_pts;
	Point pv=MapPt;
	double d=pv.length();
	
	double r=TheMap->radius*size;
	double f=TheScene->wscale*r/d;
    double pts=f;
    if(pts<mps){
    	pts_fails++;
    	return false;
    }
#endif  
    // TODO set density biases here ?

    if(density<=0){
    	dns_fails++;
    	return false;
    }
	return true;
}

bool PlantMgr::setProgram(){
	
	//GLSLMgr::checkForErrors();
	TerrainProperties *tp=Td.tp;
	
	TNplant::textures=0;
	
	for(int i=0;i<tp->plants.size;i++){
		tp->plants[i]->setProgram();
	}

	branch_nodes=0;
	trunk_nodes=0;
	line_nodes=0;
	
	double twilite_min=-0.2; // full night
	double twilite_max=0.2;  // full day
	
	char defs[1024]="";
	sprintf(defs+strlen(defs),"#define NTEXS %d\n",TNplant::textures);
	if(TNplant::textures>0 && Render.bumps())
		sprintf(defs+strlen(defs),"#define BUMPS\n",TNplant::textures);

	sprintf(defs+strlen(defs),"#define NLIGHTS %d\n",Lights.size);
	if(Render.haze())
		sprintf(defs+strlen(defs),"#define HAZE\n");

    bool do_shadows=Raster.shadows() && (Raster.twilight() || Raster.night());
	if(do_shadows && !TheScene->light_view()&& !TheScene->test_view() &&(Raster.farview()))
		sprintf(defs+strlen(defs),"#define SHADOWS\n");

	GLSLMgr::setDefString(defs);

	GLSLMgr::input_type=GL_LINES;
	GLSLMgr::output_type=GL_TRIANGLE_STRIP;
	GLSLMgr::tesslevel=0;
	//GLSLMgr::max_output=4;  // special case
	GLSLMgr::loadProgram("plants.gs.vert","plants.frag","plants.geom");
	
	GLhandleARB program=GLSLMgr::programHandle();
	if(!program){
		cout<<"PlantMgr::setProgram - failed to load program"<<endl;
		return false;
	}

	GLSLVarMgr vars;
	
	Planetoid *orb=(Planetoid*)TheScene->viewobj;
	
	Color diffuse=orb->diffuse;
	Color ambient=orb->ambient;
	Color shadow=orb->shadow_color;
	Color haze=Raster.haze_color;
	
	vars.newFloatVec("Diffuse",diffuse.red(),diffuse.green(),diffuse.blue(),diffuse.alpha());
	vars.newFloatVec("Ambient",ambient.red(),ambient.green(),ambient.blue(),ambient.alpha());
	vars.newFloatVec("Shadow",shadow.red(),shadow.green(),shadow.blue(),shadow.alpha());
	vars.newFloatVec("Haze",haze.red(),haze.green(),haze.blue(),haze.alpha());
	vars.newFloatVar("haze_zfar",Raster.haze_zfar);
	vars.newFloatVar("haze_grad",Raster.haze_grad);
	vars.newFloatVar("haze_ampl",Raster.haze_hf);
	vars.newFloatVar("bump_delta",1e-3);
	vars.newFloatVar("bump_ampl",0.05);
	vars.newFloatVar("twilite_min",twilite_min);
	vars.newFloatVar("twilite_max",twilite_max);

	vars.newBoolVar("lighting",Render.lighting());
	
	double zn=TheScene->znear;
	double zf=TheScene->zfar;
	double ws1=1/zn;
	double ws2=(zn-zf)/zf/zn;

	vars.newFloatVar("ws1",ws1);
	vars.newFloatVar("ws2",ws2);

	vars.setProgram(program);
	
	vars.loadVars();

	GLSLMgr::setProgram();
	GLSLMgr::loadVars();
		
	int n=Plant::plants.size;
	int l=randval;
	
	switch(TheScene->quality){
	case DRAFT:
		min_draw_width=1;
		break;
	case NORMAL:
		min_draw_width=0.65;
		break;
	case HIGH:
		min_draw_width=0.5;
		break;
	case BEST:
		min_draw_width=0.25;
		break;	
	}
	
	glEnable(GL_BLEND);
	//TNplant::clearStats();

	for(int i=n-1;i>=0;i--){ // Farthest to closest
		PlantData *s=Plant::plants[i];
		
		int id=s->get_id();
		
		TNplant *plant=s->mgr->plant;
		//cout<<plant->size<<" "<<plant->size*plant->base_drop<<endl;
		plant->size=s->radius; // placement size
		plant->base_point=s->base*(1-plant->size*plant->base_drop);
		plant->pntsize=s->pntsize;
		
		Point pp=Point(s->point.x,s->point.y,s->point.x);
		
		double r=Random(pp);
		randval=256*r+id;
		plant->emit();
	}
	randval=l;
#ifdef SHOW_BRANCH_STATS
	for(int i=0;i<tp->plants.size;i++){
		tp->plants[i]->showStats();
	}
#endif

	return true;
}
//-------------------------------------------------------------
// PlantMgr::make() factory method to make Placement
//-------------------------------------------------------------
Placement *PlantMgr::make(Point4DL &p, int n)
{
    return new PlantPoint(*this,p,n);
}

//************************************************************
// class PlantPoint
//************************************************************
PlantPoint::PlantPoint(PlantMgr&m, Point4DL&p,int n) : Placement(m,p,n)
{
	ht=0;
	aveht=0;
	wtsum=0;
	dist=1e16;
	visits=0;
	place_hits=0;
	mind=1e16;
	mgr=&m;
	
	instance=m.instance;

	flags.s.active=false;
}

//-------------------------------------------------------------
// PlantPoint::set_terrain()	impact terrain
//-------------------------------------------------------------
bool PlantPoint::set_terrain(PlacementMgr &pmgr)
{
	double d=pmgr.mpt.distance(center);
	d=d/radius;
	PlantMgr &mgr=(PlantMgr&)pmgr;
	sval=0;
	visits++;
	
	if(d>threshold)
		return false;

    flags.s.active=true;
	sval=lerp(d,0,threshold,0,1);

    double wt=1/(0.01+sval);
    aveht+=Height*wt;
	
    wtsum+=wt;

	if(d<dist){
		ht=Height;
		dist=d;
		mind=d;
		place_hits++;
	}
	hits++;

 	sdata[scnt].v=hid;
   	sdata[scnt].f=sval;
  	if(scnt<SDATA_SIZE)
  	    scnt++;
	return true;
}

void PlantPoint::reset(){
	flags.s.active=0;
	visits=0;
	place_hits=0;
	dist=1e6;
	aveht=0;
	wtsum=0;
}
void PlantPoint::dump(){
	if(flags.s.valid && flags.s.active){
		Point4D p(point);
		p=center;
		char msg[256];
		char vh[32];
		sprintf(vh,"%d:%d",visits,place_hits);
		sprintf(msg,"%-3d %-2d %-8s dist:%-0.4f ht:%-1.6f x:%-1.5f y:%-1.5f z:%1.5f",cnt++,flags.l,vh,dist,ht,p.x,p.y,p.z);
		cout<<msg<<endl;
	}
}
//==================== PlantData ===============================
PlantData::PlantData(PlantPoint *pnt,Point bp,double d, double ps){
	type=pnt->type;
	ht=pnt->ht;
	
	point=pnt->point;
	
	aveht=pnt->aveht/pnt->wtsum;
	base=bp;
	
	radius=pnt->radius;
    pntsize=ps;
 	distance=d;//TheScene->vpoint.distance(t);
	visits=pnt->visits;
	instance=pnt->instance;
	mgr=pnt->mgr;
}

void PlantData::print(){
	char msg[256];
	Point pp=Point(point.x,point.y,point.z);
	double h=TheMap->radius*TheMap->hscale;
	sprintf(msg,"visits:%-1d ht:%-1.4f aveht:%-1.4f dist:%g",visits,h*ht/FEET,h*aveht/FEET,distance/FEET);
	cout<<msg<<endl;
	
}
//===================== Plant ==============================
ValueList<PlantData*> Plant::plants;
//-------------------------------------------------------------
// Plant::Plant() Constructor
//-------------------------------------------------------------
Plant::Plant(int l, TNode *e)
{
	type=l;
	plant_id=get_id();
	expr=e;
	valid=false;
}

void Plant::reset()
{
	plants.free();
	TNplant::textures=0;

	TerrainProperties *tp=Td.tp;
	for(int i=0;i<tp->plants.size;i++){
		Plant *plant=tp->plants[i];
		plant->mgr()->free_htable();
	}
}

//-------------------------------------------------------------
// Plant::collect() collect valid plant points
//-------------------------------------------------------------
void Plant::collect()
{
	
#ifdef TEST_PTS
	if(tests>0)
		cout<<"tests:"<<tests<<" fails  pts:"<<100.0*pts_fails/tests<<" %"<<" dns:"<<100.0*dns_fails/tests<<endl;
#endif
	int new_plants=0;
	int bad_pts=0;
#ifdef SHOW_STATS	
	int trys=0;
	int visits=0;
	int bad_visits=0;
	int bad_valid=0;
	int bad_active=0;
#endif	

	TerrainProperties *tp=Td.tp;
	for(int i=0;i<tp->plants.size;i++){
#ifdef SHOW_STATS	
		trys=visits=bad_visits=bad_valid=bad_active=bad_pts=new_plants=0;
#endif
		Plant *plant=tp->plants[i];
		plant->mgr()->ss();
		PlantPoint *s=(PlantPoint*)plant->mgr()->next();
	while(s){
#ifdef SHOW_STATS
		trys++;		
		if(s->visits<MIN_VISITS)
			bad_visits++;
		if(!s->flags.s.valid)
			bad_valid++;
		if(!s->flags.s.active)
			bad_active++;
#endif	
		if(s->visits>=1 && s->flags.s.valid && s->flags.s.active){
			Point4D	p(s->center);
			Point pp=Point(p.x,p.y,p.z);
			Point ps=pp.spherical();
#ifdef USE_AVEHT
			double ht=s->aveht/s->wtsum;
#else
			double ht=s->ht;
#endif			
			Point base=TheMap->point(ps.x, ps.y,ht+s->radius*ht_offset/TheMap->radius); // spherical-to-rectangular
			Point bp=Point(-base.x,base.y,-base.z);  // Point.rectangular has 180 rotation around y
			double d=bp.distance(TheScene->vpoint);  // distance	
			double r=TheMap->radius*s->radius;
			double f=TheScene->wscale*r/d;
		    double pts=f;
		    double minv=MIN_VISITS; 
		    bool pts_test=true;
#ifdef TEST_PTS
		    minv=lerp(pts,min_render_pts,10*min_render_pts,1,2*MIN_VISITS); 
		    if(pts<min_render_pts){
		    	pts_test=false;
		    	bad_pts++;
		    }
#endif
		    if(pts_test && s->visits>=minv){
		    	new_plants++;
		    	plants.add(new PlantData((PlantPoint*)s,bp,d,pts));
		    }
		}
		s=plant->mgr()->next();
	  }	
#ifdef SHOW_STATS
	double usage=100.0*trys/plant->mgr()->hashsize;
	double badvis=100.0*bad_visits/trys;
	double badactive=100.0*bad_active/trys;
	double badpts=100.0*bad_pts/trys;
	cout<<plant->name()<<" plants "<<new_plants<<" tests:"<<trys<<" %hash:"<<usage<<" %inactive:"<<badactive<<" %small:"<<badpts<<" %visited:"<<100-badvis<<endl;
#endif

	} // next plant
	//}
    cout<<"total plants collected:"<<plants.size<<endl;
	plants.sort();
#ifdef SHOW
	//int pnrt_num=plants.size-1;
	int pnrt_num=min(2,plants.size-1);

	for(int i=pnrt_num;i>=0;i--){
		cout<<i<<" ";
		plants[i]->print();	
	}
#endif
	
}
//-------------------------------------------------------------
// Plant::eval() evaluate TNtexture string
//-------------------------------------------------------------
void Plant::eval()
{
	int mode=CurrentScope->passmode();
	CurrentScope->set_spass();
	expr->eval(); // TNplant.eval()
	CurrentScope->set_passmode(mode);
}

bool Plant::setProgram(){
	clearStats();
	return expr->setProgram();
}
bool Plant::initProgram(){
	return false;
}
void Plant::clearStats(){
	expr->clearStats();
}
void Plant::showStats(){
	expr->showStats();
}

//===================== TNplant ==============================
int TNplant::textures=0;
double TNplant::norm_max=2;
double TNplant::norm_min=1e-5;
//************************************************************
// TNplant class
//************************************************************
TNplant::TNplant(TNode *l, TNode *r) : TNplacements(0,l,r,0)
{
	TNarg *arg=left;
	TNarg *node=arg->left;
	if(node->typeValue() == ID_STRING){		
		setName(((TNstring*)node)->value);
		left=arg->next();
		left->setParent(this);
		arg->right=0;
		delete arg;	
	}
	plant=0;
	branches=0;
	pntsize=0;
	maxdensity=0;
	max_levels=0;
	radius=0;
	size=0;
	plant_id=0;
	branch=0;
	leaf=0;
	base_drop=0;
	width_scale=1;
	
    mgr=new PlantMgr(PLANTS|NOLOD,this);
}

//-------------------------------------------------------------
// TNplant::~TNplant() destructor
//-------------------------------------------------------------
TNplant::~TNplant()
{
	DFREE(plant);
}

//-------------------------------------------------------------
// TNplant::applyExpr() apply expr value
//-------------------------------------------------------------
void TNplant::applyExpr()
{
   if(expr){
	    TNplant* sprt=(TNplant*)expr;
	    mgr->type=type;
		DFREE(left);
		left=expr->left;
		left->setParent(this);
		expr=0;
	}
	if(right)
		right->applyExpr();
 }
//-------------------------------------------------------------
// TNplant::init() initialize the node
//-------------------------------------------------------------
void TNplant::init()
{
	PlantMgr *smgr=(PlantMgr*)mgr;
    branches=0;
	if(plant==0)
		plant=new Plant(type,this);
	smgr->set_first(1);
	//smgr->setHashsize(2*PERMSIZE);
	smgr->init();
	
	//TNplacements::init();
	double arg[11];
	INIT;
	TNarg &args=*((TNarg *)left);
	int n=getargs(&args,arg,11);
	
	if(n>0) max_levels=(int)arg[0]; 	// branch levels
	if(n>1) mgr->levels=(int)arg[1]; 	// scale levels
	if(n>2) mgr->maxsize=arg[2];     	// size of largest 
	if(n>3) mgr->mult=arg[3];			// random scale multiplier
	if(n>4) mgr->level_mult=arg[4];     // scale multiplier per level
	if(n>5) maxdensity=arg[5];
	if(n>6) smgr->slope_bias=arg[6];
	if(n>7) smgr->ht_bias=arg[7];
	if(n>8) smgr->lat_bias=arg[8];
	if(n>9) base_drop=arg[9];

	if(right)
	   right->init();
	getLeaf();
}

void TNplant::getLeaf() {
	TNBranch *p = (TNBranch*)right;
	while (p && p->typeValue() != ID_LEAF) {
		p=p->right;
	}
	if(p && p->typeValue() == ID_LEAF)
		leaf=(TNLeaf*)p;
	
}
void TNplant::set_id(int i){
	BIT_OFF(type,PID);
	type|=i&PID;
}
//-------------------------------------------------------------
// TNplant::eval() evaluate the node
//-------------------------------------------------------------
void TNplant::eval()
{	
	SINIT;
	if(right)
		right->eval();
	if(!isEnabled()){
		return;
	}
	if(CurrentScope->rpass()){
		int size=Td.tp->plants.size;
		plant_id=size;	
		mgr->instance=plant_id;
		if(plant)
			plant->set_id(size);		
		Td.add_plant(plant);		
		return;
	}	
	if(!CurrentScope->spass()){
		return;
	}
	Color c =Color(1,1,1);
	PlantMgr *smgr=(PlantMgr*)mgr;

	htval=Height;
	ncalls++;
	
	double density=maxdensity;
	MaxSize=mgr->maxsize;
	radius=TheMap->radius;
	TerrainProperties *tp=TerrainData::tp;
		
	mgr->type=type;
	if(smgr->slope_bias){
		double slope=8*zslope();
		double f=2*lerp(fabs(smgr->slope_bias)*slope,0,1,-smgr->slope_bias,smgr->slope_bias);
#ifdef DEBUG_SLOPE_BIAS
		if(ncalls%100==0)
			cout<<"slope:"<<slope<<" f:"<<f<<endl;
#endif
		density+=f;
	}
	if(smgr->ht_bias){
		double f=2*lerp(8*fabs(smgr->ht_bias)*Height,-1,1,-smgr->ht_bias,smgr->ht_bias);
		density+=f;
	}
	if(smgr->lat_bias){
		double f=lerp(fabs(smgr->lat_bias)*fabs(2*Phi/180),0,1,-smgr->lat_bias,+smgr->lat_bias);
		density+=f;
	}
    density*=maxdensity;
	density=clamp(density,0,1);
	density=sqrt(density);

	mgr->density=density;
	double hashcode=(mgr->levels+
		            1/mgr->maxsize
					+11*tp->id
					+7*plant_id
					);
	mgr->id=(int)hashcode+mgr->type+PLANTS+hashcode*TheNoise.rseed;
	
	sval=0;
	hits=0;
	cval=0;
	scnt=0;

	smgr->eval();  // calls PlantPoint.set_terrain
   
	if(hits>0){ // inside target radius
		nhits++;
		double x=1-cval;
#ifdef COLOR_TEST
//		if(instance==0)
//			c=Color(x,0,1);
//		else
			c=Color(0,x,1);
		Td.diffuse=Td.diffuse.mix(c,0.9);
#endif
#ifdef DENSITY_TEST
		x=1/(cval+1e-6);
		x=x*x;//*x*x;
		Td.density+=lerp(cval,0,0.2,0,0.05*x);
#endif
	}
 }

void TNplant::clearStats(){
	for(int i=0;i<MAX_BRANCHES;i++){
		for(int j=0;j<5;j++)
			stats[i][j]=0;
	}
}
void TNplant::showStats(){
	for(int i=0;i<branches;i++){
		cout<<"plant["<<name_str<<"] branch["<<i<<"] polygons:"<<stats[i][0]
	    <<" lines:"<<stats[i][1]
		<<" terminals:"<<stats[i][2]
		<<" skipped:"<<stats[i][3]
		<<" leafs:"<<stats[i][4]
		<<endl;
	}
}
void TNplant::addLine(int id){
	stats[id][1]++;	
}
void TNplant::addBranch(int id){
	stats[id][0]++;	
}
void TNplant::addTerminal(int id){
	stats[id][2]++;	
}
void TNplant::addSkipped(int id){
	stats[id][3]++;	
}
void TNplant::addLeaf(int id){
	stats[id][4]++;	
}
//-------------------------------------------------------------
// TNtexture::valueString() node value substring
//-------------------------------------------------------------
void TNplant::valueString(char *s)
{
	if(strlen(name_str)>0)
		sprintf(s+strlen(s),"%s(\"%s\",",symbol(),name_str);
	else
		sprintf(s+strlen(s),"%s(",symbol());

	TNarg *arg=(TNarg*)left;
	while(arg){
		arg->valueString(s+strlen(s));
		arg=arg->next();
		if(arg)
			strcat(s,",");
	}
	strcat(s,")");
}

//-------------------------------------------------------------
// TNplant::save() archive the node
//-------------------------------------------------------------
void TNplant::save(FILE *f)
{
	char buff[1024];
	buff[0]=0;
	valueString(buff);
	//if(addtabs)
	    fprintf(f,"\n%s",tabs);
	fprintf(f,"%s",buff);
	if(right)
		right->save(f);
}

//-------------------------------------------------------------
// TNplant::save() archive the node
//-------------------------------------------------------------
void TNplant::saveNode(FILE *f)
{
	char buff[1024];
	buff[0]=0;
	valueString(buff);
	//if(addtabs)
	    fprintf(f,"\n%s",tabs);
	fprintf(f,"%s",buff);
}

void TNplant::emit(){
	lastn=randval;
	Randval=URAND(lastn);
	
	double length=size*base_point.length();	
	Point bot=base_point;
	norm=bot.normalize();
	glNormal3dv(norm.values());
			
	TNBRANCH *first_branch=(TNBRANCH*)right;
	if(right && right->typeValue() == ID_BRANCH) 
		first_branch=(TNBRANCH*)right;
	else
		return;
	double branch_size=length*first_branch->length;

	Point top=bot*(1+branch_size); // starting trunk size
	Point p1=bot;
	Point p2=top;
	
	double width=width_scale*pntsize;
	
	Point tip;
	tip.x=width/TheScene->wscale;
	tip.y=0;
	glDisable(GL_CULL_FACE);
	
	glVertexAttrib4d(GLSLMgr::TexCoordsID, 0, 0, 0,0); // Constants1
	
	first_branch->fork(FIRST_FORK,p1,p2-p1,tip,length,width,0);
	
}

bool TNplant::setProgram(){
	// compensate for changes in scene fov and aspect to keep ht/width constant	
	width_scale=0.834729*TheScene->wscale/TheScene->aspect/TheScene->viewport[3];

	TNBRANCH *first_branch=(TNBRANCH*)right;
	if(right && right->typeValue() == ID_BRANCH) 
		first_branch=(TNBRANCH*)right;
	else
		return false;
	TNBRANCH *branch=first_branch;
	while(branch && branch->typeValue() == ID_BRANCH){
		branch->setProgram();
		branch=branch->right;
	}
	return true;
}

//===================== TNBranch ==============================
//************************************************************
// TNBranch class
//************************************************************

TNBranch::TNBranch(TNode *l, TNode *r, TNode *b) : TNbase(0,l,b,r)
{
	set_collapsed();
	TNarg *arg=left;
	TNarg *node=arg->left;
	if(node->typeValue() == ID_STRING){		
		setName(((TNstring*)node)->value);
		left=arg->next();
		if(left)
			left->setParent(this);
		arg->right=0;
		delete arg;	
	}
	max_plant_levels=0;
	maxlvl=0;
	branch_id=0;
	length=2;
	width_taper=0.75;
	length_taper=0.95;
	randomness=0.25;
	max_splits=4;
	first_bias=0;
	flatness=0.9;
	divergence=0.75;
	min_level=0;
	max_level=0;
	root=0;
	image=0;
	texname[0]=0;
	texture_id=0;
	texid=-1;
	instance=0;
	color_flags=0;
}

void TNBranch::init(){
	double arg[12];
	if(!left)
		return;
	INIT;
	TNarg &args=*((TNarg *)left);
	int n=getargs(&args,arg,11);
	if(n>0)max_splits=arg[0];
	if(n>1)length=arg[1];
	if(n>2)randomness=arg[2];
	if(n>3)divergence=arg[3];
	if(n>4)flatness=arg[4];
	if(n>5)width_taper=arg[5];
	if(n>6)length_taper=arg[6];	
	if(n>7)first_bias=arg[7];
	if(n>8)min_level=arg[8];
	if(n>9)max_level=arg[9];
	
	root=getRoot();
	max_plant_levels=root->max_levels;
	branch_id=root->branches;
	root->branches+=1;
	setTexture();
	setColorFlags();
	//cout<<"plant:"<<root->nodeName()<<" branch:"<<nodeName()<<" texid:"<<texid<<" color_flags:"<<color_flags<<endl;
	
	if(right)
		right->init();
}

void TNBranch::invalidateTexture(){
	if(texture_id){
		glDeleteTextures(1,&texture_id);
		texture_id=0;
	}
}
bool TNBranch::setProgram(){
	if(!image || !image->valid()){
		return false;
	}	
	texid=root->textures++;
	char str[MAXSTR];
	glActiveTexture(GL_TEXTURE0+texid);
	if(texture_id==0){
		bool rgba_image=(image->gltype()==GL_RGBA)?true:false;
		bool alpha_image=image->alpha_image();
		cout<<"rgba_image="<<rgba_image<<" alpha_image="<<alpha_image<<endl;

		glGenTextures(1, &texture_id); // Generate a unique texture ID
		cout<<"generating texture id="<<texture_id<<endl;
		glBindTexture(GL_TEXTURE_2D, texture_id);
		glTexEnvf(GL_TEXTURE_FILTER_CONTROL, GL_TEXTURE_LOD_BIAS, -1);
		glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		int w=image->width;
		int h=image->height;
		unsigned char* pixels=(unsigned char*)image->data;
		if(alpha_image || rgba_image)
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
		else
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);		
	}
	glBindTexture(GL_TEXTURE_2D, texture_id);
	GLhandleARB program=GLSLMgr::programHandle();
	sprintf(str,"samplers2d[%d]",texid);  
	glUniform1iARB(glGetUniformLocationARB(program,str),texid);
	//cout<<"branch::setProgram "<<root->nodeName()<<" branch:"<<branch_id<<" texid:"<< texid<<" image:"<<texname<<" texture_id:" <<texture_id<<endl;
		
	return true;	
}

//-------------------------------------------------------------
// TNBranch::setImage(char *name) set image texture
//-------------------------------------------------------------
void TNBranch::setImage(char *name){
	if(strcmp(name,texname)){
		if(image)
			delete image;
		invalidateTexture();
		strcpy(texname,name);				
		image=images.load(texname,JPG|BMP);
		if(image)
			cout<<"image created for "<<texname<<endl;
		else
			cout<<"image file "<<texname<<" not found"<<endl;
	}
}

void TNBranch::setTexture(){
	if(base){
		TNarg *arg=((TNarg *)base);
		while(arg){
			TNode *node=arg->left;
			if(node->typeValue()==ID_STRING){
				setImage(((TNstring*)node)->value);
				if(image){
					texid=root->textures;
					root->textures++;
				}
				return;
			}			
			arg=arg->next();
		}
	}
}
void TNBranch::setColorFlags(){
	TNarg *arg;
	color_flags=0;
	Density=0;
	if(base){
		arg=(TNarg*)base;
		while(arg){
			if(arg->left->typeValue()==ID_COLOR){		
				color_flags=1;
				int comps=((TNcolor*)arg->left)->comps();
				if(comps==4)
					color_flags=2;
				return;
			}
			arg=arg->next();
		}
	}
}
void TNBranch::setColor(){
	TNarg *arg;
	if(base && color_flags){
		arg=(TNarg*)base;
		while(arg){
			S0.clr_cvalid();
			arg->left->eval();
			if(S0.cvalid()){
				glColor4d(S0.c.red(), S0.c.green(), S0.c.blue(), S0.c.alpha());
			}
			arg=arg->next();
		}
	}
}
void TNBranch::fork(int opt, Point start, Point vec,Point tip,double size, double width, int lvl){
	if(lvl<min_level)
		return;
	maxlvl=(max_level>0&&max_level<max_plant_levels)?max_level:max_plant_levels;
	
    if(lvl>maxlvl)
    	return;
    
    int l=randval;
    
	double splits=max_splits*(1+0.5*randomness*SRAND(randval));
	if(first_bias) // add more branches at start of new branch fork
		splits*=first_bias;
	splits=splits<1?1:splits;
	for(int i=0;i<splits;i++){
		emit(opt,start,vec,tip,size,width,lvl);
	}
	randval=l;
}

Point TNBranch::setVector(Point vec, Point start){

	Point v = vec.normalize();
	
	v.x += divergence * SRAND(randval);
	v.y += divergence * SRAND(randval);
	v.z += divergence * SRAND(randval);

	v = v.normalize();

	if (flatness > 0) {
		Point n = root->norm + start;
		n = n.normalize();
		Point tp1 = n.cross(v);
		Point vp = tp1.cross(n);
		double f = flatness;
		vp = vp.normalize(); // projection of v along surface
		Point v1 = v * (1 - f);
		Point v2 = vp * f;
		v = v1 + v2;
	}
	return v;

}

void TNBranch::emit(int opt, Point svec, Point vec, Point tip, double size,
		double width, int lvl) {
	if (lvl < min_level)
		return;
	if (lvl > maxlvl)
		return;
	
	int lev = lvl;
	lev++;
	
	int mode = opt;
	
	bool first_fork = (opt & FIRST_FORK);
	bool first_emit = (opt & FIRST_EMIT);
	double topx = 0;
	double topy = 0;
	double botx = 1;
	double boty = 1;
	Point v, p1, p2, bot;
	Color c;
	bool terminal = branch_id == root->branches - 1;
	int splits = max_splits * (1 + 0.5 * randomness * SRAND(randval));
	
	splits = splits >= 1 ? splits : 1;
	double size_scale = 1.0;
	double parent_width=width;
	double child_width=width;
	if (first_fork && lvl > 0) {
		double parent_length=size * TheScene->wscale* root->width_scale/root->size;
		size_scale = length / parent_length;
		//cout<<branch_id<<" "<<size_scale<<endl;
		size_scale = size_scale > 1 ? 1 : size_scale;
		size_scale = size_scale < 0 ? 0 : size_scale;
		child_width*=size_scale;

		//width *= size_scale;
	}
	
	if (child_width < MIN_DRAW_WIDTH) {
		root->addSkipped(branch_id);
		return;
	} 
	
	Point start=svec;
	Density = ((double) lvl) / maxlvl;
	// add a random offset to each branch split
	double rb = randomness > 1 ? 1 : randomness;
	double b = rb * URAND(randval);
	if (!first_emit && lvl > 0) { // keep at least one child branch at end of parent
		b = b <= 1 ? b : 1;
		start = svec - vec * b;
	}
	v=setVector(vec,start);
	
	size *= 1 + 0.25 * randomness * SRAND(randval);
	v = v * size * length; // v = direction along last branch

	p2 = start + v; //new top
	bot = p2; // new base	

	p2 = p2 - TheScene->vpoint;
	p1 = start - TheScene->vpoint;

	v = bot - start; // new vector

	if (width > MIN_TRIANGLE_WIDTH) {
		root->addBranch(branch_id);
		setColor();
		if (width * width_taper < MIN_LINE_WIDTH || lev > maxlvl) {
			Density = 1;
			mode |= LAST_EMIT;
			root->addTerminal(branch_id);
		}
		// calculate (fake) width perpendicular to branch vector
		// TODO move this to shader ?
		Point q = TheScene->project(v); // convert model to screen space
		double a = atan2(q.y / q.z, q.x / q.z);
		double x = -sin(a);
		double y = cos(a);
	
		double off = child_width / TheScene->wscale;
		
		double f=URAND(randval);
	
		// decrease width at end of vector
		topx = x * off * width_taper;// * size_scale;
		topy = y * off * width_taper;// * size_scale;
	
		botx = tip.x * size_scale;
		boty = tip.y * size_scale;
	
		// fix billboard gap in sequential levels
		//  - set bottom offsets for next level to = top offsets for previous level
		tip.x = topx;
		tip.y = topy;
		double nscale=lerp(width,MIN_TRIANGLE_WIDTH,10*MIN_TRIANGLE_WIDTH,TNplant::norm_min,TNplant::norm_max);
		glVertexAttrib4d(GLSLMgr::CommonID1, topx, topy, botx, boty); // Constants1		
		glVertexAttrib4d(GLSLMgr::TexCoordsID, nscale, color_flags, texid, 0); // Constants1

		if (test3) { // @ key - draw lines
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
			glLineWidth(2);
		}

		glBegin(GL_LINES);
		glVertex4d(p1.x, p1.y, p1.z, 1);
		glVertex4d(p2.x, p2.y, p2.z, 2);
		glEnd();
		if (test3)  // @ key - draw lines
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		
	} else if (width >= MIN_LINE_WIDTH) {
		root->addLine(branch_id);
		Density = 1;
		setColor();
		if (width * width_taper < MIN_LINE_WIDTH || lev > maxlvl) {
			root->addTerminal(branch_id);
			mode |= LAST_EMIT;
		}
		glVertexAttrib4d(GLSLMgr::CommonID1, 0, 0, 0, 0); // Constants1
		glVertexAttrib4d(GLSLMgr::TexCoordsID, TNplant::norm_min, color_flags, texid,
				LINE_MODE); // Constants1

		glLineWidth(MIN_LINE_WIDTH);
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

		glBegin(GL_LINES);
		glVertex4d(p1.x, p1.y, p1.z, 0);
		glVertex4d(p2.x, p2.y, p2.z, 0);
		glEnd();	
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);	
	}	
	if (mode & LAST_EMIT) {
		if (root->leaf && root->leaf != this)
			root->leaf->fork(FIRST_FORK, bot, v, tip, size, width, lev-1);
		return;
	}
	width = child_width*width_taper;
	size *= length_taper;
	emit(FIRST_EMIT, bot, v, tip, size, width, lev);
	for (int i = 1; i < splits; i++) {
		emit(0, bot, v, tip, size, width, lev);
	}
	if (right && right->typeValue() == ID_BRANCH) {
		TNBranch *child = (TNBranch*) right;
		child->fork(FIRST_FORK, bot, v, tip, size, width, lev);
	}
}

TNplant* TNBranch::getRoot() {
	NodeIF *p = getParent();
	while (p && p->typeValue() != ID_PLANT) {
		p=p->getParent();
	}
	if(p && p->typeValue() == ID_PLANT)
		return p;
	return 0;
}
void TNBranch::valueString(char *s){
	if(strlen(name_str)>0)
		sprintf(s+strlen(s),"%s(\"%s\",",symbol(),name_str);
	else
		sprintf(s+strlen(s),"%s(",symbol());
	TNbase::valueString(s);
}
void TNBranch::save(FILE *f){
	fprintf(f,"\n%s",tabs);
	if(strlen(name_str)>0)
		fprintf(f,"%s(\"%s\"",symbol(),name_str);
	else
		fprintf(f,"%s(",symbol());
	if(left){
		fprintf(f,",");
		left->save(f);
	}
	fprintf(f,")");
	if(base){
		fprintf(f,"[");
		base->save(f);
		fprintf(f,"]");
	}
	if(right)
		right->save(f);
}
void TNBranch::saveNode(FILE *f){
	TNbase::saveNode(f);
}
void TNBranch::eval(){
	if(right)
		right->eval();
}
void TNBranch::getTexDir(char*dir){
	char base[256];
	char dimdir[32];
  	File.getBaseDirectory(base);
 	sprintf(dir,"%s/Textures/Plants/Branch",base);
}
//===================== TNleaf ==============================
//************************************************************
// TNLeaf class
//************************************************************
TNLeaf::TNLeaf(TNode *l, TNode *r, TNode *b) : TNBranch(l,r,b){
	
}

void TNLeaf::emit(int opt, Point start, Point vec, Point tip, double size,
		double width, int lvl) {
	Point v=setVector(vec,start);
	size *= 1 + 0.25 * randomness * SRAND(randval);
	v = v * size * length; // v = direction along last branch

	Point p1 = start - TheScene->vpoint;
	Point p2 = start + v- TheScene->vpoint; //new top

	root->addLine(branch_id);
	Density = 1;
	setColor();
	root->addLeaf(branch_id);

	glVertexAttrib4d(GLSLMgr::CommonID1, 0, 0, 0, 0); // Constants1
	glVertexAttrib4d(GLSLMgr::TexCoordsID, 0, color_flags, texid,
			LINE_MODE); // Constants1

	glLineWidth(MIN_LINE_WIDTH);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	glBegin(GL_LINES);
	glVertex4d(p1.x, p1.y, p1.z, 0);
	glVertex4d(p2.x, p2.y, p2.z, 0);
	glEnd();

	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

}
void TNLeaf::getTexDir(char*dir){
	char base[256];
	char dimdir[32];
  	File.getBaseDirectory(base);
 	sprintf(dir,"%s/Textures/Plants/Leaf",base);
}
void TNLeaf::init(){
	TNBranch::init();
}

