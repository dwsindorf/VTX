#include "SceneClass.h"
#include "RenderOptions.h"
#include "Plants.h"
#include "Util.h"
#include "MapNode.h"
#include "ModelClass.h"
#include "AdaptOptions.h"
#include "FileUtil.h"
#include "GLSLMgr.h"
#include "Effects.h"
#include "TerrainClass.h"

extern double lsin(double g);
extern double lcos(double g);

#define USE_AVEHT
#define MIN_VISITS 1
#define TEST_NEIGHBORS 1

static bool use_cache=true;
//#define DUMP
//#define DEBUG_PMEM
#define DRAW_LINES

//#define PRINT_PLANT_TIMING
#define DEBUG_RANDOMIZE
#define SHOW_PLANT_STATS
#define SHOW_BRANCH_STATS
//#define SHOW_BRANCH_TIMING
//#define DEBUG_SLOPE_BIAS
//#define DEBUG_HT_BIAS
//#define DEBUG_LAT_BIAS
//#define DEBUG_HARD_BIAS

#define PSCALE TheMap->radius

#define SRAND 	(rands[PERM((randval++))])
#define URAND 	(rands[PERM((randval++))]+0.5)

#define FIRST_FORK  1
#define FIRST_EMIT  2
#define LAST_EMIT   4
#define LAST_FORK   8
#define BASE_FORK   16

static int cnt=0;

#define ENABLE_3D
// Basic algorithm
// 1) TNplant class implemented similar to sprites, craters etc (i.e placements)
//    Primary task is to generate a set of surface positions to spawn plant instances
// 2) TNbranch class creates a branching pattern for each plant placement
//    - Branches are implemented as 3d points which are projected into eye space then screen space
//    - successive branch levels are generated by calling "emit" recursively 
//      (or fork on first call if multiple branch types exist)
// 3) in screen space either a line (with width) or a polygon is drawn between connecting branch points
// 4) if a polygon is used base and tip parameter points are calculated based on the angle of the branch
//    - distance between tip points is less than that between base points to simulate branch taper
// 5) in 2d mode lighting (branch curvature) is emulated by changing normal from left to right along branch
//   - in the center normal faces directly out to eye
//   - in 3d mode surface normals of cone side panels are used to generate a more accurate shading model
// TODO: 
// 1) Better branching model (DONE)
//  Currently all branches spawn from the same point in screen space
//  Improve this by trying the following:
//  a) allow branches to spawn at random locations along parent stem vector (DONE)
//    - set 'start' position somewhere between top and base using random variable
//    - problem: in spline mode placements don't follow curve
//  b) place new branches at random offsets from center of parent branches (DONE)
//    - not implemented in 3d mode
//  c) don't require branch starting width to be the same as parents width (DONE)
//    - scale next segment width based on size of child branch
//  c) In multi-branch cases have a minimum level to start producing new branches and max level to stop (DONE)
//    - min level prevents branches from forming lower in parent trunk
//    - child branches should form only towards the tip of parent branches
// 2) implement geometry shader to improve performance (DONE)
// 3) add support for textures (DONE)
//   - optional: texture scale ?
// 4) add support for phase shading for textures (DONE)
//   - optional: user control of phase amplitude ?
// 5) implement TNLeaf class (DONE)
//    - only generate leaves at end of "terminal" branches
// 6) use a spline function when connecting levels on same branch (DONE)
//   - generate additional line segments between segment end points (no need for branching)
//   - use quadratic interpolation from last 3 points to smooth transition
// 7) implement 3d branches (DONE)
//   - generate a "cone" for each branch vector in geometry shader (16 side panels)
// 8) use lists to increase render speed (WONT DO)
//   - display lists actually degrade performance (at least when the vertex count is high)
//   - COMPILE followed by callList step very costly compared to just rendering directly (10x worse ?)
//   - if COMPILE skipped (just callList) performance is about the same as direct render for small model
// 9) generate wxWidgets classes for plants (DONE)
// 10) add support for shadows (DONE)
//  - 3d mode only
// 11) leaves
//  - leaf clusters (DONE)
//  - change DENSITY to go 0-1 from base to tip (DONE)
//  - method to make leaves alternate sides (DONE)
//  - support multiple leaf clusters per new branch (first bias) DONE
//  - vary leaf projection between eye plane and plane perpendicular to branch (flatness) DONE
//  - use image aspect to correctly set length to width ratio
//  - support NxN leaf textures (same as for sprites) DONE
//  - move start of leaf to surface of branch
// 12) branch data caching
//   if scene changes generate an array of cached data for each branch and leaf by traversing the plant tree
//   else play out the array using simple opengl calls
//   results:
//   - render time improves with/without shadows if scene is stationary with changing time (e.g. 20 vs 50 ms)
//   - but degradation in performance if moving (e.g 120 vs 50 ms)
//    o need to traverse plant tree but extra overhead required to free and build cache
//   - also see a subtle change in lighting if caching is enabled (a lighter lighter or darker depending on tod)
// 13) random plants
//   - implement "randomize" function that tweaks control parameters (WIP)
//   - generate random plants for procedural instance cases (e.g. new planet)
//     o may need separate prototypes for trees, bushes grasses
//       - then randomize the prototype
//     o generate textures randomly using procedural methods
// 14) texture lookup from other directories
//   - if texture not found in expected base directory look in bitmaps and imports directories
//     o if found populate search tree with other images from that directory
//     o add "Textures" and "Bitmaps" to end of directory list (1x1 etc)

//
// BUGS/problems
// 1) don't get enough plants generated - not all color spots produce a new plant
//     o improvement: added extra argument in TNplant to increase size of "dot" (threshold test)
//     o improvement: moving visits++ before threshold test in set_terrain
// 2) far away plants (e.g. trees) look "denuded" (i.e. lack foliage) because smaller branches arn't drawn
//    - workaround: increase branch width with distance (using new RANGE variable)
// 3) multiple plants don't stack if "+" used to connect
//    - Preceding plant loses last branch
//    - works OK without "+" connection
// 4) TNLeaf issues
//   - found problem that rectangles were not being created correctly (slanted edges)
//     * fixed by creating projected vector in eye space vs. model space
//     * also fixes width/length problem (narrow leaves)
//     o but lines projected to or away from eye are smaller than those tangent to eye (at same depth)
//       so leaves are drawn with different sizes depending on orientation
//     o overall effect is ok, models young and older leaves on same branch but would be better to be
//       able to control this
//     o rotation angle doesn't always seem correct and changes with aspect ratio
//   - need to adjust leaf size based on plant size
// 5) spline issues
//   - offsets don't follow branch curvature when spline is applied
//   - offset sometimes disconnects branches from parent
//   - sometimes get a twist in middle of spline (180 phase shift ?)
// 6) 3d issues
//   - branch dimensions and shapes change when aspect ratio and size of window are changed (scales ok in 2d)
//   - trunk size can be very different between 2d and 3d
// 7) GUI issues
//   - adding a plant sometimes puts branch on lower plant 
//   - adding plant to terrain puts following elements in a sub-group
//     o removing also removes sub-group elements
//   - deleting branch can cause crash
//   - adding branch to (empty) plant causes crash
// 8) shadows
//   o don't show or ill defined unless view range is small (e.g. no distant hills)
//    - need to add extra shadow view that only includes visible or near plants
//   o shadows generated for leaves
//    - projection not correct (too small)
//    - no shadow if flatness=1 (orientation 100% towards eye)
//    - get white silhouette around leaves on ground shadows
//    - get black silhouette around leaves against sky
//    - sometimes get small shadow of same leaf at leaf base
//   o shadows generated for lines
//    - can't see unless line width increased >1
// 9) Shape
//   o plant shape doesn't scale correctly with size 
//   - sometimes branches are too wide (WRT) length when plant is added to surface
//   * fixed: caused by plant scale and width dependent on orbital size (map->radius)
//   - replaced map->radius with fixed constant (4e-3)
// 10) plant branches disappear if 3d-clouds are present
//   o fixed: removed call to GLSLMgr::max_output=4 in CloadLayer setProgram
// 11) plants are generated on or below water (fixed)
// 12) clusters
//   - not all leaves are in the same plane
//   * fixed: was using tilted vector for branch direction
//   - transparency not perfect
// 13) leaves don't show on far plants (branches show but have no foliage)
//   * improved
// 14) when multiple leaves are present secondary leaves are not connected to branch (suspended in air)
//   * improved: shortened vector connecting previous node by 90%
// 15) data caching (leaves)
//   o collect leaf data only when scene changes otherwise render collected data
//   o problems with shadows
//   - if color not enabled get shadow everywhere and render times double
//   - leaf shadows aren't rendered (fixed)
// 16) plants don't show on some layers in multi-layer maps (fixed - use surface1)
// 17) shadows aren't drawn correctly after move (but are fixed when scene is re-rendered)
// 18) In terrain with 2 plants adding Map deletes surface "pt" (ok with only 1 plant)
//     - creates empty Map below plants (doesn't make a layer) (FIXED - map id level > plant)
// NOTES to self
// 1) Branch texture images
//   - If tiled image is created from a photo it will only show the front half of full 3d map
//   - to emulate 3d need to multiply xz tex coords by 2 (maps 2 copies of tiled image around branch)
//   - this works for normal images but for multidim sprite panels sometimes get a visual discontinuity 
//     o ogl doesn't seem to be able to wrap borders of interior images to avoid this
//   - one idea is to start with a phase away from the viewpoint and only use a 1to1 multplier
//     o this hides the discontinuity but we loose half the available image content (since half is hidden behind the branch)
//     o wrapping image this way also results in a 2x horizontal distortion
//   - a workaround is to duplicate and combine each sub-image before generating the sprite panel image
//     o each sub-image is twice as wide but we can see all available photo detail even with a 1x multiply
// 2) using VBO for branches(and leafs) resulted in a HUGE speedup, (particularly for shadows)
//   e.g shrubs with leafs (with shadows) : non-VNBO <1.0 fps with VBO ~15 fps
//************************************************************

extern double MaxSize,Height,Phi,Theta,Level,PLevel,Randval,Srand,Range,Temp,Slope;
extern Point MapPt;
extern double  zslope();
extern char tabs[];

extern int test1,test2,test3,test4,test5;

static int ncalls=0;
static int oldmode=0;

static TerrainData Td;

static int branch_nodes;
static int trunk_nodes;
static int line_nodes;

static double base_draw_width=1;
static double min_draw_width=base_draw_width;

//#define MIN_DRAW_WIDTH min_draw_width // varies with scene quality
#define MIN_LINE_WIDTH min_draw_width
#define MIN_TRIANGLE_WIDTH 10*MIN_LINE_WIDTH
#define MIN_SPLINE_WIDTH 4*MIN_TRIANGLE_WIDTH


static int randval=0;


LeafImageMgr leaf_mgr; // global image manager
BranchImageMgr branch_mgr; // global image manager

enum {
	PLANT_TYPES =0,
	PLANTS_DRAWN=1,
	PLANTS_SKIPPED=2,
	PLANT_BRANCHES=3,
	PLANT_LEAVES=4,
	PLANT_LINES=5,
	PLANT_TRIANGLES=6,
	PLANT_SPLINES=7,
	PLANT_VERTEXES=8,
	PLANT_INSTANCES=9,
};
static char str1[1024];
static char str2[1024];
static char str3[1024];
void set_plant_stat_strings(){
	sprintf(str1,"types:%d number:%d verts:%d times make:%3.2f process:%3.2f render:%3.2f s\n",
	PlantMgr::stats[PLANT_TYPES],
	PlantMgr::stats[PLANT_INSTANCES],
	PlantMgr::stats[PLANT_VERTEXES],
	PlantMgr::generate_time,
	PlantMgr::process_time,
	PlantMgr::render_time);
	
	sprintf(str2,"new plants:%d branches:%d leaves:%d lines:%d triangles:%d splines:%d skipped:%d\n",
	PlantMgr::show_one?1:PlantMgr::stats[PLANTS_DRAWN],
	PlantMgr::stats[PLANT_BRANCHES],
	PlantMgr::stats[PLANT_LEAVES],
	PlantMgr::stats[PLANT_LINES],
	PlantMgr::stats[PLANT_TRIANGLES],
	PlantMgr::stats[PLANT_SPLINES],
	PlantMgr::stats[PLANTS_SKIPPED]
	);
	str3[0]=0;
	if(use_cache){
		int cache_tests=PlantObjMgr::cacheHits+PlantObjMgr::cacheMisses;
		sprintf(str3,"cache tests:%d hits:%2.1f active:%d added:%d removed:%d\n",
				cache_tests,100.0*PlantObjMgr::cacheHits/cache_tests,PlantObjMgr::plantCache.size(),PlantObjMgr::cacheMisses,PlantObjMgr::cacheDeletes);
	}
}
void show_plant_info()
{
	if(!Render.display(PLANTINFO))
		return;
	TheScene->draw_string(HDR1_COLOR,"------- plants ---------------------");
	set_plant_stat_strings();
	TheScene->draw_string(DATA_COLOR,str1);
	TheScene->draw_string(DATA_COLOR,str2);
	if(strlen(str3))
		TheScene->draw_string(DATA_COLOR,str3);
	TheScene->draw_string(HDR1_COLOR,"------------------------------------");
}
void show_plant_stats()
{
	cout<<"------- plants ---------------------"<<endl;
	set_plant_stat_strings();
	cout<<str1;
	cout<<str2;
	cout<<str3;
}
//************************************************************
// BranchData class
//************************************************************

double BranchData::distance() { 
	return position.distance(TheScene->xpoint);
}

void BranchVBO::appendEyeSpace(const std::vector<BranchVertex>& objVerts, Point plantCenter)
{
    Point offset = plantCenter - TheScene->xpoint;   
    for (const auto& vObj : objVerts) {
        BranchVertex vEye = vObj;
        vEye.pos=Vec4(vObj.pos.x+offset.x,vObj.pos.y+offset.y,vObj.pos.z+offset.z);
        vEye.common2=Vec4(vObj.common2.x+offset.x,vObj.common2.y+offset.y,vObj.common2.z+offset.z);
        vertexesEyeSpace.push_back(vEye);
    }
    dirty = true;
}

void BranchVBO::build()
{
    if (!dirty || vertexesEyeSpace.empty()) return;

    if (!vbo)
        glGenBuffers(1, &vbo);

    // Just upload the data - no VAO setup here
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER,
                 vertexesEyeSpace.size() * sizeof(BranchVertex),
                 vertexesEyeSpace.data(),
                 GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    vertCount = vertexesEyeSpace.size();
    dirty = false;
}

void BranchVBO::addBranch(Vec4 p0, Vec4 p1, Vec4 p2, Vec4 f, Vec4 d, Vec4 s, Color c, float shaderMode)
{
    BranchVertex v;
    v.common1 = f;
    v.common2 = p0;
    v.common3 = s;
    v.texcoord = Vec4(d.x, d.y, d.z, shaderMode);
    v.color = Vec4(c.red(), c.green(), c.blue(), c.alpha());

    v.pos = p1;
    vertexesObjectSpace.push_back(v);
    v.pos = p2;
    vertexesObjectSpace.push_back(v);

    dirty = true;
}

void BranchVBO::render()
{
    if (vertexesEyeSpace.empty() || !vbo) return;

    size_t stride = sizeof(BranchVertex);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    // Compatibility attributes (gl_Vertex, gl_Color)
    glVertexPointer(4, GL_FLOAT, stride, (void*)offsetof(BranchVertex, pos));
    glEnableClientState(GL_VERTEX_ARRAY);

    if (PlaceObjMgr::shadow_mode) {
        glDisableClientState(GL_COLOR_ARRAY);
    } else {
        glColorPointer(4, GL_FLOAT, stride, (void*)offsetof(BranchVertex, color));
        glEnableClientState(GL_COLOR_ARRAY);
    }

    // Generic attribs - set fresh every draw against current program
    glVertexAttribPointer(GLSLMgr::CommonID1, 4, GL_FLOAT, GL_FALSE, stride,
                         (void*)offsetof(BranchVertex, common1));
    glEnableVertexAttribArray(GLSLMgr::CommonID1);

    glVertexAttribPointer(GLSLMgr::CommonID2, 4, GL_FLOAT, GL_FALSE, stride,
                         (void*)offsetof(BranchVertex, common2));
    glEnableVertexAttribArray(GLSLMgr::CommonID2);

    glVertexAttribPointer(GLSLMgr::CommonID3, 4, GL_FLOAT, GL_FALSE, stride,
                         (void*)offsetof(BranchVertex, common3));
    glEnableVertexAttribArray(GLSLMgr::CommonID3);

    glVertexAttribPointer(GLSLMgr::TexCoordsID, 4, GL_FLOAT, GL_FALSE, stride,
                         (void*)offsetof(BranchVertex, texcoord));
    glEnableVertexAttribArray(GLSLMgr::TexCoordsID);

    glDrawArrays(GL_LINES, 0, vertCount);

    // Cleanup
    glDisableVertexAttribArray(GLSLMgr::CommonID1);
    glDisableVertexAttribArray(GLSLMgr::CommonID2);
    glDisableVertexAttribArray(GLSLMgr::CommonID3);
    glDisableVertexAttribArray(GLSLMgr::TexCoordsID);
    glDisableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);  // restore
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}
void BranchVBO::free()
{
    if (vbo) { glDeleteBuffers(1, &vbo); vbo = 0; }
    if (vao) { glDeleteVertexArrays(1, &vao); vao = 0; }
    vertexesObjectSpace.clear();
    vertexesEyeSpace.clear();
    vertCount = 0;
    dirty = true;
}

//************************************************************
// PlantMgr class
//************************************************************
//	arg[0]  levels   		scale levels
//	arg[1]  maxsize			size of largest craters
//	arg[2]  mult			size multiplier per level
//	arg[3]  density			density or dexpr
//
//-------------------------------------------------------------
int PlantMgr::stats[MAX_PLANT_STATS];
double PlantMgr::generate_time=0;
double PlantMgr::render_time=0;
double PlantMgr::process_time=0;
bool PlantMgr::threed=true;
bool PlantMgr::spline=true;
bool PlantMgr::poly_lines=false;
bool PlantMgr::shader_lines=false;

bool PlantMgr::show_one=false;
int PlantMgr::textures=0;
bool PlantMgr::first_instance=false;
bool PlantMgr::update_needed=false;
bool PlantMgr::vbo_valid=false;

PlantMgr::PlantMgr(int i,TNplant *p) : PlacementMgr(i)
{
#ifdef DUMP
	if(!first_instance)
		add_finisher();
#endif
	MSK_SET(type,PLACETYPE,PLANTS);
	plant=p;
	mult=0.5;
	slope_bias=0;
	hardness_bias=0;
	ht_bias=0;
	lat_bias=0;
	slope_bias=0;
	dexpr=0;
	instance=0;
	first_instance=true;
	set_ntest(TEST_NEIGHBORS);
	//set_testpts(1);
	set_testDensity(true);
#ifdef TEST_PLANTS
	set_testColor(true);
#endif

}
PlantMgr::~PlantMgr()
{
  	if(finalizer()){
 #ifdef DEBUG_PMEM
  		printf("PlantMgr::free()\n");
#endif
	}
}

void PlantMgr::clearStats(){
	for(int i=0;i<MAX_PLANT_STATS;i++){
		stats[i]=0;
	}
}

//-------------------------------------------------------------
// PlantMgr::init()	initialize global objects
//-------------------------------------------------------------
void PlantMgr::init()
{
	static bool finisher_added=false;
#ifdef DEBUG_PMEM
  	printf("PlantMgr::init()\n");
#endif
	PlacementMgr::init();

	ncalls=0;
  	reset();
	if(!finisher_added)
		add_finisher(show_plant_info);
	finisher_added=true;

}

double PlantData::value() { return 2000*instance+pts;}
//-------------------------------------------------------------
// PlantMgr::make() factory methods to make Placement
// - derived classes my override
//-------------------------------------------------------------
Placement *PlantMgr::make(Point4DL &p, int n)
{
    return new Placement(*this,p,n);
}
PlaceData *PlantMgr::make(Placement*s)
{
    return new PlantData(s);
}
//************************************************************
// PlantObjMgr class
//************************************************************
ValueList<PlaceData*> PlantObjMgr::data(50000,10000);
std::map<PlantObjMgr::PlantCacheKey, PlantObjMgr::PlantCacheEntry> PlantObjMgr::plantCache;
int PlantObjMgr::cacheHits=0;
int PlantObjMgr::cacheMisses=0;
int PlantObjMgr::cacheDeletes=0;
int PlantObjMgr::maxCacheSize=50000;

void PlantObjMgr::freeLeafs(){
	for (int i=0;i<objs.size;i++){
		((Plant*)objs[i])->freeLeafs();
	}
}
void PlantObjMgr::freeBranches(){
	for (int i=0;i<objs.size;i++){
		((Plant*)objs[i])->freeBranches();
	}
}
void PlantObjMgr::renderBranches(){
	for (int i=0;i<objs.size;i++){
		((Plant*)objs[i])->renderBranches();
	}
}
void PlantObjMgr::renderLeafs(){
	for (int i=0;i<objs.size;i++){
		((Plant*)objs[i])->renderLeafs();
	}
}
void PlantObjMgr::collect(){
	data.free();
	for(int i=0;i<objs.size;i++){
		PlaceObj *obj=objs[i];
		obj->mgr()->collect(data);
	}
	if(data.size)
		data.sort();
}
void PlantObjMgr::clearCache()
{
    // Free all cached geometry
    plantCache.clear();
    
    // Reset stats
    cacheHits = 0;
    cacheMisses = 0;
    cacheDeletes = 0;
    
    // Force regeneration next frame
    // (cache is empty so all plants will be cache misses)
}
void PlantObjMgr::updateCache()
{
    static int frameCount = 0;
    
    auto it = plantCache.begin();
    while (it != plantCache.end()) {
        it->second.framesSinceUsed++;
        
        if (it->second.framesSinceUsed > 5) {  // remove if not used after 5 update cycles
            it = plantCache.erase(it);
            cacheDeletes++;
        } else {
            ++it;
        }
    }
    
    // Enforce max cache size
    while ((int)plantCache.size() > maxCacheSize) {
        auto oldest = std::max_element(plantCache.begin(), plantCache.end(),
            [](const auto& a, const auto& b) {
                return a.second.framesSinceUsed < b.second.framesSinceUsed;
            });
        plantCache.erase(oldest);
    }
}
void PlantObjMgr::free() { 
	//cout<<"PlantObjMgr::free() "<<data.size<<endl;
	data.free();
	//clearCache();
}

void PlantObjMgr::render()
{
    int n = placements();
    int l = randval;
    if (n == 0)
        return;
    
    bool moved = TheScene->moved();
    bool changed = TheScene->changed_detail();
    if (changed && PlaceObjMgr::shadow_mode) {
        return;
    }
    bool update_needed = moved || changed;
    if (moved && PlaceObjMgr::shadow_mode)
        update_needed = false;

    Point eyePoint = TheScene->epoint;
    double t0;
    double gentm=0;
    double tm=0;
   // cout<<"PlantObjMgr::render() changed="<<changed<<" moved="<<moved<<endl;

    glEnable(GL_BLEND);

    if (update_needed) {
    	PlantMgr::clearStats();
  		cacheHits = cacheMisses =0;
  		PlantMgr::stats[PLANT_TYPES]=objs.size;
  		t0=clock();
   		if(changed)
    		clearCache(); 
    	for (int i = 0; i < objs.size; i++) {
			Plant *plant = (Plant*)objs[i];
			plant->accumBranchVBO.vertexesEyeSpace.clear();
			plant->accumLineVBO.vertexesEyeSpace.clear();
			plant->accumLeafVBO.vertexesEyeSpace.clear();
			plant->accumBranchVBO.dirty = true;
			plant->accumLineVBO.dirty = true;
			plant->accumLeafVBO.dirty = true;
		}

        int start = PlantMgr::show_one ? 1 : n;  // number of plants to process
        PlantMgr::stats[PLANT_INSTANCES]=start;
        for (int i = 0; i < start; i++) {
            PlaceData *s = data[i];
            PlantMgr *pmgr = (PlantMgr*)s->mgr;
            TNplant *tnplant = pmgr->plant;
            Plant *plant = (Plant*)tnplant->plant;  // Cast to Plant*
            
            if (!plant) continue;

            tnplant->size     = s->radius;
            tnplant->drop     = (1 - tnplant->size * pmgr->drop);
            tnplant->base_point = s->vertex;
            tnplant->pntsize  = s->pts;
            tnplant->distance = s->dist;
            randval           = s->rval;
            tnplant->seed     = URAND;

            Point plantCenter = s->vertex * tnplant->drop;
            // Look up cache
            PlantCacheKey cacheKey(plantCenter, s->instance);
            auto cacheIt = plantCache.find(cacheKey);
  
            if (use_cache && cacheIt != plantCache.end() &&
                !cacheIt->second.needsRegen(s->pts)) {
                // CACHE HIT
                cacheHits++;
                PlantCacheEntry& entry = cacheIt->second;
                entry.framesSinceUsed = 0;
               
                plant->accumBranchVBO.appendEyeSpace(cacheIt->second.branches, plantCenter);
                plant->accumLineVBO.appendEyeSpace(cacheIt->second.lines, plantCenter);
                plant->accumLeafVBO.appendEyeSpace(entry.leafs, plantCenter);  // ADD THIS LINE
                //tm+=clock()-t2;
            } 
            else {
                // CACHE MISS - generate geometry
                cacheMisses++;

                // Clear before generating
                plant->branchVBO.clear();
                plant->lineVBO.clear();
                plant->freeLeafs();  // Clears both leafs list AND leafVBO
                double t1=clock();
                // Generate in object space
                tnplant->emit();
                gentm+=clock()-t1;

                // Sort leafs and build leafVBO in object space
                plant->sortLeafs();

                // Store in cache
                PlantCacheEntry entry;
                entry.branches    = plant->branchVBO.vertexesObjectSpace;
                entry.lines       = plant->lineVBO.vertexesObjectSpace;
                entry.leafs       = plant->leafVBO.vertexesObjectSpace;
                entry.worldVertex = plantCenter;
                entry.pts         = s->pts;
                entry.drop        = tnplant->drop;
                entry.size        = s->radius;
                entry.instance    = s->instance;
                entry.seed        = tnplant->seed;
                entry.rval        = s->rval;
                entry.framesSinceUsed = 0;

                plantCache[cacheKey] = entry;
                //double t2=clock();
                // Append to accum (object space â†’ eye space)
                plant->accumBranchVBO.appendEyeSpace(entry.branches, plantCenter);
                plant->accumLineVBO.appendEyeSpace(entry.lines, plantCenter);
                plant->accumLeafVBO.appendEyeSpace(entry.leafs, plantCenter);
                //tm+=clock()-t2;
            }
         }
        //double t2=clock();
        // Upload accumulated eye space VBOs once per plant type
        PlantMgr::stats[PLANT_VERTEXES]=0;
        for (int i = 0; i < objs.size; i++) {
        	Plant *plant = (Plant*)objs[i];
			PlantMgr::stats[PLANT_VERTEXES]+=plant->accumBranchVBO.vertexesEyeSpace.size()
			+plant->accumLineVBO.vertexesEyeSpace.size()
			+plant->accumLeafVBO.vertexesEyeSpace.size();
        }
        //int nverts=0;
		for (int i = 0; i < objs.size; i++) {
			Plant *plant = (Plant*)objs[i];
			plant->accumBranchVBO.build();
			plant->accumLineVBO.build();
			plant->accumLeafVBO.build();
		}
        //tm+=clock()-t2;

        updateCache();  // OUTSIDE the loop!
        PlantMgr::generate_time=gentm/CLOCKS_PER_SEC;
        PlantMgr::process_time=(clock()-t0)/CLOCKS_PER_SEC-PlantMgr::generate_time; // all other processing
        
        //cout<<"nverts="<<nverts<<endl;
        
    } else if (data.size) {
        // No update needed - just set normal
        PlaceData *s = data[0];
        PlantMgr *pmgr = (PlantMgr*)s->mgr;
        TNplant *tnplant = pmgr->plant;
        tnplant->setNormal();
    }
    t0=clock();
    if (!PlaceObjMgr::shadow_mode)
        setProgram();
    glDisable(GL_CULL_FACE);
    renderBranches();
    renderLeafs();
    glEnable(GL_CULL_FACE);

    randval = l;
    PlantMgr::render_time=(clock()-t0)/CLOCKS_PER_SEC;
#ifdef SHOW_BRANCH_STATS
    if (update_needed)
        show_plant_stats();
#endif
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 }
bool PlantObjMgr::setProgram(){
	if(PlaceObjMgr::shadow_mode)
		return false;
	GLSLMgr::input_type=GL_LINES;
	GLSLMgr::output_type=GL_TRIANGLE_STRIP;

	char defs[1024]="#define PLACED\n";

	PlantMgr::textures=0;
	
	for(int i=0;i<objs.size;i++){
		objs[i]->setProgram();
	}

	branch_nodes=0;
	trunk_nodes=0;
	line_nodes=0;
	
	double twilite_min=-0.2; // full night
	double twilite_max=0.2;  // full day
	
	if(Render.textures()){
		sprintf(defs+strlen(defs),"#define NTEXS %d\n",PlantMgr::textures);
		if(PlantMgr::textures>0 && Render.bumps())
			sprintf(defs+strlen(defs),"#define BUMPS\n",PlantMgr::textures);
	}
	else
		sprintf(defs+strlen(defs),"#define NTEXS 0\n");
		
	sprintf(defs+strlen(defs),"#define NLIGHTS %d\n",Lights.size);
	if(Render.haze())
		sprintf(defs+strlen(defs),"#define HAZE\n");

    bool do_shadows=Raster.shadows();
	if(do_shadows && !TheScene->light_view()&& !TheScene->test_view())
		sprintf(defs+strlen(defs),"#define SHADOWS\n");
	if(TheScene->light_view() || TheScene->test_view())
		sprintf(defs+strlen(defs),"#define TEST_VIEW\n");
	GLSLMgr::setDefString(defs);

	
	if(PlantMgr::threed)
		GLSLMgr::loadProgram("plants.gs.vert","plants.frag","plants3D.geom");
	else
		GLSLMgr::loadProgram("plants.gs.vert","plants.frag","plants2D.geom");
		
	GLhandleARB program=GLSLMgr::programHandle();
	if(!program){
		cout<<"PlantMgr::setProgram - failed to load program"<<endl;
		return false;
	}
	
	char str[MAXSTR];
	
	for(int i=0;i<PlantMgr::textures;i++){
		sprintf(str,"samplers2d[%d]",i);
		glUniform1iARB(glGetUniformLocationARB(program,str),i);
	}

	GLSLVarMgr vars;
	
	Planetoid *orb=(Planetoid*)TheScene->viewobj;
	
	Color diffuse=orb->diffuse;
	Color ambient=orb->ambient;
	Color shadow=orb->shadow_color;
	Color haze=Raster.haze_color;
		
	double shadow_intensity=orb->shadow_intensity;
	vars.newFloatVec("Diffuse",diffuse.red(),diffuse.green(),diffuse.blue(),diffuse.alpha());
	vars.newFloatVec("Ambient",ambient.red(),ambient.green(),ambient.blue(),ambient.alpha());
	vars.newFloatVec("Shadow",shadow.red(),shadow.green(),shadow.blue(),shadow_intensity);
	vars.newFloatVec("Haze",haze.red(),haze.green(),haze.blue(),haze.alpha());
	vars.newFloatVar("haze_zfar",Raster.haze_zfar);
	vars.newFloatVar("haze_grad",Raster.haze_grad);
	vars.newFloatVar("haze_ampl",Raster.haze_hf);
	vars.newFloatVar("bump_delta",1e-3);
	vars.newFloatVar("bump_ampl",0.025);
	vars.newFloatVar("twilite_min",twilite_min);
	vars.newFloatVar("twilite_max",twilite_max);

	vars.newBoolVar("lighting",Render.lighting());
	
	double zn=TheScene->znear;
	double zf=TheScene->zfar;
	double ws1=1/zn;
	double ws2=(zn-zf)/zf/zn;

	vars.newFloatVar("ws1",ws1);
	vars.newFloatVar("ws2",ws2);

	vars.setProgram(program);
	
	vars.loadVars();

	GLSLMgr::setProgram();
	GLSLMgr::loadVars();
		
	int l=randval;
	randval=l;
	return true;
}
void PlantObjMgr::render_zvals(){
	render_shadows();
}
void PlantObjMgr::render_shadows(){
	if(objs.size==0)
		return;
	if(!PlantMgr::threed)
		return;
	shadow_mode=true;
	GLSLMgr::input_type=GL_LINES;
	GLSLMgr::output_type=GL_TRIANGLE_STRIP;
	
	Raster.setShadowProgram("plants.gs.vert","plants.shadows.geom",0);
	Raster.setProgram(Raster.PLACE_SHADOWS);

	render();
	shadow_mode=false;
}
//************************************************************
// Plant class
//************************************************************
//-------------------------------------------------------------
// Plant::Plant() Constructor
//-------------------------------------------------------------
Plant::Plant(int t, TNode *e):PlaceObj(t,e)
{
	sorted=false;
}
PlacementMgr *Plant::mgr() { return ((TNplant*)expr)->mgr;}

bool Plant::setProgram(){
	return ((TNplant*)expr)->setProgram();
}

void Plant::collectBranches(Vec4 p0, Vec4 p1, Vec4 p2, Vec4 f, Vec4 d, Vec4 s, Color c) {
    branchVBO.addBranch(p0, p1, p2, f, d, s, c, TNBranch::shaderMode(d.w));
}

void Plant::collectLines(Vec4 p0, Vec4 p1, Vec4 p2, Vec4 f, Vec4 d, Vec4 s, Color c) {
    lineVBO.addBranch(p0, p1,p2, f, d, s, c, TNBranch::shaderMode(d.w));
}

void Plant::freeBranches() {
    branchVBO.clear();
    lineVBO.clear();
}
void Plant::renderBranches() {
    if (PlantMgr::poly_lines || PlantMgr::shader_lines) {
        glLineWidth(1);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        accumBranchVBO.render();
        accumLineVBO.render();
    } else {
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glLineWidth(1);
        accumBranchVBO.render();
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glLineWidth(0.5);
        accumLineVBO.render();
    }
}

void Plant::renderLeafs() {
    if (PlantMgr::poly_lines || PlantMgr::shader_lines)
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    else
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    accumLeafVBO.render();
}
void Plant::collectLeafs(Vec4 p0,Vec4 p1,Vec4 p2, Vec4 f, Vec4 d,Vec4 s,Color c){
	leafs.add(new BranchData(p0,p1,p2,f,d,s,c));
}

void Plant::sortLeafs() {
	if (!sorted) {
		leafs.ss();
		leafs.sort(); 
		leafVBO.clear();
		for (int i = leafs.size - 1; i >= 0; i--) {
			BranchData *l = leafs[i];
			leafVBO.addBranch(l->data[0], l->data[1], l->data[2], l->data[3],
					l->data[4], l->data[5], l->c,
					TNBranch::shaderMode(l->data[4].w));
		}
	}
	sorted = true;
}

void Plant::freeLeafs() {
	leafs.free();
    leafVBO.clear();
	sorted=false;
}
//************************************************************
// TNplant class
//************************************************************
double TNplant::norm_max=2;
double TNplant::norm_min=1e-5;
double TNplant::draw_scale=1;
TNplant::TNplant(TNode *l, TNode *r) : TNplacements(0,l,r,0)
{
	set_collapsed();

	TNarg *arg=left;
	TNarg *node=arg->left;
	if(node->typeValue() == ID_STRING){		
		setName(((TNstring*)node)->value);
		left=arg->next();
		left->setParent(this);
		arg->right=0;
		delete arg;	
	}
	plant=0;
	branches=0;
	pntsize=0;
	size=1e-6;
	width_scale=1;
	size_scale=1;
	distance=0;
	seed=0;
	radius=0.1;
	drop=0;
	
    mgr=new PlantMgr(PLANTS,this);
}

//-------------------------------------------------------------
// TNplant::~TNplant() destructor
//-------------------------------------------------------------
TNplant::~TNplant()
{
	DFREE(plant);
}

//-------------------------------------------------------------
// TNplant::applyExpr() apply expr value
//-------------------------------------------------------------
void TNplant::applyExpr()
{
   if(expr){
	    TNplant* sprt=(TNplant*)expr;
	    mgr->type=type;
		DFREE(left);
		left=expr->left;
		left->setParent(this);
		expr=0;
	}
	if(right)
		right->applyExpr();
 }
//-------------------------------------------------------------
// TNplant::init() initialize the node
//-------------------------------------------------------------
void TNplant::init()
{
    branches=0;
	if(right)
	   right->init();
	PlantMgr *smgr=(PlantMgr*)mgr;
	if(plant==0)
		plant=new Plant(type,this);
	smgr->init();
			
	smgr->getArgs((TNarg *)left);
	smgr->set_first(1);
	
	
	TNBranch *first_branch=(TNBranch*)right;
	if(right && right->typeValue() == ID_BRANCH) 
		first_branch=(TNBranch*)right;
	else
		return;
	double w=first_branch->width;
	double t=first_branch->length_taper;
	double n=first_branch->max_level;
	double f=n/w;
	if(n>1 && t<1)
		f=(pow(t, float(n)) - 1.0) / (t - 1.0)/w;
	f=pow(f,0.75);
	//cout<<"n:"<<n<<" w:"<<w<<" t:"<<t<<" f:"<<f<<endl;
	smgr->pts_scale=f;
}

void TNplant::set_id(int i){
	BIT_OFF(type,PID);
	type|=i&PID;
}

//-------------------------------------------------------------
// TNplant::eval() evaluate the node
//-------------------------------------------------------------
void TNplant::eval()
{	
	PlantMgr *smgr=(PlantMgr*)mgr;

	TerrainData ground;
	bool spass=CurrentScope->spass();

	if(!isEnabled() || TheScene->viewtype !=SURFACE || Raster.surface==2){
		if(right)
			right->eval();
		return;
	}
	SINIT;	
	if(CurrentScope->rpass()){
		int layer=inLayer()?Td.tp->type():0; // layer id
		int instance=Td.tp->Plants.objects();
		mgr->instance=instance;
		mgr->layer=layer;
		if(plant){
			plant->set_id(instance);
			plant->layer=layer;
		}
		if(layer)
			Td.tp->Plants.addObject(plant);
		else
			Td.Plants.addObject(plant);
		Td.pids++;
		mgr->setHashcode();
		if(right)
			right->eval();
		return;
	}
	if(right)
		right->eval();
	//if(!CurrentScope->spass())
	ground.copy(S0);
	if(S0.get_flag(ROCKBODY))
		return;	
	ncalls++;
	
	INIT;
	
	mgr->type=type;

	radius=TheMap->radius;

	mgr->getArgs((TNarg *)left);
	
	MaxSize=mgr->maxsize;

	double density=mgr->density;

 	if(density>0)
		smgr->eval();  // calls PlantPoint.set_terrain (need MapPt)

	S0.copy(ground); // restore S0.p.z etc

	if(!CurrentScope->spass()){ // adapt pass only
		mgr->setTests(); // set S0.c S0.s (density)
	}
}

void TNplant::addSkipped(){
	PlantMgr::stats[PLANTS_SKIPPED]++;
}
void TNplant::addRendered(){
	PlantMgr::stats[PLANTS_DRAWN]++;
}
void TNplant::addLine(){
	PlantMgr::stats[PLANT_LINES]++;	
}
void TNplant::addBranch(){
	PlantMgr::stats[PLANT_BRANCHES]++;	
}
void TNplant::addTriangle(){
	PlantMgr::stats[PLANT_TRIANGLES]++;	
}

void TNplant::addSpline(){
	PlantMgr::stats[PLANT_SPLINES]++;	
}
void TNplant::addLeaf(){
	PlantMgr::stats[PLANT_LEAVES]++;	
}

//-------------------------------------------------------------
// TNtexture::valueString() node value substring
//-------------------------------------------------------------
void TNplant::valueString(char *s)
{
	//sprintf(s+strlen(s),"\n%s",tabs);
	if(strlen(name_str)>0)
		sprintf(s+strlen(s),"%s(\"%s\",",symbol(),name_str);
	else
		sprintf(s+strlen(s),"%s(",symbol());

	TNarg *arg=(TNarg*)left;
	while(arg){
		arg->valueString(s+strlen(s));
		arg=arg->next();
		if(arg)
			strcat(s,",");
	}
	strcat(s,")");
	TNBranch *branch=right;
	while(branch && (branch->typeValue()==ID_BRANCH||branch->typeValue()==ID_LEAF)){
		sprintf(s+strlen(s),"\n%s",tabs);
		branch->valueString(s);
		branch=branch->right;
	}
}

//-------------------------------------------------------------
// TNplant::save() archive the node
//-------------------------------------------------------------
void TNplant::save(FILE *f)
{
	char buff[4096];
	buff[0]=0;
	valueString(buff);
	fprintf(f,"%s",buff);
	
	TNBranch *branch=right;
	while(branch && (branch->typeValue()==ID_BRANCH||branch->typeValue()==ID_LEAF)){
		branch=branch->right;
	}
	fprintf(f,"\n%s",tabs);
    if(branch)
    	branch->save(f);
}

//-------------------------------------------------------------
// TNplant::saveNode() archive the node
//-------------------------------------------------------------
void TNplant::saveNode(FILE *f)
{
	char buff[1024];
	buff[0]=0;
	valueString(buff);
	//if(addtabs)
	    fprintf(f,"\n%s",tabs);
	fprintf(f,"%s",buff);
}

//-------------------------------------------------------------
// TNplant::lastChild
//-------------------------------------------------------------
NodeIF *TNplant::lastChild(){
	TNBranch *p = (TNBranch*)right;
	if(!right)
		return this;
	TNBranch *n=p;
	while (n && (n->typeValue() == ID_BRANCH || n->typeValue() == ID_LEAF)) {
		TNBranch *t=n->right;
		if(!t || (t->typeValue()!=ID_BRANCH && t->typeValue()!=ID_LEAF)){
			p=n;
			break;
		}
		n=n->right;
	}
	return p;
}

//-------------------------------------------------------------
// TNplant::removeNode() delete or replace
//-------------------------------------------------------------
NodeIF *TNplant::removeNode(){
	
	bool inlayer=inLayer();
	
	NodeIF *p=getParent();
	NodeIF *child=0;
	if(p->typeValue()!=ID_ROOT){
		child=p->removeChild(this);
	}
	TNBranch *branch=(TNBranch*)right;
	if(!branch)
	   return this;

	TNode *next=0;
	while(branch && (branch->typeValue()==ID_BRANCH||branch->typeValue()==ID_LEAF)){
		next=branch->right;
		branch->right=0;
		delete branch;
		branch=next;
	}
	right=0;
	if(next){
		if(p->typeValue()!=ID_ROOT)
	    	p->addChild(next);
		else
			p->replaceChild(this,next);
	}
	//Td.plants.remove(plant);
	plant=0;
	return this;
}


//-------------------------------------------------------------
// TNplant::addChild
//-------------------------------------------------------------
NodeIF *TNplant::addChild(NodeIF *n){
	if(n->typeValue()==ID_BRANCH)
		return TNfunc::addChild(n);
	else {
		TNunary *nlast=lastChild();
		nlast->right=n;
	}
	return this;
}

//-------------------------------------------------------------
// TNplant::replaceNode
//-------------------------------------------------------------
NodeIF *TNplant::replaceNode(NodeIF *n){
	removeNode();
	NodeIF *p=getParent();
    p->addChild(n);
	return this;
}
int TNplant::getChildren(LinkedList<NodeIF*>&l){
	return TNfunc::getChildren(l);
}

void TNplant::setScale(){
	//dfactor=draw_scale;
	switch(TheScene->render_quality){
	case DRAFT:
		min_draw_width=base_draw_width*1.5;
		break;
	case NORMAL:
		min_draw_width=base_draw_width;
		break;
	case HIGH:
		min_draw_width=base_draw_width*0.95;
		break;
	case BEST:
		min_draw_width=base_draw_width*0.9;
		break;	
	}
}

//-------------------------------------------------------------
// TNplant::setNormal() set glNormal
//-------------------------------------------------------------
void TNplant::setNormal(){
	if(!isEnabled())
		return;
	Point bot=base_point;
	Point norm=bot.normalize();
	if(!PlaceObjMgr::shadow_mode)
		glNormal3dv(norm.values());
}

//-------------------------------------------------------------
// TNplant::emit() build the branch structure
//-------------------------------------------------------------
void TNplant::emit(){
	if(!isEnabled())
		return;
	setScale();
	// compensate for changes in scene fov and aspect to keep ht/width constant	
	// note: width_scale == 1 for med and large 0.6629 for wide
	width_scale=0.834729*TheScene->wscale*TheScene->aspect/TheScene->viewport[3];
	//width_scale=800/TheScene->wscale;
     
	Randval=URAND;
	double length=size*PSCALE;	
		
	TNBranch *first_branch=(TNBranch*)right;
	if(right && right->typeValue() == ID_BRANCH) 
		first_branch=(TNBranch*)right;
	else
		return; // plant with no branches !
	
	norm=base_point.normalize(); // defines surface normal
	if(!PlaceObjMgr::shadow_mode)
		glNormal3dv(norm.values());

	Point bot=base_point*drop;	
	double branch_size=length*first_branch->length;
	Point top=bot*(1+branch_size); // starting trunk size
	Point p1=bot;
	Point p2=top;

	// convert from world space to object space
	p1=p1-base_point;
	p2=p2-base_point;
	
	double start_width=width_scale*pntsize*first_branch->length;//*first_branch->width;
	size_scale=	pntsize*width_scale/size;
	
	//dfactor=draw_scale*lerp(pntsize,1,100,0.5,1);

	Point tip;
	tip.x=start_width/width_scale;
	tip.y=0;
	tip.z=0;
	
	TNLeaf::left_side=0;
		
	first_branch->fork(BASE_FORK,p1,p2-p1,tip,length,start_width,0);

	addRendered();	
}

bool TNplant::setProgram(){
	TNBranch *first_branch=(TNBranch*)right;
	if(right && right->typeValue() == ID_BRANCH) 
		first_branch=(TNBranch*)right;
	else
		return false;
	TNBranch *branch=first_branch;
	while(branch && (branch->typeValue() == ID_BRANCH || branch->typeValue() == ID_LEAF)){
		branch->setProgram();
		branch=branch->right;
	}
	return true;
}

bool TNplant::randomize(){
	if(right && (right->typeValue() == ID_BRANCH)){
		((TNBranch*)right)->randomize();
		return true;
	}
	return false;
}
NodeIF *TNplant::getInstance(){
		return this;
}
NodeIF *TNplant::getInstance(NodeIF *parent){
	randomize();
	return this;
}

NodeIF *TNplant::getInstance(NodeIF *parent, int type){
	LinkedList<ModelSym*>list;
	char name[256];
	char path[1024];
	path[0]=0;
	strcpy(name,TheScene->typeSymbol(type).c_str());
	TheScene->model->getDirList(type,list);
	list.ss();
	ModelSym *is=list.at();
    while(is=list++){
    	if(strcmp(is->name(),name)==0){
    		strcpy(path,is->dir());
    		break;
    	}
	}
 	list.free();
 	TNplant *plant=0;
    if(strlen(path)){
    	File.getFileNameList(path,"*.spx",list);
		int ival=std::rand() % list.size;
		is=list[ival];
		strcpy(name,is->name());
		strcpy(path,is->dir());
		plant=TheScene->open_node(0,path);
		
    }
 	cout<<"TNplant::getInstance{"<<name<<") path:"<<path<<endl;
 	path[0]=0;
 	plant->valueString(path);
 	cout<<"TNplant::getInstance "<<path<<endl;
    list.free();
	plant->randomize();
	return plant;
}

//************************************************************
// TNBranch class
//************************************************************
int TNBranch::collect_mode=0;
//ValueList<BranchData*> TNBranch::branches(1000,2000);

TNBranch::TNBranch(TNode *l, TNode *r, TNode *b) : TNbase(0,l,r,b)
{
	setImageMgr(&branch_mgr);
	set_collapsed();
	TNarg *arg=left;
	TNarg *node=arg->left;
	if(node->typeValue() == ID_STRING){		
		setName(((TNstring*)node)->value);
		left=arg->next();
		if(left)
			left->setParent(this);
		arg->right=0;
		delete arg;	
	}
	level=0;
	maxlvl=0;
	branch_id=0;
	length=1;
	width=1;
	width_taper=0.75;
	length_taper=0.95;
	randomness=1;
	max_splits=5;
	first_bias=2;
	flatness=0.0;
	curvature=0;
	density=1;
	divergence=0.75;
	min_level=0;
	max_level=1;
	offset=1;
	root=0;
	image=0;
	image_file[0]=0;
	colorexpr[0]=0;
	texture_id=0;
	texid=-1;
	instance=0;
	color_flags=0;
	color=0;
	enables=flags::ENABLES;
	bias=0;
	alpha_texture=false;
	//getTextureName();
	getColorString();
	setEnabled(true);
}

void TNBranch::init(){
	double arg[12];
	if(!left)
		return;
	INIT;
	texture_id=0;
	if(arglist.size==0)
		getArgs();
	getTextureImage();
	initArgs();
	
	//getTextureImage();
	getRoot();
	level=0;
	branch_id=root->branches;
	root->branches+=1;
	setColorFromExpr();
	if(base){
		delete base;
		base=0;
	}
	setColorFlags();
	
	if(right)
		right->init();
}

void TNBranch::initArgs(){
	double arg[16];
	if(!left)
		return;
	INIT;
	enables=flags::ENABLES;
	TNarg &args=*((TNarg *)left);
	int n=getargs(&args,arg,16);
	if(n>0)max_level=arg[0];
	if(n>1)max_splits=arg[1];
	if(n>2)length=arg[2];
	if(n>3)width=arg[3];
	if(n>4)randomness=arg[4];
	if(n>5)divergence=arg[5];
	if(n>6)flatness=arg[6];
	if(n>7)width_taper=arg[7];
	if(n>8)length_taper=arg[8];	
	if(n>9)first_bias=arg[9];
	if(n>10)min_level=arg[10];
	if(n>11)offset=arg[11];
	if(n>12)bias=arg[12];
	if(n>13)enables=arg[13];
	if(n>14)curvature=arg[14];
	if(n>15)density=arg[15];
	
	getTextureName();
}

void TNBranch::invalidateTexture(){
	if(texture_id){
		glDeleteTextures(1,&texture_id);
		texture_id=0;
	}
}
bool TNBranch::setProgram(){
	
	if(!image || !image->valid()){
		return false;
	}	
	texid=PlantMgr::textures++;
	char str[MAXSTR];
	glActiveTexture(GL_TEXTURE0+texid);
	if(texture_id==0){
		bool rgba_image=(image->gltype()==GL_RGBA)?true:false;
		alpha_texture=image->alpha_image();
		//cout<<"rgba_image="<<rgba_image<<" alpha_image="<<alpha_texture<<endl;

		glGenTextures(1, &texture_id); // Generate a unique texture ID
		glBindTexture(GL_TEXTURE_2D, texture_id);
		glTexEnvf(GL_TEXTURE_FILTER_CONTROL, GL_TEXTURE_LOD_BIAS, -1);
		glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		int w=image->width;
		int h=image->height;
		unsigned char* pixels=(unsigned char*)image->data;

		if(alpha_texture||rgba_image)
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
		else
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);
	}
	glBindTexture(GL_TEXTURE_2D, texture_id);
		
	return true;	
}

//-------------------------------------------------------------
// TNBranch::setImage(char *name) set image texture
//-------------------------------------------------------------
void TNBranch::setPlantImage(char *name){
	setImage(name);
	if(image)
		invalidateTexture();
}
void TNBranch::setColorFromExpr(){
	if(color){
		delete color;
		color=0;
	}
	if(strlen(colorexpr)){
		color=(TNcolor*)TheScene->parse_node(colorexpr);
	}
}
void TNBranch::setColorExpr(char *expr){
	if(strcmp(expr,colorexpr)){
		strcpy(colorexpr,expr);
		setColorFromExpr();
	}
	
}
void TNBranch::setColor(TNcolor* c){
	if(color)
		delete color;
	color=c;
}
TNcolor* TNBranch::getTNcolor(){
	return color;
}

void TNBranch::getArgs(){
	TNarg *arg=((TNarg *)left);
	arglist.reset();
	while(arg){
		arglist.add(arg);
		arg=arg->next();
	}
}
double TNBranch::evalArg(int i, double d){
	TNarg *arg=arglist[i];
	if(arg){
		arg->eval();
		if(!S0.constant())
			return S0.s;
	}
	return d;
}

void TNBranch::getTextureImage(){
	if(base){
		TNarg *arg=((TNarg *)base);
		while(arg){
			TNode *node=arg->left;
			if(node->typeValue()==ID_STRING){
				setPlantImage(((TNstring*)node)->value);
				if(image){
					texid=PlantMgr::textures;
					PlantMgr::textures++;
				}
				return;
			}			
			arg=arg->next();
		}
	}
}
void TNBranch::getTextureName(){
	if(base){
		TNarg *arg=((TNarg *)base);
		while(arg){
			TNode *node=arg->left;
			if(node->typeValue()==ID_STRING){
				setImageName(((TNstring*)node)->value);
				return;
			}			
			arg=arg->next();
		}
	}
}
void TNBranch::getColorString (){
	if(base){
		TNarg *arg=((TNarg *)base);
		while(arg){
			TNode *node=arg->left;
			if(node->typeValue()==ID_COLOR){
				node->valueString(colorexpr);
				return;
			}			
			arg=arg->next();
		}
	}
}

bool TNBranch::colValid(){
	return strlen(colorexpr)>0?true:false;
}
bool TNBranch::texValid(){
	return texid>0;
}

void TNBranch::setColorFlags(){
	color_flags=0;
	if(color && isColEnabled()){
		color_flags=1;
		int comps=color->comps();
		TNarg &args=*((TNarg *)color->right);
		char alpha[256]={0};
		if(args[3])
			args[3]->valueString(alpha);
		if(comps==4 && strcmp(alpha,"0"))
			color_flags=2;
		else
			color_flags=0;
	}
	if(texid>=0 && isTexEnabled() && alpha_texture && !isShapeEnabled())
		color_flags|=4; // rect mode
}

Color TNBranch::getColor(){
	Color c(1,1,1);
	if(color && isColEnabled()){
		S0.clr_cvalid();
		color->eval();
		double alpha=isTexEnabled()?S0.c.alpha():1.0;
		S0.c.set_alpha(alpha);
		c=S0.c;
	}
    return c;
}

Point TNBranch::setVector(Point vec, Point start, int lvl){

	Point v = vec.normalize();
	
	if(isPlantBranch()){
		double d=evalArg(5,divergence);
		v.x += d * SRAND;
		v.y += d * SRAND;
		v.z += d * SRAND;
		v = v.normalize(); // branch direction
	}
	
//	if(isPlantLeaf())
//	return v;
			
	double g=evalArg(6,flatness); // magnitude
	double c=evalArg(14,curvature);
	if(g==0)
		return v;

	c=clamp(c,-1,1);
	Point np,nm,vp,vf,v1,v2;
    Point rn=root->norm;
    double dp=1-v.dot(rn);
    if(dp<1e-3){
    	rn=rn+Point(1e-3,2e-4,1e-3);
    }
	nm=start-rn;
	np=start+rn;
	np=np.normalize();
	nm=nm.normalize();
    
	if(isPlantLeaf())
		vp=v;
	else{
		vp=np.cross(v);
    	vp = vp.cross(np); // flat
 	}
   	vp = vp.normalize(); 
	v1 = v * (1 - g); 
	double f=abs(c);
	if(c>=0)
		v2=np*f+vp*(1-f);
	else
		v2=nm*f+vp*(1-f);
	v = v1 + v2*g;

	return v;

}
Point TNBranch::spline(double x, Point p0, Point p1, Point p2){
  Point c=p0;
  Point b=p1*4-p0*3-p2;
  Point a=p2*2+p0*2-p1*4;
  return a*x*x+b*x+c;
}

static bool main_fork=false;
void TNBranch::fork(int opt, Point start, Point vec,Point tip,double s, double w, int lvl){
	int minlvl=0;

	//TNLeaf::left_side=0;
	TNBranch *parent=getParent();
	if(min_level<-0.1){
		if(parent->typeValue()==ID_BRANCH)
			minlvl=parent->max_level+min_level;
	}
	else if(min_level>0){
		minlvl=min_level;
		//cout<<"lvl:"<<lvl<<" minlvl:"<<minlvl<<endl;
	}
	//if(!isPlantLeaf() &&lvl<minlvl)
	if(lvl>0 && minlvl>0 && lvl<=minlvl)
		return;
	
	
	if(isPlantLeaf())
		maxlvl=parent->max_level;
	else
		maxlvl=max_level;

	level=0;
    int l=randval;
    
	double n=1;

	if(isPlantBranch()){
		n = first_bias*lerp(density,0.0,1.0,2*SRAND+0.25,1.0);
		n=n<1?1:n;
		double we=evalArg(3,width);
		
		// increase width of branches wrt parent for more distant plants
		// - otherwise only trunk is rendered and it appears "denuded"
		//if((opt & BASE_FORK)==0)
		//	we*=lerp(w,1,10,3,1); // units are screen pixels
			
		we=we>1?1:we; // clamp branch width to parent width
		for(int i=0;i<n;i++){
			level=0;
			emit(opt,start,vec,tip,s,we*w,0);
		}
	}
	else{
		TNLeaf *leaf=this;
		leaf->phase=root->seed; // random phase
		n+=max_splits;
		for(int i=0;i<n;i++){
			emit(opt,start,vec,tip,s,w,lvl);
		}
	}
	randval=l+1;
}

void TNBranch::emit(int opt, Point base, Point vec, Point tip,
		double parent_size, double parent_width, int lvl) {

	int lev = lvl;
	lev++;

	if (!root)
		init();
	level++;
	TNBranch *parent=getParent();
	if(parent->typeValue()==ID_PLANT){
		PLevel = ((double) lvl-1) / maxlvl;
		//cout<<"trunk level "<<level<<endl;
	}
	//else
	//	cout<<"branch level"<<level<<endl;

	int mode = opt;

	//Point xp; // subtract eye position in VBO transform
 
	bool first_fork = (opt & FIRST_FORK);
	bool main_branch = (opt & FIRST_EMIT);
	//bool main_branch = (opt & BASE_FORK);

	double topx = 0;
	double topy = 0;
	double botx = 1;
	double boty = 1;
	Point v, p0, p1, p2, bot, q;
	double a, b, x, y, off;
	int shader_mode = 0;
	int poly_mode = POLY_FILL;//GL_FILL;

	TNBranch *child = 0;
	if(right && (right->typeValue()==ID_BRANCH || right->typeValue()==ID_LEAF))
		child=(TNBranch *)right;
	Color c;
	double size_scale = 1.0;
	double child_width = parent_width;
	double child_size = parent_size;
	double top_offset = 0;
	double bot_offset = 0;
	double parent_length = parent_size * TheScene->wscale * root->width_scale
			/ root->size;
	double child_length = parent_length;
	double pw=1;
	double pd=1;
	
	if(isPlantBranch()){
		int n = (int)max_splits+0.4;
		pw=pow(n,max_level);
		pw=pw<max_level?max_level:pw;
		//pd = ((double) level) / pw;

		if (first_fork && lvl > 0  && parent->typeValue()==ID_BRANCH){
			child_width *= parent->width_taper;
	    }
		if (child_width <MIN_LINE_WIDTH) {
			root->addSkipped();
			return;
		}
		if (level>pw) {
			root->addSkipped();
			return;
		}
	}
	Level = ((double) lvl-1) / maxlvl;
	
	Srand = SRAND;
	Point start = base;
	
	p0 = base - vec; // previous base
	p1 = base;     // new base

	child_size *= 1 + 0.25 * randomness * SRAND;
	double cl = child_size * evalArg(2,length);
	if (!main_branch) {
		if (isPlantLeaf()) {
			b=offset*(1.0-(double)level/(max_splits + 1));
		} else {
			b = offset*URAND;
		}
		b = b <= 1 ? b : 1;

		start = p1 - vec * b;
		SRAND;
		double dw = (parent_width - child_width) / parent_width;
		bot_offset = dw * SRAND / size_scale;
		top_offset = bot_offset;

		v = setVector(vec, start, lvl);
		v = v * cl; // v = direction along last branch
	} else { // main branch
		bot_offset = tip.z;
		v = setVector(vec, start, lvl);
		v = v * cl; // v = direction along last branch
	}
	//set leaf offset from previous leaf (e.g. so flowers don't intersect leaves)
	if (isPlantLeaf()&& child && child->isPlantLeaf())
	  	//v=v*child->length_taper; // why does reducing v only affect child leaf offset?
  		v=v*0.1; // why does reducing v only affect child leaf offset?
	p2 = start + v; // new top
	bot = p2;       // new base	
	p1 = start;

	int tid = isTexEnabled() ? texid : -1;

	if (isPlantBranch() && lev >maxlvl)
		opt = LAST_EMIT;
	double bf=evalArg(12,Randval*randomness+bias);
	int rc=image_cols*image_rows-1;
	int sel=0;
	if(rc>0){
		sel=bf*rc;
		sel=clamp(sel,0,rc);
	}
	int sy=sel/image_cols;
	int sx=sel-sy*image_rows;
	
	sy=image_rows-sy-1; // invert y
	Vec4 sd(image_cols,image_rows,sx,sy);	

	if (isPlantLeaf() && isEnabled()) {  // leaf mode
		double rv = URAND; // density
		double sv = SRAND; // size
		double df = evalArg(15,density);
		if (rv > 1 - df) { // skip render if density test fails
			shader_mode = LEAF_MODE;

			c=getColor();

			double depth = bot.length();
			child_size = length * FEET / 12; // inches
			child_size *= 1 + 0.5 * randomness * sv;

			double width_ratio = 0.5 * width;
			if(image)
				width_ratio/=image->aspect();
			double size = root->width_scale * PSCALE * TheScene->wscale
					* child_size;

			int segs = max_level;
			double tilt = divergence+ 1e-4; // meta-stable if tilt=0;
			double f = 1.0 / segs;
			Point eye = p1.normalize(); // base of branch
			eye = eye.normalize();
			Point v = p2 - p1;  // branch direction
			v = v.normalize();
			Point t = v.cross(eye); // vector in a plane perpendicular to branch and eye (but edge on)
			t = t.cross(v);        // offset 90 degrees from view plane 
			t = t.normalize();
			Point r = t * tilt + v * (1 - tilt);
			r = r.normalize();
			Point pv = p2;

			 // alternate leaf side on branch
			TNLeaf *leaf = this;
			double phase = leaf->phase;
			double nscale=-1;
			if ((leaf->left_side & 1) == 0){
				phase += 0.5;
			}
			leaf->left_side++;
			
			double orientation=flatness+1e-3;
			pd=pow(Level,4);
			double bt=lerp(pd,0,1,1,1-length_taper);
			bt=bt<0?0:bt;
			
			double asize=size * bt;
			double w1 = 0.75*parent_width / TheScene->wscale/ root->size_scale;
			// leaf clusters
			Point p1s=p1;
			for (int i = 0; i < segs; i++) {
				root->addLeaf();
				double a = i * f + phase;
				double ca = COS(2.0 * PI * a);
				double sa = SIN(2.0 * PI * a);
				Point pr = r * ca + v.cross(r) * sa
						+ v * v.dot(r) * (1.0 - ca);
				pr = pr.normalize();
				p1 = p1s+ pr * w1; // need 1/2 branch width !
				p2 = p1 + pr * asize;
				
				double aspect=((double)image_cols)/image_rows;
				root->plant->collectLeafs(Vec4(p0), Vec4(p1), Vec4(p2),
						Vec4(1 - width_taper,width_ratio * asize/aspect, orientation,enables),
						Vec4(nscale,color_flags, tid, shader_mode), sd,c);
			}
		}
		else
			root->addSkipped();
	} else if (child_width >= MIN_TRIANGLE_WIDTH && isEnabled()) { // branch mode
		double nscale = lerp(child_width, MIN_LINE_WIDTH,
				10 * MIN_TRIANGLE_WIDTH, TNplant::norm_min,
				TNplant::norm_max);
		
		double w1 = child_width / TheScene->wscale;
		double w2 = w1 * (evalArg(7,width_taper));

		shader_mode = RECT_MODE;
		if (PlantMgr::spline && child_width > MIN_SPLINE_WIDTH) {
			shader_mode = SPLINE_MODE;
			root->addSpline();
		} else
			root->addBranch();
		c=getColor();
		//c = S0.c;

		tip.x = topx;
		tip.y = topy;
		tip.z = top_offset;

		if (PlantMgr::threed) {
			w1 = w1 / root->size_scale;
			w2 = w2 / root->size_scale;
		}
		double phase=0.5*Randval;

		if (PlantMgr::threed && shader_mode == SPLINE_MODE) {
			// note: first implemented this code in the shader and was a bit faster but:
			// 1) in 3d run out of shader resources (max components) unless the product
			//    of spline nodes and cone nodes is <= 32 (default cone nodes = 16 so nv <=2)
			// 2) get miss-aligment between branch segments because can't set terminal vector (v)
			//    to direction of spline end (no access to ogl parameters from shader)
			int nv = 4;
			double ds = 0.5 / nv;
			double s = 0.5;
			double r1 = w1;
			double r2 = w2;
			Point t0, t1, t2;
			t0 = p0;
			double delta = 1.0 / (nv);
			double f1, f2, dx, dy;
			Vec4 T0;
			for (int i = 0; i < nv; i++) {
				f1 = i * delta;
				f2 = (i + 1) * delta;
				dx = (1 - f1) * r1 + f1 * r2;
				dy = (1 - f2) * r1 + f2 * r2;
				t1 = spline(s, p0, p1, p2);
				t2 = spline(s + ds, p0, p1, p2);
				root->plant->collectBranches(Vec4(t0,phase), Vec4(t1), Vec4(t2),
						Vec4(dx, dy, f1, f2),
						Vec4(nscale,color_flags, tid, shader_mode), sd,c);
				t0 = t1;
				s += ds;
			}
			v = t2 - t1;
			v = v.normalize();
			v = v * cl;

			bot = t2;
			w1 = dx;
			w2 = dy;

		} else { // no spline
			root->addTriangle();
			root->plant->collectBranches(Vec4(p0,phase), Vec4(p1,bot_offset), Vec4(p2,top_offset),Vec4(w1, w2, 0, 1),
					Vec4(nscale,color_flags, tid, shader_mode), sd,c);
		}
	}
	else if (isEnabled()) { // line mode > MIN_DRAW_WIDTH
		double nscale = TNplant::norm_min;
		root->addLine();
		c=getColor();
		root->plant->collectLines(Vec4(p0), Vec4(p1), Vec4(p2),Vec4(),
				Vec4(nscale,color_flags, tid, LINE_MODE),sd,c);
	}

	if (child)
		child->fork(FIRST_FORK, bot, v, tip, child_size, child_width, lev);
	if (opt & LAST_EMIT)
		return;
	if (isPlantBranch() ) {
		double n = max_splits*lerp(density,0.0,1.0,2*SRAND+0.25,1.0);
		n = n >= 1 ? n : 1;
	
		child_width *= evalArg(7,width_taper);
		child_size *= evalArg(8,length_taper);
		if (n>=1 && child_width >MIN_LINE_WIDTH){
			emit(FIRST_EMIT, bot, v, tip, child_size, child_width, lev);
			for (int i = 1; i < n; i++) {
				emit(0, bot, v, tip, child_size, child_width, lev);
			}
		}
	}
}

void TNBranch::getRoot() {
	root=nullptr;
	NodeIF *p = getParent();
	while (p && p->typeValue() != ID_PLANT) {
		p=p->getParent();
	}
	if(p && p->typeValue() == ID_PLANT){
		root=p;
	}
}
void TNBranch::propertyString(char *s){
	TNarg *arg=(TNarg*)left;
	while(arg){
		arg->valueString(s);
		arg=arg->next();
		if(arg)
			strcat(s,",");
	}
}

void TNBranch::valueString(char *s){
	sprintf(s+strlen(s),"%s(",symbol());
	if(strlen(name_str))
		sprintf(s+strlen(s),"\"%s\",",name_str);
	
	TNarg *arg=(TNarg*)left;
	while(arg){
		arg->valueString(s+strlen(s));
		arg=arg->next();
		if(arg)
			strcat(s,",");
	}
	strcat(s,")");
	if(strlen(image_file) ||(strlen(colorexpr))){
		sprintf(s+strlen(s),"[");
		if(strlen(image_file)){
			sprintf(s+strlen(s),"\"%s\"",image_file);
			if(strlen(colorexpr))
				sprintf(s+strlen(s),",");				
		}
		if(strlen(colorexpr))
			sprintf(s+strlen(s),"%s",colorexpr);
		sprintf(s+strlen(s),"]");
	}
}

void TNBranch::save(FILE *f){
	fprintf(f,"\n%s",tabs);
	if(strlen(name_str)>0)
		fprintf(f,"%s(\"%s\"",symbol(),name_str);
	else
		fprintf(f,"%s(",symbol());
	if(left){
		if(strlen(name_str)>0)
			fprintf(f,",");
		left->save(f);
	}
	fprintf(f,")");
	if((strlen(image_file)) ||(strlen(colorexpr))){
		fprintf(f,"[");
		if(strlen(image_file)){
			fprintf(f,"\"%s\"",image_file);
			if(strlen(colorexpr))
				fprintf(f,",");				
		}
		if(strlen(colorexpr))
			fprintf(f,"%s",colorexpr);
		fprintf(f,"]");
	}
	fprintf(f,"\n%s",tabs);
	if(right)
		right->save(f);
}
void TNBranch::saveNode(FILE *f){
	fprintf(f,"%s(",symbol());
	if(strlen(name_str))
		fprintf(f,"\"%s\",",name_str);
	if(left)
		left->save(f);
	fprintf(f,")");
	if(strlen(image_file) ||(strlen(colorexpr))){
		fprintf(f,"[");
		if(strlen(image_file)){
			fprintf(f,"\"%s\"",image_file);
			if(strlen(colorexpr))
				fprintf(f,",");				
		}
		if(strlen(colorexpr))
			fprintf(f,"%s",colorexpr);
		fprintf(f,"]\n");
	}
}
NodeIF *TNBranch::removeNode(){
	return TNfunc::removeNode();
}

bool TNBranch::randomize(){
	initArgs();
	if(right && (right->typeValue()==ID_BRANCH||right->typeValue()==ID_LEAF))
		(TNBranch*)right->randomize();
	if(!isRandEnabled() || !isEnabled())
		return false;
	
	int nsave=lastn;
	lastn=getRandValue();//*123;
	setRands();
	lastn=nsave;

	char buff[512];
	char tmp[512];
	buff[0]=0;
	double orgarg[18]={0};
	double newarg[18]={0};
	int n=getargs(left,orgarg,17);
			
	double f=orgarg[4];
	
	if(strlen(name_str)>0)
		sprintf(tmp,"%s(\"%s\",",symbol(),name_str);
	else
		sprintf(tmp,"%s(",symbol());
	std::string str(tmp);

	TNode *sav=right;
	right=0;
	valueString(buff);
	right=sav;
	for(int i=0;i<n;i++)
		newarg[i]=orgarg[i];
		
	/*
	int n=getargs(&args,arg,16);
	if(n>0)max_level=arg[0];
	if(n>1)max_splits=arg[1];
	if(n>2)length=arg[2];
	if(n>3)width=arg[3];
	if(n>4)randomness=arg[4];
	if(n>5)divergence=arg[5];
	if(n>6)flatness=arg[6];
	if(n>7)width_taper=arg[7];
	if(n>8)length_taper=arg[8];	
	if(n>9)first_bias=arg[9];
	if(n>10)min_level=arg[10];
	if(n>11)offset=arg[11];
	if(n>12)bias=arg[12];
	if(n>13)enables=arg[13];
	if(n>14)curvature=arg[14];
	if(n>15)density=arg[15];}
	*/
//	newarg[0]=clamp(orgarg[0]*(1+f*s[0]),1,15);
//	newarg[1]=orgarg[1];
//	if(isPlantBranch()){
//		newarg[2]=clamp(orgarg[2]*(1+f*s[2]),0.1,2);    // length
//		newarg[3]=clamp(orgarg[3]*(1+f*s[3]),0.1,1.0);  // width
//	}
	newarg[5]=orgarg[5]*(1+f*s[5]);          // divergence
	newarg[6]=orgarg[6]*(1+f*s[6]);          // flatness
	newarg[9]=orgarg[9]+max(3*f*s[9],1.0);   // first_bias
	newarg[11]=orgarg[11]*(1+f*s[11]);       // offset
	newarg[12]=orgarg[12]*(1+f*s[12]);       // bias
	newarg[14]=clamp(orgarg[14]+0.25*f*s[14],-1,1);      // curvature
	newarg[15]=clamp(orgarg[15]*(1+0.5*f*s[15]),0.1,1);  // density
	for(int i=0;i<n;i++){
		sprintf(tmp,"%1.3g",newarg[i]);
		if(i<n-1)
			strcat(tmp,",");
		str+=tmp;
	}
	str+=")";
	uint info;
	if(isPlantBranch()){
		int ityp=4*r[8];
		switch(ityp){
		case 0:
			info=IMAGE|SPX;
			break;
		case 1:
			info=IMPORT;
			break;
		default:
		case 2:
			info=BRANCH;
			break;
		}
	}
	else{
		info=LEAF;
	}
	TNcolor* color=getTNcolor();
	if(color){
		TNcolor::rand_val=f;
		color->randomize();
		tmp[0]=0;
		color->valueString(tmp);
		setColorExpr(tmp);
		//cout<<tmp<<endl;
	}
	LinkedList<ImageSym *> list;
	images.getImageInfo(info, list);
	
	int indx=list.size*r[9];
	char *tname=list[indx]->name();
	
	cout<<"randomize "<<tname<<endl;
	setPlantImage(tname);
#ifdef DEBUG_RANDOMIZE
	cout<<"old:"<<buff<<endl;
#endif
	sprintf(tmp,str.c_str());
	TNBranch *newbranch=TheScene->parse_node(tmp);
	tmp[0]=0;
	
	if(newbranch){
		delete left;
		left=newbranch->left;
		left->setParent(this);
		if(right)
			newbranch->right=right;	
		getArgs();
		initArgs();
#ifdef DEBUG_RANDOMIZE
		buff[0]=0;
		newbranch->valueString(buff);
	    cout<<"new:"<<buff<<endl;
#endif
		return true;
	}
	else{
		lastn=nsave;
		return false;
	}
}

//-------------------------------------------------------------
// TNBranch::replaceNode
//-------------------------------------------------------------
NodeIF *TNBranch::replaceNode(NodeIF *c){
	if(!c || c->typeValue()!=typeValue())
		return 0;
	if(left)
		delete left;
	if(base)
		delete base;
	TNBranch *newbranch=(TNBranch *)c;
	left=newbranch->left;
	left->setParent(this);
	base=newbranch->base;
	setName(newbranch->nodeName());
	if(base)
		base->setParent(this);
	init();
	return this;
}

void TNBranch::eval(){
	if(right)
		right->eval();
}

int TNBranch::getChildren(LinkedList<NodeIF*>&l){
	return TNfunc::getChildren(l);
}

//************************************************************
// TNLeaf class
//************************************************************


int TNLeaf::left_side=0;
TNLeaf::TNLeaf(TNode *l, TNode *r, TNode *b) : TNBranch(l,r,b){
	setImageMgr(&leaf_mgr);
	width_taper=0.8;
	length_taper=1;
	min_level=-1;
	offset=1;
	flatness=0.2;
	phase=0;
}


Point TNLeaf::setVector(Point vec, Point start, int lvl){
	return TNBranch::setVector(vec,start,lvl);

}
